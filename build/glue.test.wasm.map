{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","~lib/rt/pure.ts","~lib/rt/tlsf.ts","~lib/gc.ts","~lib/rt.ts","~lib/util/error.ts","~lib/memory.ts","~lib/util/memory.ts","src/shared/CanvasInstruction.ts","src/shared/CanvasDirection.ts","src/shared/CanvasPatternRepetition.ts","src/shared/GlobalCompositeOperation.ts","src/shared/ImageSmoothingQuality.ts","src/shared/LineCap.ts","src/shared/LineJoin.ts","src/shared/TextAlign.ts","src/shared/TextBaseline.ts","src/shared/FillRule.ts","assembly/internal/FillStrokeStyleType.ts","assembly/renderer/CanvasRenderingContext2D.ts","~lib/arraybuffer.ts","~lib/util/number.ts","~lib/util/string.ts","~lib/typedarray.ts","~lib/map.ts","~lib/util/hash.ts","assembly/internal/getContext.ts","assembly/internal/Buffer.ts","assembly/internal/StackPointer.ts","assembly/internal/util.ts","~lib/string.ts","assembly/renderer/Image.ts","assembly/glue.test.ts","assembly/renderer/CanvasGradient.ts","assembly/renderer/CanvasPattern.ts","~lib/number.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["// Alignment guarantees\r\n\r\n// @ts-ignore: decorator\r\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\r\n// @ts-ignore: decorator\r\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\r\n// @ts-ignore: decorator\r\n@inline export const AL_MASK: usize = AL_SIZE - 1;\r\n\r\n// Extra debugging\r\n\r\n// @ts-ignore: decorator\r\n@inline export const DEBUG = true;\r\n\r\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\r\n// │                           MM info                             │ -16\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                           GC info                             │ -12\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                          runtime id                           │ -8\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                         runtime size                          │ -4\r\n// ╞═══════════════════════════════════════════════════════════════╡\r\n// │                              ...                              │ ref\r\n@unmanaged export class BLOCK {\r\n  /** Memory manager info. */\r\n  mmInfo: usize; // WASM64 needs adaption\r\n  /** Garbage collector info. */\r\n  gcInfo: u32;\r\n  /** Runtime class id. */\r\n  rtId: u32;\r\n  /** Runtime object size. */\r\n  rtSize: u32;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline export const BLOCK_OVERHEAD = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\r\n\r\n// @ts-ignore: decorator\r\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\r\n","// This file is shared with the compiler and must remain portable\r\n\r\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\r\n// │                             count                             │\r\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\r\n// │                      Typeinfo#flags [id=0]                    │ id < count\r\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\r\n// │                      Typeinfo#base  [id=0]                    │\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                              ...                              │\r\n\r\n/** Runtime type information data structure. */\r\n@unmanaged\r\nexport class Typeinfo {\r\n  /** Flags describing the shape of this class type. */\r\n  flags: TypeinfoFlags;\r\n  /** Base class id or `0` if none. */\r\n  base: u32;\r\n}\r\n\r\n/** Runtime type information flags. */\r\nexport const enum TypeinfoFlags {\r\n  /** No specific flags. */\r\n  NONE = 0,\r\n  /** Type is an `ArrayBufferView`. */\r\n  ARRAYBUFFERVIEW = 1 << 0,\r\n  /** Type is an `Array`. */\r\n  ARRAY = 1 << 1,\r\n  /** Type is a `Set`. */\r\n  SET = 1 << 2,\r\n  /** Type is a `Map`. */\r\n  MAP = 1 << 3,\r\n  /** Type is inherently acyclic. */\r\n  ACYCLIC = 1 << 4,\r\n  /** Value alignment of 1 byte. */\r\n  VALUE_ALIGN_0 = 1 << 5,\r\n  /** Value alignment of 2 bytes. */\r\n  VALUE_ALIGN_1 = 1 << 6,\r\n  /** Value alignment of 4 bytes. */\r\n  VALUE_ALIGN_2 = 1 << 7,\r\n  /** Value alignment of 8 bytes. */\r\n  VALUE_ALIGN_3 = 1 << 8,\r\n  /** Value alignment of 16 bytes. */\r\n  VALUE_ALIGN_4 = 1 << 9,\r\n  /** Value is a signed type. */\r\n  VALUE_SIGNED = 1 << 10,\r\n  /** Value is a float type. */\r\n  VALUE_FLOAT = 1 << 11,\r\n  /** Value type is nullable. */\r\n  VALUE_NULLABLE = 1 << 12,\r\n  /** Value type is managed. */\r\n  VALUE_MANAGED = 1 << 13,\r\n  /** Key alignment of 1 byte. */\r\n  KEY_ALIGN_0 = 1 << 14,\r\n  /** Key alignment of 2 bytes. */\r\n  KEY_ALIGN_1 = 1 << 15,\r\n  /** Key alignment of 4 bytes. */\r\n  KEY_ALIGN_2 = 1 << 16,\r\n  /** Key alignment of 8 bytes. */\r\n  KEY_ALIGN_3 = 1 << 17,\r\n  /** Key alignment of 16 bytes. */\r\n  KEY_ALIGN_4 = 1 << 18,\r\n  /** Key is a signed type. */\r\n  KEY_SIGNED = 1 << 19,\r\n  /** Key is a float type. */\r\n  KEY_FLOAT = 1 << 20,\r\n  /** Key type is nullable. */\r\n  KEY_NULLABLE = 1 << 21,\r\n  /** Key type is managed. */\r\n  KEY_MANAGED = 1 << 22\r\n}\r\n","import { DEBUG, BLOCK_OVERHEAD } from \"rt/common\";\r\nimport { Block, freeBlock, ROOT } from \"rt/tlsf\";\r\nimport { TypeinfoFlags } from \"shared/typeinfo\";\r\nimport { onincrement, ondecrement, onfree, onalloc } from \"./rtrace\";\r\n\r\n/////////////////////////// A Pure Reference Counting Garbage Collector ///////////////////////////\r\n// see:     https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon03Pure.pdf\r\n\r\n// ╒══════════════════════ GC Info structure ══════════════════════╕\r\n// │  3                   2                   1                    │\r\n// │1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0│\r\n// ├─┼─┴─┴─┼─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\r\n// │B│color│                     refCount                          │\r\n// └─┴─────┴───────────────────────────────────────────────────────┘\r\n// B: buffered\r\n\r\n// @ts-ignore: decorator\r\n@inline const BUFFERED_MASK: u32 = 1 << ((sizeof<u32>() * 8) - 1);\r\n// @ts-ignore: decorator\r\n@inline const COLOR_BITS = 3;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_SHIFT: u32 = ctz(BUFFERED_MASK) - COLOR_BITS;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_MASK: u32 = ((1 << COLOR_BITS) - 1) << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline export const REFCOUNT_MASK: u32 = (1 << COLOR_SHIFT) - 1;\r\n\r\n// ╒════════╤═══════════════════ Colors ═══════════════════════════╕\r\n// │ Color  │ Meaning                                              │\r\n// ├────────┼──────────────────────────────────────────────────────┤\r\n// │ BLACK  │ In use or free                                       │\r\n// │ GRAY   │ Possible member of cycle                             │\r\n// │ WHITE  │ Member of garbage cycle                              │\r\n// │ PURPLE │ Possible root of cycle                               │\r\n// │ RED    │ Candidate cycle undergoing Σ-computation *concurrent │\r\n// │ ORANGE │ Candidate cycle awaiting epoch boundary  *concurrent │\r\n// └────────┴──────────────────────────────────────────────────────┘\r\n// Acyclic detection has been decoupled, hence no GREEN.\r\n\r\n// @ts-ignore: decorator\r\n@inline const COLOR_BLACK: u32 = 0 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_GRAY: u32 = 1 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_WHITE: u32 = 2 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_PURPLE: u32 = 3 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n// @inline const COLOR_RED: u32 = 4 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n// @inline const COLOR_ORANGE: u32 = 5 << COLOR_SHIFT;\r\n\r\n// @ts-ignore: decorator\r\n@inline const VISIT_DECREMENT = 1; // guard 0\r\n// @ts-ignore: decorator\r\n@inline const VISIT_MARKGRAY = 2;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_SCAN = 3;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_SCANBLACK = 4;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_COLLECTWHITE = 5;\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nfunction __visit(ref: usize, cookie: i32): void {\r\n  if (ref < __heap_base) return;\r\n  var s = changetype<Block>(ref - BLOCK_OVERHEAD);\r\n  switch (cookie) {\r\n    case VISIT_DECREMENT: {\r\n      decrement(s);\r\n      break;\r\n    }\r\n    case VISIT_MARKGRAY: {\r\n      if (DEBUG) assert((s.gcInfo & REFCOUNT_MASK) > 0);\r\n      s.gcInfo = s.gcInfo - 1;\r\n      markGray(s);\r\n      break;\r\n    }\r\n    case VISIT_SCAN: {\r\n      scan(s);\r\n      break;\r\n    }\r\n    case VISIT_SCANBLACK: {\r\n      let info = s.gcInfo;\r\n      assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\r\n      s.gcInfo = info + 1;\r\n      if ((info & COLOR_MASK) != COLOR_BLACK) {\r\n        scanBlack(s);\r\n      }\r\n      break;\r\n    }\r\n    case VISIT_COLLECTWHITE: {\r\n      collectWhite(s);\r\n      break;\r\n    }\r\n    default: if (DEBUG) assert(false);\r\n  }\r\n}\r\n\r\n/** Increments the reference count of the specified block by one.*/\r\nfunction increment(s: Block): void {\r\n  var info = s.gcInfo;\r\n  assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\r\n  s.gcInfo = info + 1;\r\n  if (isDefined(ASC_RTRACE)) onincrement(s);\r\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\r\n}\r\n\r\n/** Decrements the reference count of the specified block by one, possibly freeing it. */\r\nfunction decrement(s: Block): void {\r\n  var info = s.gcInfo;\r\n  var rc = info & REFCOUNT_MASK;\r\n  if (isDefined(ASC_RTRACE)) ondecrement(s);\r\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\r\n  if (rc == 1) {\r\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_DECREMENT);\r\n    if (!(info & BUFFERED_MASK)) {\r\n      freeBlock(ROOT, s);\r\n    } else {\r\n      s.gcInfo = BUFFERED_MASK | COLOR_BLACK | 0;\r\n    }\r\n  } else {\r\n    if (DEBUG) assert(rc > 0);\r\n    if (!(__typeinfo(s.rtId) & TypeinfoFlags.ACYCLIC)) {\r\n      s.gcInfo = BUFFERED_MASK | COLOR_PURPLE | (rc - 1);\r\n      if (!(info & BUFFERED_MASK)) {\r\n        appendRoot(s);\r\n      }\r\n    } else {\r\n      s.gcInfo = (info & ~REFCOUNT_MASK) | (rc - 1);\r\n    }\r\n  }\r\n}\r\n\r\n/** Buffer of possible roots. */\r\n// @ts-ignore: decorator\r\n@lazy var ROOTS: usize;\r\n/** Current absolute offset into the `ROOTS` buffer. */\r\n// @ts-ignore: decorator\r\n@lazy var CUR: usize = 0;\r\n/** Current absolute end offset into the `ROOTS` buffer. */\r\n// @ts-ignore: decorator\r\n@lazy var END: usize = 0;\r\n\r\n/** Appends a block to possible roots. */\r\nfunction appendRoot(s: Block): void {\r\n  var cur = CUR;\r\n  if (cur >= END) {\r\n    growRoots(); // TBD: either that or pick a default and force collection on overflow\r\n    cur = CUR;\r\n  }\r\n  store<Block>(cur, s);\r\n  CUR = cur + sizeof<usize>();\r\n}\r\n\r\n/** Grows the roots buffer if it ran full. */\r\nfunction growRoots(): void {\r\n  var oldRoots = ROOTS;\r\n  var oldSize = CUR - oldRoots;\r\n  var newSize = max(oldSize * 2, 64 << alignof<usize>());\r\n  var newRoots = __alloc(newSize, 0);\r\n  if (isDefined(ASC_RTRACE)) onfree(changetype<Block>(newRoots - BLOCK_OVERHEAD)); // neglect unmanaged\r\n  memory.copy(newRoots, oldRoots, oldSize);\r\n  if (oldRoots) {\r\n    if (isDefined(ASC_RTRACE)) onalloc(changetype<Block>(oldRoots - BLOCK_OVERHEAD)); // neglect unmanaged\r\n    __free(oldRoots);\r\n  }\r\n  ROOTS = newRoots;\r\n  CUR = newRoots + oldSize;\r\n  END = newRoots + newSize;\r\n}\r\n\r\n/** Collects cyclic garbage. */\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __collect(): void {\r\n\r\n  // markRoots\r\n  var roots = ROOTS;\r\n  var cur = roots;\r\n  for (let pos = cur, end = CUR; pos < end; pos += sizeof<usize>()) {\r\n    let s = load<Block>(pos);\r\n    let info = s.gcInfo;\r\n    if ((info & COLOR_MASK) == COLOR_PURPLE && (info & REFCOUNT_MASK) > 0) {\r\n      markGray(s);\r\n      store<Block>(cur, s);\r\n      cur += sizeof<usize>();\r\n    } else {\r\n      if ((info & COLOR_MASK) == COLOR_BLACK && !(info & REFCOUNT_MASK)) {\r\n        freeBlock(ROOT, s);\r\n      } else {\r\n        s.gcInfo = info & ~BUFFERED_MASK;\r\n      }\r\n    }\r\n  }\r\n  CUR = cur;\r\n\r\n  // scanRoots\r\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\r\n    scan(load<Block>(pos));\r\n  }\r\n\r\n  // collectRoots\r\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\r\n    let s = load<Block>(pos);\r\n    s.gcInfo = s.gcInfo & ~BUFFERED_MASK;\r\n    collectWhite(s);\r\n  }\r\n  CUR = roots;\r\n}\r\n\r\n/** Marks a block as gray (possible member of cycle) during the collection phase. */\r\nfunction markGray(s: Block): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) != COLOR_GRAY) {\r\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_GRAY;\r\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_MARKGRAY);\r\n  }\r\n}\r\n\r\n/** Scans a block during the collection phase, determining whether it is garbage or not. */\r\nfunction scan(s: Block): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) == COLOR_GRAY) {\r\n    if ((info & REFCOUNT_MASK) > 0) {\r\n      scanBlack(s);\r\n    } else {\r\n      s.gcInfo = (info & ~COLOR_MASK) | COLOR_WHITE;\r\n      __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCAN);\r\n    }\r\n  }\r\n}\r\n\r\n/** Marks a block as black (in use) if it was found to be reachable during the collection phase. */\r\nfunction scanBlack(s: Block): void {\r\n  s.gcInfo = (s.gcInfo & ~COLOR_MASK) | COLOR_BLACK;\r\n  __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCANBLACK);\r\n}\r\n\r\n/** Collects all white (member of a garbage cycle) nodes when completing the collection phase.  */\r\nfunction collectWhite(s: Block): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) == COLOR_WHITE && !(info & BUFFERED_MASK)) {\r\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_BLACK;\r\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_COLLECTWHITE);\r\n    freeBlock(ROOT, s);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __retain(ref: usize): usize {\r\n  if (ref > __heap_base) increment(changetype<Block>(ref - BLOCK_OVERHEAD));\r\n  return ref;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __release(ref: usize): void {\r\n  if (ref > __heap_base) decrement(changetype<Block>(ref - BLOCK_OVERHEAD));\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __reset(): void {\r\n}\r\n","import { AL_BITS, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"rt/common\";\r\nimport { onfree, onalloc } from \"./rtrace\";\r\nimport { REFCOUNT_MASK } from \"./pure\";\r\n\r\n/////////////////////// The TLSF (Two-Level Segregate Fit) memory allocator ///////////////////////\r\n//                             see: http://www.gii.upv.es/tlsf/\r\n\r\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\r\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\r\n\r\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\r\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\r\n// └───────────────────────────────────────────────┴───────╨───────┘\r\n// FL: first level, SL: second level, AL: alignment, SB: small block\r\n\r\n// @ts-ignore: decorator\r\n@inline const SL_BITS: u32 = 4;\r\n// @ts-ignore: decorator\r\n@inline const SL_SIZE: usize = 1 << <usize>SL_BITS;\r\n\r\n// @ts-ignore: decorator\r\n@inline const SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\r\n// @ts-ignore: decorator\r\n@inline const SB_SIZE: usize = 1 << <usize>SB_BITS;\r\n\r\n// @ts-ignore: decorator\r\n@inline const FL_BITS: u32 = 31 - SB_BITS;\r\n\r\n// [00]: < 256B (SB)  [12]: < 1M\r\n// [01]: < 512B       [13]: < 2M\r\n// [02]: < 1K         [14]: < 4M\r\n// [03]: < 2K         [15]: < 8M\r\n// [04]: < 4K         [16]: < 16M\r\n// [05]: < 8K         [17]: < 32M\r\n// [06]: < 16K        [18]: < 64M\r\n// [07]: < 32K        [19]: < 128M\r\n// [08]: < 64K        [20]: < 256M\r\n// [09]: < 128K       [21]: < 512M\r\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\r\n// [11]: < 512K\r\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\r\n\r\n// Tags stored in otherwise unused alignment bits\r\n\r\n// @ts-ignore: decorator\r\n@inline const FREE: usize = 1 << 0;\r\n// @ts-ignore: decorator\r\n@inline const LEFTFREE: usize = 1 << 1;\r\n// @ts-ignore: decorator\r\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\r\n\r\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┼─┤ overhead   ┐\r\n// │                          size                           │0│L│F│ ◄─┐ info\r\n// ├─────────────────────────────────────────────────────────┴─┴─┴─┤   │\r\n// │                                                               │   │\r\n// │               ... additional runtime overhead ...             │   │\r\n// │                                                               │   │\r\n// ╞═══════════════════════════════════════════════════════════════╡   │      ┐ ┘\r\n// │                        if free: ◄ prev                        │ ◄─┤ usize\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                        if free: next ►                        │ ◄─┤\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                             ...                               │   │    = 0\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                        if free: back ▲                        │ ◄─┘\r\n// └───────────────────────────────────────────────────────────────┘ payload  ┘ >= MIN SIZE\r\n// F: FREE, L: LEFTFREE\r\n@unmanaged export class Block extends BLOCK {\r\n\r\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\r\n  prev: Block | null;\r\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\r\n  next: Block | null;\r\n\r\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\r\n}\r\n\r\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\r\n// `next` and `back` if free.\r\n\r\n// @ts-ignore: decorator\r\n@inline const BLOCK_MINSIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK; // prev + next + back\r\n// @ts-ignore: decorator\r\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\r\n\r\n/** Gets the left block of a block. Only valid if the left block is free. */\r\n// @ts-ignore: decorator\r\n@inline function GETFREELEFT(block: Block): Block {\r\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\r\n}\r\n\r\n/** Gets the right block of of a block by advancing to the right by its size. */\r\n// @ts-ignore: decorator\r\n@inline function GETRIGHT(block: Block): Block {\r\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\r\n}\r\n\r\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\r\n// │        0        |           flMap                            S│ ◄────┐\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                           slMap[0] S                          │ ◄─┐  │\r\n// ├───────────────────────────────────────────────────────────────┤   │  │\r\n// │                           slMap[1]                            │ ◄─┤  │\r\n// ├───────────────────────────────────────────────────────────────┤  u32 │\r\n// │                           slMap[22]                           │ ◄─┘  │\r\n// ╞═══════════════════════════════════════════════════════════════╡    usize\r\n// │                            head[0]                            │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                              ...                              │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                           head[367]                           │ ◄────┤\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                             tail                              │ ◄────┘\r\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\r\n// S: Small blocks map\r\n@unmanaged class Root {\r\n  /** First level bitmap. */\r\n  flMap: usize;\r\n}\r\n\r\n// Root constants. Where stuff is stored inside of the root structure.\r\n\r\n// @ts-ignore: decorator\r\n@inline const SL_START = sizeof<usize>();\r\n// @ts-ignore: decorator\r\n@inline const SL_END = SL_START + (FL_BITS << alignof<u32>());\r\n// @ts-ignore: decorator\r\n@inline const HL_START = (SL_END + AL_MASK) & ~AL_MASK;\r\n// @ts-ignore: decorator\r\n@inline const HL_END = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\r\n// @ts-ignore: decorator\r\n@inline const ROOT_SIZE = HL_END + sizeof<usize>();\r\n\r\n// @ts-ignore: decorator\r\n@lazy export var ROOT: Root;\r\n\r\n/** Gets the second level map of the specified first level. */\r\n// @ts-ignore: decorator\r\n@inline function GETSL(root: Root, fl: usize): u32 {\r\n  return load<u32>(\r\n    changetype<usize>(root) + (fl << alignof<u32>()),\r\n    SL_START\r\n  );\r\n}\r\n\r\n/** Sets the second level map of the specified first level. */\r\n// @ts-ignore: decorator\r\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\r\n  store<u32>(\r\n    changetype<usize>(root) + (fl << alignof<u32>()),\r\n    slMap,\r\n    SL_START\r\n  );\r\n}\r\n\r\n/** Gets the head of the free list for the specified combination of first and second level. */\r\n// @ts-ignore: decorator\r\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\r\n  return load<Block>(\r\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\r\n    HL_START\r\n  );\r\n}\r\n\r\n/** Sets the head of the free list for the specified combination of first and second level. */\r\n// @ts-ignore: decorator\r\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\r\n  store<Block>(\r\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\r\n    head,\r\n    HL_START\r\n  );\r\n}\r\n\r\n/** Gets the tail block.. */\r\n// @ts-ignore: decorator\r\n@inline function GETTAIL(root: Root): Block {\r\n  return load<Block>(\r\n    changetype<usize>(root),\r\n    HL_END\r\n  );\r\n}\r\n\r\n/** Sets the tail block. */\r\n// @ts-ignore: decorator\r\n@inline function SETTAIL(root: Root, tail: Block): void {\r\n  store<Block>(\r\n    changetype<usize>(root),\r\n    tail,\r\n    HL_END\r\n  );\r\n}\r\n\r\n/** Inserts a previously used block back into the free list. */\r\nfunction insertBlock(root: Root, block: Block): void {\r\n  if (DEBUG) assert(block); // cannot be null\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(blockInfo & FREE); // must be free\r\n\r\n  var right = GETRIGHT(block);\r\n  var rightInfo = right.mmInfo;\r\n\r\n  // merge with right block if also free\r\n  if (rightInfo & FREE) {\r\n    let newSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\r\n    if (newSize < BLOCK_MAXSIZE) {\r\n      removeBlock(root, right);\r\n      block.mmInfo = blockInfo = (blockInfo & TAGS_MASK) | newSize;\r\n      right = GETRIGHT(block);\r\n      rightInfo = right.mmInfo;\r\n      // 'back' is set below\r\n    }\r\n  }\r\n\r\n  // merge with left block if also free\r\n  if (blockInfo & LEFTFREE) {\r\n    let left = GETFREELEFT(block);\r\n    let leftInfo = left.mmInfo;\r\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\r\n    let newSize = (leftInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK);\r\n    if (newSize < BLOCK_MAXSIZE) {\r\n      removeBlock(root, left);\r\n      left.mmInfo = blockInfo = (leftInfo & TAGS_MASK) | newSize;\r\n      block = left;\r\n      // 'back' is set below\r\n    }\r\n  }\r\n\r\n  right.mmInfo = rightInfo | LEFTFREE;\r\n  // right is no longer used now, hence rightInfo is not synced\r\n\r\n  // we now know the size of the block\r\n  var size = blockInfo & ~TAGS_MASK;\r\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be a valid size\r\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\r\n\r\n  // set 'back' to itself at the end of block\r\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\r\n\r\n  // mapping_insert\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    fl = inv - clz<usize>(size);\r\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // perform insertion\r\n  var head = GETHEAD(root, fl, sl);\r\n  block.prev = null;\r\n  block.next = head;\r\n  if (head) head.prev = block;\r\n  SETHEAD(root, fl, sl, block);\r\n\r\n  // update first and second level maps\r\n  root.flMap |= (1 << fl);\r\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\r\n}\r\n\r\n/** Removes a free block from internal lists. */\r\nfunction removeBlock(root: Root, block: Block): void {\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(blockInfo & FREE); // must be free\r\n  var size = blockInfo & ~TAGS_MASK;\r\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be valid\r\n\r\n  // mapping_insert\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    fl = inv - clz<usize>(size);\r\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // link previous and next free block\r\n  var prev = block.prev;\r\n  var next = block.next;\r\n  if (prev) prev.next = next;\r\n  if (next) next.prev = prev;\r\n\r\n  // update head if we are removing it\r\n  if (block == GETHEAD(root, fl, sl)) {\r\n    SETHEAD(root, fl, sl, next);\r\n\r\n    // clear second level map if head is empty now\r\n    if (!next) {\r\n      let slMap = GETSL(root, fl);\r\n      SETSL(root, fl, slMap &= ~(1 << sl));\r\n\r\n      // clear first level map if second level is empty now\r\n      if (!slMap) root.flMap &= ~(1 << fl);\r\n    }\r\n  }\r\n  // note: does not alter left/back because it is likely that splitting\r\n  // is performed afterwards, invalidating those changes. so, the caller\r\n  // must perform those updates.\r\n}\r\n\r\n/** Searches for a free block of at least the specified size. */\r\nfunction searchBlock(root: Root, size: usize): Block | null {\r\n  // size was already asserted by caller\r\n\r\n  // mapping_search\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    const invRound = inv - SL_BITS;\r\n    let requestSize = size < halfMaxSize\r\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\r\n      : size;\r\n    fl = inv - clz<usize>(requestSize);\r\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // search second level\r\n  var slMap = GETSL(root, fl) & (~0 << sl);\r\n  var head: Block | null = null;\r\n  if (!slMap) {\r\n    // search next larger first level\r\n    let flMap = root.flMap & (~0 << (fl + 1));\r\n    if (!flMap) {\r\n      head = null;\r\n    } else {\r\n      fl = ctz<usize>(flMap);\r\n      slMap = GETSL(root, fl);\r\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\r\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\r\n    }\r\n  } else {\r\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\r\n  }\r\n  return head;\r\n}\r\n\r\n/** Prepares the specified block before (re-)use, possibly splitting it. */\r\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\r\n  // size was already asserted by caller\r\n\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(!(size & AL_MASK)); // size must be aligned so the new block is\r\n\r\n  // split if the block can hold another MINSIZE block incl. overhead\r\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\r\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\r\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\r\n\r\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\r\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\r\n    insertBlock(root, spare); // also sets 'back'\r\n\r\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\r\n  } else {\r\n    block.mmInfo = blockInfo & ~FREE;\r\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\r\n  }\r\n}\r\n\r\n/** Adds more memory to the pool. */\r\nfunction addMemory(root: Root, start: usize, end: usize): bool {\r\n  if (DEBUG) {\r\n    assert(\r\n      start <= end &&       // must be valid\r\n      !(start & AL_MASK) && // must be aligned\r\n      !(end & AL_MASK)      // must be aligned\r\n    );\r\n  }\r\n\r\n  var tail = GETTAIL(root);\r\n  var tailInfo: usize = 0;\r\n  if (tail) { // more memory\r\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\r\n\r\n    // merge with current tail if adjacent\r\n    if (start - BLOCK_OVERHEAD == changetype<usize>(tail)) {\r\n      start -= BLOCK_OVERHEAD;\r\n      tailInfo = tail.mmInfo;\r\n    } else {\r\n      // We don't do this, but a user might `memory.grow` manually\r\n      // leading to non-adjacent pages managed by TLSF.\r\n    }\r\n\r\n  } else if (DEBUG) { // first memory\r\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\r\n  }\r\n\r\n  // check if size is large enough for a free block and the tail block\r\n  var size = end - start;\r\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\r\n    return false;\r\n  }\r\n\r\n  // left size is total minus its own and the zero-length tail's header\r\n  var leftSize = size - (BLOCK_OVERHEAD << 1);\r\n  var left = changetype<Block>(start);\r\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\r\n  left.prev = null;\r\n  left.next = null;\r\n\r\n  // tail is a zero-length used block\r\n  tail = changetype<Block>(start + size - BLOCK_OVERHEAD);\r\n  tail.mmInfo = 0 | LEFTFREE;\r\n  SETTAIL(root, tail);\r\n\r\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\r\n\r\n  return true;\r\n}\r\n\r\n/** Grows memory to fit at least another block of the specified size. */\r\nfunction growMemory(root: Root, size: usize): void {\r\n  // Here, both rounding performed in searchBlock ...\r\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\r\n  if (size < halfMaxSize) { // don't round last fl\r\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\r\n    size += (1 << (invRound - clz<usize>(size))) - 1;\r\n  }\r\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\r\n  // to merge with the tail block, that's one time, otherwise it's two times.\r\n  var pagesBefore = memory.size();\r\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\r\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\r\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\r\n  if (memory.grow(pagesWanted) < 0) {\r\n    if (memory.grow(pagesNeeded) < 0) unreachable();\r\n  }\r\n  var pagesAfter = memory.size();\r\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\r\n}\r\n\r\n/** Prepares and checks an allocation size. */\r\nfunction prepareSize(size: usize): usize {\r\n  if (size >= BLOCK_MAXSIZE) throw new Error(\"allocation too large\");\r\n  return max<usize>((size + AL_MASK) & ~AL_MASK, BLOCK_MINSIZE); // align and ensure min size\r\n}\r\n\r\n/** Initilizes the root structure. */\r\nexport function initializeRoot(): void {\r\n  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\r\n  var pagesBefore = memory.size();\r\n  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\r\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\r\n  var root = changetype<Root>(rootOffset);\r\n  root.flMap = 0;\r\n  SETTAIL(root, changetype<Block>(0));\r\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\r\n    SETSL(root, fl, 0);\r\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\r\n      SETHEAD(root, fl, sl, null);\r\n    }\r\n  }\r\n  addMemory(root, (rootOffset + ROOT_SIZE + AL_MASK) & ~AL_MASK, memory.size() << 16);\r\n  ROOT = root;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar collectLock: bool = false;\r\n\r\n/** Allocates a block of the specified size. */\r\nexport function allocateBlock(root: Root, size: usize): Block {\r\n  if (DEBUG) assert(!collectLock); // must not allocate while collecting\r\n  var payloadSize = prepareSize(size);\r\n  var block = searchBlock(root, payloadSize);\r\n  if (!block) {\r\n    if (gc.auto) {\r\n      if (DEBUG) collectLock = true;\r\n      __collect();\r\n      if (DEBUG) collectLock = false;\r\n      block = searchBlock(root, payloadSize);\r\n      if (!block) {\r\n        growMemory(root, payloadSize);\r\n        block = <Block>searchBlock(root, payloadSize);\r\n        if (DEBUG) assert(block); // must be found now\r\n      }\r\n    } else {\r\n      growMemory(root, payloadSize);\r\n      block = <Block>searchBlock(root, payloadSize);\r\n      if (DEBUG) assert(block); // must be found now\r\n    }\r\n  }\r\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\r\n  block.gcInfo = 0; // RC=0\r\n  // block.rtId = 0; // set by the caller (__alloc)\r\n  block.rtSize = size;\r\n  removeBlock(root, <Block>block);\r\n  prepareBlock(root, <Block>block, payloadSize);\r\n  if (isDefined(ASC_RTRACE)) onalloc(<Block>block);\r\n  return <Block>block;\r\n}\r\n\r\n/** Reallocates a block to the specified size. */\r\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\r\n  var payloadSize = prepareSize(size);\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) {\r\n    assert(\r\n      !(blockInfo & FREE) &&           // must be used\r\n      !(block.gcInfo & ~REFCOUNT_MASK) // not buffered or != BLACK\r\n    );\r\n  }\r\n\r\n  // possibly split and update runtime size if it still fits\r\n  if (payloadSize <= (blockInfo & ~TAGS_MASK)) {\r\n    prepareBlock(root, block, payloadSize);\r\n    block.rtSize = size;\r\n    return block;\r\n  }\r\n\r\n  // merge with right free block if merger is large enough\r\n  var right = GETRIGHT(block);\r\n  var rightInfo = right.mmInfo;\r\n  if (rightInfo & FREE) {\r\n    let mergeSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\r\n    if (mergeSize >= payloadSize) {\r\n      removeBlock(root, right);\r\n      // TODO: this can yield an intermediate block larger than BLOCK_MAXSIZE, which\r\n      // is immediately split though. does this trigger any assertions / issues?\r\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\r\n      block.rtSize = size;\r\n      prepareBlock(root, block, payloadSize);\r\n      return block;\r\n    }\r\n  }\r\n\r\n  // otherwise move the block\r\n  var newBlock = allocateBlock(root, size);\r\n  newBlock.rtId = block.rtId;\r\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, size);\r\n  block.mmInfo = blockInfo | FREE;\r\n  insertBlock(root, block);\r\n  if (isDefined(ASC_RTRACE)) onfree(block);\r\n  return newBlock;\r\n}\r\n\r\n/** Frees a block. */\r\nexport function freeBlock(root: Root, block: Block): void {\r\n  var blockInfo = block.mmInfo;\r\n  assert(!(blockInfo & FREE)); // must be used (user might call through to this)\r\n  block.mmInfo = blockInfo | FREE;\r\n  insertBlock(root, block);\r\n  if (isDefined(ASC_RTRACE)) onfree(block);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __alloc(size: usize, id: u32): usize {\r\n  var root = ROOT;\r\n  if (!root) {\r\n    initializeRoot();\r\n    root = ROOT;\r\n  }\r\n  var block = allocateBlock(root, size);\r\n  block.rtId = id;\r\n  return changetype<usize>(block) + BLOCK_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __realloc(ref: usize, size: usize): usize {\r\n  if (DEBUG) assert(ROOT); // must be initialized\r\n  assert(ref != 0 && !(ref & AL_MASK)); // must exist and be aligned\r\n  return changetype<usize>(reallocateBlock(ROOT, changetype<Block>(ref - BLOCK_OVERHEAD), size)) + BLOCK_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __free(ref: usize): void {\r\n  if (DEBUG) assert(ROOT); // must be initialized\r\n  assert(ref != 0 && !(ref & AL_MASK)); // must exist and be aligned\r\n  freeBlock(ROOT, changetype<Block>(ref - BLOCK_OVERHEAD));\r\n}\r\n","/// <reference path=\"./rt/index.d.ts\" />\r\n\r\n/** Garbage collector interface. */\r\nexport namespace gc {\r\n\r\n  /** Can be set to `false` to disable automatic collection. Defaults to `true`. */\r\n  export var auto: bool = true;\r\n\r\n  /** Performs a full garbage collection cycle. */\r\n  export function collect(): void {\r\n    __collect();\r\n  }\r\n}\r\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\r\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\r\nimport { BLOCK, BLOCK_OVERHEAD } from \"./rt/common\";\r\nimport { ArrayBufferView } from \"./arraybuffer\";\r\n\r\n// @ts-ignore: decorator\r\n@builtin\r\nexport declare const __rtti_base: usize;\r\n\r\n// @ts-ignore: decorator\r\n@builtin @unsafe\r\nexport declare function __visit_globals(cookie: u32): void;\r\n\r\n// @ts-ignore: decorator\r\n@builtin @unsafe\r\nexport declare function __visit_members(ref: usize, cookie: u32): void;\r\n\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport function __typeinfo(id: u32): TypeinfoFlags {\r\n  var ptr = __rtti_base;\r\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\r\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport function __instanceof(ref: usize, superId: u32): bool { // keyword\r\n  var id = changetype<BLOCK>(ref - BLOCK_OVERHEAD).rtId;\r\n  var ptr = __rtti_base;\r\n  if (id <= load<u32>(ptr)) {\r\n    do if (id == superId) return true;\r\n    while (id = changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\r\n  }\r\n  return false;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport function __allocArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\r\n  var array = __alloc(offsetof<i32[]>(), id);\r\n  var bufferSize = <usize>length << alignLog2;\r\n  var buffer = __alloc(bufferSize, idof<ArrayBuffer>());\r\n  store<usize>(array, __retain(buffer), offsetof<ArrayBufferView>(\"buffer\"));\r\n  store<usize>(array, buffer, offsetof<ArrayBufferView>(\"dataStart\"));\r\n  store<u32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\r\n  store<i32>(changetype<usize>(array), length, offsetof<i32[]>(\"length_\"));\r\n  if (data) memory.copy(buffer, data, bufferSize);\r\n  return array;\r\n}\r\n\r\n// These are provided by the respective implementation, included as another entry file by asc:\r\n\r\n// @builtin @unsafe\r\n// export declare function __alloc(size: usize, id: u32): usize;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __realloc(ref: usize, size: usize): usize;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __free(ref: usize): void;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __retain(ref: usize): usize;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __release(ref: usize): void;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __collect(): void;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __visit(ref: usize, cookie: u32): void;\r\n","// Common error messages for use accross the standard library. Keeping error messages compact\r\n// and reusing them where possible ensures minimal static data in binaries.\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_EMPTYARRAY: string = \"Array is empty\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\r\n","import { memcmp, memmove, memset } from \"./util/memory\";\r\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\r\n\r\n/** Memory manager interface. */\r\nexport namespace memory {\r\n\r\n  /** Gets the size of the memory in pages. */\r\n  // @ts-ignore: decorator\r\n  @builtin\r\n  export declare function size(): i32;\r\n\r\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export declare function grow(pages: i32): i32;\r\n\r\n  /** Fills a section in memory with the specified byte value. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export function fill(dst: usize, c: u8, n: usize): void {\r\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\r\n  }\r\n\r\n  /** Copies a section of memory to another. Has move semantics. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export function copy(dst: usize, src: usize, n: usize): void {\r\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\r\n  }\r\n\r\n  /** Initializes a memory segment. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\r\n    throw new Error(E_NOTIMPLEMENTED);\r\n  }\r\n\r\n  /** Drops a memory segment. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function drop(segmentIndex: u32): void {\r\n    throw new Error(E_NOTIMPLEMENTED);\r\n  }\r\n\r\n  /** Repeats a section of memory at a specific address. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\r\n    var index: usize = 0;\r\n    var total = srcLength * count;\r\n    while (index < total) {\r\n      memory.copy(dst + index, src, srcLength);\r\n      index += srcLength;\r\n    }\r\n  }\r\n\r\n  /** Compares a section of memory to another. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\r\n    return memcmp(vl, vr, n);\r\n  }\r\n}\r\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\r\n  if (ASC_SHRINK_LEVEL > 1) {\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    let w: u32, x: u32;\r\n\r\n    // copy 1 byte each until src is aligned to 4 bytes\r\n    while (n && (src & 3)) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      n--;\r\n    }\r\n\r\n    // if dst is aligned to 4 bytes as well, copy 4 bytes each\r\n    if ((dest & 3) == 0) {\r\n      while (n >= 16) {\r\n        store<u32>(dest     , load<u32>(src     ));\r\n        store<u32>(dest +  4, load<u32>(src +  4));\r\n        store<u32>(dest +  8, load<u32>(src +  8));\r\n        store<u32>(dest + 12, load<u32>(src + 12));\r\n        src += 16; dest += 16; n -= 16;\r\n      }\r\n      if (n & 8) {\r\n        store<u32>(dest    , load<u32>(src    ));\r\n        store<u32>(dest + 4, load<u32>(src + 4));\r\n        dest += 8; src += 8;\r\n      }\r\n      if (n & 4) {\r\n        store<u32>(dest, load<u32>(src));\r\n        dest += 4; src += 4;\r\n      }\r\n      if (n & 2) { // drop to 2 bytes each\r\n        store<u16>(dest, load<u16>(src));\r\n        dest += 2; src += 2;\r\n      }\r\n      if (n & 1) { // drop to 1 byte\r\n        store<u8>(dest++, load<u8>(src++));\r\n      }\r\n      return;\r\n    }\r\n\r\n    // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\r\n    // doing shifts if faster when copying enough bytes (here: 32 or more)\r\n    if (n >= 32) {\r\n      switch (dest & 3) {\r\n        // known to be != 0\r\n        case 1: {\r\n          w = load<u32>(src);\r\n          store<u8>(dest++, load<u8>(src++));\r\n          store<u8>(dest++, load<u8>(src++));\r\n          store<u8>(dest++, load<u8>(src++));\r\n          n -= 3;\r\n          while (n >= 17) {\r\n            x = load<u32>(src + 1);\r\n            store<u32>(dest, w >> 24 | x << 8);\r\n            w = load<u32>(src + 5);\r\n            store<u32>(dest + 4, x >> 24 | w << 8);\r\n            x = load<u32>(src + 9);\r\n            store<u32>(dest + 8, w >> 24 | x << 8);\r\n            w = load<u32>(src + 13);\r\n            store<u32>(dest + 12, x >> 24 | w << 8);\r\n            src += 16; dest += 16; n -= 16;\r\n          }\r\n          break;\r\n        }\r\n        case 2: {\r\n          w = load<u32>(src);\r\n          store<u8>(dest++, load<u8>(src++));\r\n          store<u8>(dest++, load<u8>(src++));\r\n          n -= 2;\r\n          while (n >= 18) {\r\n            x = load<u32>(src + 2);\r\n            store<u32>(dest, w >> 16 | x << 16);\r\n            w = load<u32>(src + 6);\r\n            store<u32>(dest + 4, x >> 16 | w << 16);\r\n            x = load<u32>(src + 10);\r\n            store<u32>(dest + 8, w >> 16 | x << 16);\r\n            w = load<u32>(src + 14);\r\n            store<u32>(dest + 12, x >> 16 | w << 16);\r\n            src += 16; dest += 16; n -= 16;\r\n          }\r\n          break;\r\n        }\r\n        case 3: {\r\n          w = load<u32>(src);\r\n          store<u8>(dest++, load<u8>(src++));\r\n          n -= 1;\r\n          while (n >= 19) {\r\n            x = load<u32>(src + 3);\r\n            store<u32>(dest, w >> 8 | x << 24);\r\n            w = load<u32>(src + 7);\r\n            store<u32>(dest + 4, x >> 8 | w << 24);\r\n            x = load<u32>(src + 11);\r\n            store<u32>(dest + 8, w >> 8 | x << 24);\r\n            w = load<u32>(src + 15);\r\n            store<u32>(dest + 12, x >> 8 | w << 24);\r\n            src += 16; dest += 16; n -= 16;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // copy remaining bytes one by one\r\n    if (n & 16) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    if (n & 8) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    if (n & 4) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    if (n & 2) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    if (n & 1) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n  if (dest === src) return;\r\n  if (ASC_SHRINK_LEVEL < 1) {\r\n    if (src + n <= dest || dest + n <= src) {\r\n      memcpy(dest, src, n);\r\n      return;\r\n    }\r\n  }\r\n  if (dest < src) {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while (dest & 7) {\r\n        if (!n) return;\r\n        --n;\r\n        store<u8>(dest++, load<u8>(src++));\r\n      }\r\n      while (n >= 8) {\r\n        store<u64>(dest, load<u64>(src));\r\n        n    -= 8;\r\n        dest += 8;\r\n        src  += 8;\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while ((dest + n) & 7) {\r\n        if (!n) return;\r\n        store<u8>(dest + --n, load<u8>(src + n));\r\n      }\r\n      while (n >= 8) {\r\n        n -= 8;\r\n        store<u64>(dest + n, load<u64>(src + n));\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest + --n, load<u8>(src + n));\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n  if (ASC_SHRINK_LEVEL > 1) {\r\n    while (n) {\r\n      store<u8>(dest++, c);\r\n      --n;\r\n    }\r\n  } else {\r\n    // fill head and tail with minimal branching\r\n    if (!n) return;\r\n    store<u8>(dest, c);\r\n    store<u8>(dest + n - 1, c);\r\n    if (n <= 2) return;\r\n\r\n    store<u8>(dest + 1, c);\r\n    store<u8>(dest + 2, c);\r\n    store<u8>(dest + n - 2, c);\r\n    store<u8>(dest + n - 3, c);\r\n    if (n <= 6) return;\r\n    store<u8>(dest + 3, c);\r\n    store<u8>(dest + n - 4, c);\r\n    if (n <= 8) return;\r\n\r\n    // advance pointer to align it at 4-byte boundary\r\n    let k: usize = -dest & 3;\r\n    dest += k;\r\n    n -= k;\r\n    n &= -4;\r\n\r\n    let c32: u32 = <u32>-1 / 255 * c;\r\n\r\n    // fill head/tail up to 28 bytes each in preparation\r\n    store<u32>(dest, c32);\r\n    store<u32>(dest + n - 4, c32);\r\n    if (n <= 8) return;\r\n    store<u32>(dest + 4, c32);\r\n    store<u32>(dest + 8, c32);\r\n    store<u32>(dest + n - 12, c32);\r\n    store<u32>(dest + n - 8, c32);\r\n    if (n <= 24) return;\r\n    store<u32>(dest + 12, c32);\r\n    store<u32>(dest + 16, c32);\r\n    store<u32>(dest + 20, c32);\r\n    store<u32>(dest + 24, c32);\r\n    store<u32>(dest + n - 28, c32);\r\n    store<u32>(dest + n - 24, c32);\r\n    store<u32>(dest + n - 20, c32);\r\n    store<u32>(dest + n - 16, c32);\r\n\r\n    // align to a multiple of 8\r\n    k = 24 + (dest & 4);\r\n    dest += k;\r\n    n -= k;\r\n\r\n    // copy 32 bytes each\r\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\r\n    while (n >= 32) {\r\n      store<u64>(dest, c64);\r\n      store<u64>(dest + 8, c64);\r\n      store<u64>(dest + 16, c64);\r\n      store<u64>(dest + 24, c64);\r\n      n -= 32;\r\n      dest += 32;\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\r\n  if (vl == vr) return 0;\r\n  if (ASC_SHRINK_LEVEL < 2) {\r\n    if ((vl & 7) == (vr & 7)) {\r\n      while (vl & 7) {\r\n        if (!n) return 0;\r\n        let a = <i32>load<u8>(vl);\r\n        let b = <i32>load<u8>(vr);\r\n        if (a != b) return a - b;\r\n        n--; vl++; vr++;\r\n      }\r\n      while (n >= 8) {\r\n        if (load<u64>(vl) != load<u64>(vr)) break;\r\n        vl += 8;\r\n        vr += 8;\r\n        n  -= 8;\r\n      }\r\n    }\r\n  }\r\n  while (n--) {\r\n    let a = <i32>load<u8>(vl);\r\n    let b = <i32>load<u8>(vr);\r\n    if (a != b) return a - b;\r\n    vl++; vr++;\r\n  }\r\n  return 0;\r\n}\r\n","export const enum CanvasInstruction {\r\n  Arc = 0,\r\n  ArcTo = 1,\r\n  BeginPath = 2,\r\n  BezierCurveTo = 3,\r\n  Clip = 4,\r\n  ClosePath = 5,\r\n  Commit = 6,\r\n  ClearRect = 7,\r\n  Direction = 8,\r\n  DrawFocusIfNeeded = 9,\r\n  DrawImage = 10,\r\n  Ellipse = 11,\r\n  Fill = 12,\r\n  FillGradient = 13,\r\n  FillPattern = 14,\r\n  FillRect = 15,\r\n  FillStyle = 16,\r\n  FillText = 17,\r\n  FillTextWidth = 18,\r\n  Filter = 19,\r\n  Font = 20,\r\n  GlobalAlpha = 21,\r\n  GlobalCompositeOperation = 22,\r\n  ImageSmoothingEnabled = 23,\r\n  ImageSmoothingQuality = 24,\r\n  Inspect = 25,\r\n  LineCap = 26,\r\n  LineDash = 27,\r\n  LineDashOffset = 28,\r\n  LineJoin = 29,\r\n  LineTo = 30,\r\n  LineWidth = 31,\r\n  MiterLimit = 32,\r\n  MoveTo = 33,\r\n  QuadraticCurveTo = 34,\r\n  Rect = 35,\r\n  Restore = 36,\r\n  Rotate = 37,\r\n  Save = 38,\r\n  Scale = 39,\r\n  SetTransform = 40,\r\n  ShadowBlur = 41,\r\n  ShadowColor = 42,\r\n  ShadowOffsetX = 43,\r\n  ShadowOffsetY = 44,\r\n  Stroke = 45,\r\n  StrokeGradient = 46,\r\n  StrokePattern = 47,\r\n  StrokeRect = 48,\r\n  StrokeStyle = 49,\r\n  StrokeText = 50,\r\n  StrokeTextWidth = 51,\r\n  TextAlign = 52,\r\n  TextBaseline = 53,\r\n  Translate = 54,\r\n  Transform = 55,\r\n}\r\n","/**\r\n * The CanvasRenderingContext2D.direction value of the Canvas 2D API specifies the current text\r\n * direction used to draw text onto the canvas.\r\n */\r\nexport enum CanvasDirection {\r\n  /**\r\n   * The text direction is left-to-right.\r\n   */\r\n  ltr = 0,\r\n  /**\r\n   * The text direction is right-to-left.\r\n   */\r\n  rtl = 1,\r\n  /**\r\n   * The text direction is inherited from the <canvas> element or the Document as appropriate. Default value.\r\n   */\r\n  inherit = 2,\r\n}\r\n","/**\r\n * A value indicating how to repeat the pattern's image.\r\n */\r\nexport enum CanvasPatternRepetition {\r\n  /**\r\n   * A canvas pattern repetition indicating a repeating pattern in both the x and y directions.\r\n   */\r\n  repeat = 0,\r\n  /**\r\n   * A canvas pattern repetition indicating a repeating pattern only the x direction.\r\n   */\r\n  repeat_x = 1,\r\n  /**\r\n   * A canvas pattern repetition indicating a repeating pattern only the y direction.\r\n   */\r\n  repeat_y = 2,\r\n  /**\r\n   * A canvas pattern repetition indicationg no repeating pattern.\r\n   */\r\n  no_repeat = 3,\r\n}\r\n","/**\r\n * The GlobalCompositeOperation enum for the globalCompositeOperation property sets the type\r\n * of compositing operation to apply when drawing new shapes.\r\n */\r\nexport enum GlobalCompositeOperation {\r\n  /**\r\n   * This is the default setting and draws new shapes on top of the existing canvas content\r\n   */\r\n  source_over = 0,\r\n  /**\r\n   * The new shape is drawn only where both the new shape and the destination canvas overlap.\r\n   * Everything else is made transparent.\r\n   */\r\n  source_in = 1,\r\n  /**\r\n   * The new shape is drawn where it doesn't overlap the existing canvas content.\r\n   */\r\n  source_out = 2,\r\n  /**\r\n   * The new shape is only drawn where it overlaps the existing canvas content.\r\n   */\r\n  source_atop = 3,\r\n  /**\r\n   * New shapes are drawn behind the existing canvas content.\r\n   */\r\n  destination_over = 4,\r\n  /**\r\n   * The existing canvas content is kept where both the new shape and existing canvas content\r\n   * overlap. Everything else is made transparent.\r\n   */\r\n  destination_in = 5,\r\n  /**\r\n   * The existing content is kept where it doesn't overlap the new shape.\r\n   */\r\n  destination_out = 6,\r\n  /**\r\n   * The existing canvas is only kept where it overlaps the new shape. The new shape is drawn\r\n   * behind the canvas content.\r\n   */\r\n  destination_atop = 7,\r\n  /**\r\n   * Where both shapes overlap the color is determined by adding color values.\r\n   */\r\n  lighter = 8,\r\n  /**\r\n   * Only the new shape is shown.\r\n   */\r\n  copy = 9,\r\n  /**\r\n   * Shapes are made transparent where both overlap and drawn normal everywhere else.\r\n   */\r\n  xor = 10,\r\n  /**\r\n   * The pixels are of the top layer are multiplied with the corresponding pixel of the bottom\r\n   * layer. A darker picture is the result.\r\n   */\r\n  multiply = 11,\r\n  /**\r\n   * The pixels are inverted, multiplied, and inverted again. A lighter picture is the result\r\n   * (opposite of multiply)\r\n   */\r\n  screen = 12,\r\n  /**\r\n   * A combination of multiply and screen. Dark parts on the base layer become darker, and light\r\n   * parts become lighter.\r\n   */\r\n  overlay = 13,\r\n  /**\r\n   * Retains the darkest pixels of both layers.\r\n   */\r\n  darken = 14,\r\n  /**\r\n   * Retains the lightest pixels of both layers.\r\n   */\r\n  lighten = 15,\r\n  /**\r\n   * Divides the bottom layer by the inverted top layer.\r\n   */\r\n  color_dodge = 16,\r\n  /**\r\n   * Divides the inverted bottom layer by the top layer, and then inverts the result.\r\n   */\r\n  color_burn = 17,\r\n  /**\r\n   * A combination of multiply and screen like overlay, but with top and bottom layer swapped.\r\n   */\r\n  hard_light = 18,\r\n  /**\r\n   * A softer version of hard-light. Pure black or white does not result in pure black or white.\r\n   */\r\n  soft_light = 19,\r\n  /**\r\n   * Subtracts the bottom layer from the top layer or the other way round to always get a positive\r\n   * value.\r\n   */\r\n  difference = 20,\r\n  /**\r\n   * Like difference, but with lower contrast.\r\n   */\r\n  exclusion = 21,\r\n  /**\r\n   * Preserves the luma and chroma of the bottom layer, while adopting the hue of the top layer.\r\n   */\r\n  hue = 22,\r\n  /**\r\n   * Preserves the luma and hue of the bottom layer, while adopting the chroma of the top layer.\r\n   */\r\n  saturation = 23,\r\n  /**\r\n   * Preserves the luma of the bottom layer, while adopting the hue and chroma of the top layer.\r\n   */\r\n  color = 24,\r\n  /**\r\n   * Preserves the hue and chroma of the bottom layer, while adopting the luma of the top layer.\r\n   */\r\n  luminosity = 25,\r\n}\r\n","export enum ImageSmoothingQuality {\r\n  low = 0,\r\n  medium = 1,\r\n  high = 2,\r\n}","export enum LineCap {\r\n  butt = 0,\r\n  round = 1,\r\n  square = 2,\r\n}\r\n","/**\r\n * The LineJoin enum responsible for setting the lineJoin property of the Canvas 2D API determines\r\n * the shape used to join two line segments where they meet.\r\n *\r\n * This property has no effect wherever two connected segments have the same direction, because no\r\n * joining area will be added in this case. Degenerate segments with a length of zero (i.e., with\r\n * all endpoints and control points at the exact same position) are also ignored.\r\n */\r\nexport enum LineJoin {\r\n  /**\r\n   * Rounds off the corners of a shape by filling an additional sector of disc centered at the\r\n   * common endpoint of connected segments. The radius for these rounded corners is equal to the\r\n   * line width.\r\n   */\r\n  bevel = 0,\r\n  /**\r\n   * Fills an additional triangular area between the common endpoint of connected segments, and the\r\n   * separate outside rectangular corners of each segment.\r\n   */\r\n  round = 1,\r\n  /**\r\n   * Connected segments are joined by extending their outside edges to connect at a single point,\r\n   * with the effect of filling an additional lozenge-shaped area. This setting is affected by the\r\n   * miterLimit property. Default value.\r\n   */\r\n  miter = 2,\r\n}","/**\r\n * The TextAlign enum specifies the current text alignment used when drawing text.\r\n *\r\n * The alignment is relative to the x value of the fillText() method. For example, if textAlign is\r\n * \"center\", then the text's left edge will be at x - (textWidth / 2).\r\n */\r\nexport enum TextAlign {\r\n  /**\r\n   * The text is left-aligned.\r\n   **/\r\n  left = 0,\r\n  /**\r\n   * The text is right-aligned.\r\n   **/\r\n  right = 1,\r\n  /**\r\n   * The text is centered.\r\n   **/\r\n  center = 2,\r\n  /**\r\n   * The text is aligned at the normal start of the line (left-aligned for left-to-right locales, right-aligned for right-to-left locales).\r\n   **/\r\n  start = 3,\r\n  /**\r\n   * The text is aligned at the normal end of the line (right-aligned for left-to-right locales, left-aligned for right-to-left locales).\r\n   **/\r\n  end = 4,\r\n}\r\n","/**\r\n * The TextBasline enum specifies the current text baseline used when drawing text.\r\n */\r\nexport enum TextBaseline {\r\n  /**\r\n   * The text baseline is the top of the em square.\r\n   **/\r\n  top = 0,\r\n  /**\r\n   * The text baseline is the hanging baseline. (Used by Tibetan and other Indic scripts.)\r\n   **/\r\n  hanging = 1,\r\n  /**\r\n   * The text baseline is the middle of the em square.\r\n   **/\r\n  middle = 2,\r\n  /**\r\n   * The text baseline is the normal alphabetic baseline. Default value.\r\n   **/\r\n  alphabetic = 3,\r\n  /**\r\n   * The text baseline is the ideographic baseline; this is the bottom of the body of the characters, if the main body of characters protrudes beneath the alphabetic baseline. (Used by Chinese, Japanese, and Korean scripts.)\r\n   **/\r\n  ideographic = 4,\r\n  /**\r\n   * The text baseline is the bottom of the bounding box. This differs from the ideographic baseline in that the ideographic baseline doesn't consider descenders.\r\n   **/\r\n  bottom = 5,\r\n}","export enum FillRule {\r\n  nonzero = 0,\r\n  evenodd = 1,\r\n}\r\n","//#endregion EXTERNALS\r\nexport const enum FillStrokeStyleType {\r\n  String = 0,\r\n  CanvasPattern = 1,\r\n  CanvasGradient = 2\r\n}\r\n","import { CanvasInstruction } from \"../../src/shared/CanvasInstruction\";\r\nimport { Buffer } from \"../internal/Buffer\";\r\nimport { DOMMatrix } from \"./DOMMatrix\";\r\nimport { CanvasDirection } from \"../../src/shared/CanvasDirection\";\r\nimport { CanvasPattern } from \"./CanvasPattern\";\r\nimport { CanvasGradient } from \"./CanvasGradient\";\r\nimport { Image, getImageID } from \"./Image\";\r\nimport { CanvasPatternRepetition } from \"../../src/shared/CanvasPatternRepetition\";\r\nimport { GlobalCompositeOperation } from \"../../src/shared/GlobalCompositeOperation\";\r\nimport { ImageSmoothingQuality } from \"../../src/shared/ImageSmoothingQuality\";\r\nimport { LineCap } from \"../../src/shared/LineCap\";\r\nimport { LineJoin } from \"../../src/shared/LineJoin\";\r\nimport { TextAlign } from \"../../src/shared/TextAlign\";\r\nimport { TextBaseline } from \"../../src/shared/TextBaseline\";\r\nimport { arraysEqual } from \"../internal/util\";\r\nimport { Path2DElement } from \"../internal/Path2DElement\";\r\nimport { FillRule } from \"../../src/shared/FillRule\";\r\nimport { STORE, LOAD } from \"../internal/util\";\r\nimport { StackPointer } from \"../internal/StackPointer\";\r\nimport { CanvasStack } from \"./CanvasStack\";\r\nimport { FillStrokeStyleType } from \"../internal/FillStrokeStyleType\";\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"render\")\r\ndeclare function render(ctxid: i32, data: usize): void;\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"createLinearGradient\")\r\ndeclare function createLinearGradient(id: i32, x0: f64, y0: f64, x1: f64, y1: f64): i32;\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"createRadialGradient\")\r\ndeclare function createRadialGradient(id: i32, x0: f64, y0: f64, r0: f64, x1: f64, y1: f64, r1: f64): i32;\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"createPattern\")\r\ndeclare function createPattern(ctxid: i32, imageid: i32, repetition: CanvasPatternRepetition): i32;\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"measureText\")\r\ndeclare function measureText(id: i32, text: string): f64;\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"isPointInPath\")\r\ndeclare function isPointInPath(id: i32, x: f64, y: f64, fillRule: FillRule): bool;\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"isPointInStroke\")\r\ndeclare function isPointInStroke(id: i32, x: f64, y: f64): bool;\r\nvar defaultBlack: string = \"#000\";\r\nvar defaultNone: string = \"none\";\r\nvar defaultFont: string = \"10px sans-serif\";\r\nvar defaultShadowColor: string = \"rgba(0, 0, 0, 0)\";\r\nvar defaultLineDash: Float64Array = new Float64Array(0);\r\n\r\n//#region ARRAYBUFFERINITIALIZER\r\n/**\r\n * Utility function for setting the given ArrayBuffer to the identity 2d transform matrix inline.\r\n *\r\n * @param ArrayBuffer buff\r\n */\r\n// @ts-ignore: Decorators are valid here\r\nfunction setArrayBufferIdentity(buff: usize): usize {\r\n  STORE<f64>(buff, 0, 1.0);\r\n  STORE<f64>(buff, 1, 0.0);\r\n  STORE<f64>(buff, 2, 0.0);\r\n  STORE<f64>(buff, 3, 1.0);\r\n  STORE<f64>(buff, 4, 0.0);\r\n  STORE<f64>(buff, 5, 0.0);\r\n  return buff;\r\n}\r\n\r\nfunction initializeStackPointer(pointer: StackPointer<CanvasStack>): StackPointer<CanvasStack> {\r\n  let stack = pointer.reference();\r\n  stack.a = 1;\r\n  stack.d = 1;\r\n  stack.direction = CanvasDirection.inherit;\r\n  stack.fillStyleType = FillStrokeStyleType.String;\r\n  stack.fillStyleString = defaultBlack;\r\n  __retain(changetype<usize>(defaultBlack));\r\n  stack.filter = defaultNone;\r\n  __retain(changetype<usize>(defaultNone));\r\n  stack.font = defaultFont;\r\n  __retain(changetype<usize>(defaultFont));\r\n  stack.globalAlpha = 1.0;\r\n  stack.globalCompositeOperation = GlobalCompositeOperation.source_over;\r\n  stack.imageSmoothingEnabled = true;\r\n  stack.imageSmoothingQuality = ImageSmoothingQuality.low;\r\n  stack.lineCap = LineCap.butt;\r\n  stack.lineDash = defaultLineDash;\r\n  stack.lineJoin = LineJoin.miter;\r\n  stack.lineWidth = 1.0;\r\n  stack.miterLimit = 10.0;\r\n  stack.shadowBlur = 0.0;\r\n  stack.shadowColor = defaultShadowColor;\r\n  stack.strokeStyleString = defaultBlack;\r\n  __retain(changetype<usize>(defaultBlack));\r\n  __retain(changetype<usize>(defaultShadowColor));\r\n  return pointer;\r\n}\r\n\r\n\r\n/** The path element initializer. */\r\nfunction createPathElements(): StackPointer<Path2DElement> {\r\n  let pointer = StackPointer.create<Path2DElement>(0x1000);\r\n  let reference = pointer.reference();\r\n  reference.instruction = CanvasInstruction.BeginPath;\r\n  reference.count = 0;\r\n  reference.updateTransform = true;\r\n  reference.transformA = 1.0;\r\n  reference.transformD = 1.0;\r\n  return pointer;\r\n}\r\n\r\n/**\r\n * An AssemblyScript virtual representation of an actual CanvasRenderingContext2D Object. The\r\n * CanvasRenderingContext2D interface, part of the Canvas API, provides the 2D rendering context\r\n * for the drawing surface of a <canvas> element. It is used for drawing shapes, text, images, and\r\n * other objects.\r\n */\r\n@sealed\r\nexport class CanvasRenderingContext2D extends Buffer<CanvasInstruction> {\r\n  /**\r\n   * The component's external object id. It initializes to -1, which will never be an actual object\r\n   * id externally. If it actually returns -1, it will cause the host to error saying it cannot\r\n   * find the specified canvas context.\r\n   */\r\n  private id: i32 = -1;\r\n\r\n  /**\r\n   * The virutal stack index offset that keeps track of the number of `save()` and `restore()`\r\n   * stack states.\r\n   */\r\n  private _stackOffset: u8 = <u8>0;\r\n\r\n  //#region CREATELINEARGRADIENT\r\n  /**\r\n   * The CanvasRenderingContext2D.createLinearGradient() method of the Canvas 2D API creates a\r\n   * gradient along the line connecting two given coordinates.\r\n   *\r\n   * @param {f64} x0 - A float number representing the first x coordinate point of the gradient.\r\n   * @param {f64} y0 - A float number representing the first y coordinate point of the gradient.\r\n   * @param {f64} x1 - A float number representing the second x coordinate point of the gradient.\r\n   * @param {f64} y1 - A float number representing the second y coordinate point of the gradient.\r\n   */\r\n  public createLinearGradient(x0: f64, y0: f64, x1: f64, y1: f64): CanvasGradient {\r\n    var id: i32 = createLinearGradient(this.id, x0, y0, x1, y1);\r\n    var result: CanvasGradient = new CanvasGradient();\r\n    store<i32>(changetype<usize>(result), id, offsetof<CanvasGradient>(\"id\"));\r\n    return result;\r\n  }\r\n  //#endregion CREATELINEARGRADIENT\r\n\r\n  //#region CREATERADIALGRADIENT\r\n  /**\r\n   * The CanvasRenderingContext2D.createRadialGradient() method of the Canvas 2D API creates a\r\n   * radial gradient using the size and coordinates of two circles.\r\n   *\r\n   * @param {f64} x0 - The x-axis coordinate of the start circle.\r\n   * @param {f64} y0 - The y-axis coordinate of the start circle.\r\n   * @param {f64} r0 - The radius of the start circle. Must be non-negative and finite.\r\n   * @param {f64} x1 - The x-axis coordinate of the end circle.\r\n   * @param {f64} y1 - The y-axis coordinate of the end circle.\r\n   * @param {f64} r1 - The radius of the end circle. Must be non-negative and finite.\r\n   */\r\n  public createRadialGradient(x0: f64, y0: f64, r0: f64, x1: f64, y1: f64, r1: f64): CanvasGradient {\r\n    var id: i32 = createRadialGradient(this.id, x0, y0, r0, x1, y1, r1);\r\n    var result: CanvasGradient = new CanvasGradient();\r\n    store<i32>(changetype<usize>(result), id, offsetof<CanvasGradient>(\"id\"));\r\n    return result;\r\n  }\r\n  //#endregion CREATERADIALGRADIENT\r\n\r\n  private _stack: StackPointer<CanvasStack> = initializeStackPointer(StackPointer.create<CanvasStack>(0xFF));\r\n\r\n  //#region TRANSFORM\r\n\r\n  /**\r\n   * An ArrayBuffer that contains a single transform value that represents the last transform\r\n   * written by a `setTransform()` operation\r\n   */\r\n  private _currentTransform: ArrayBuffer = changetype<ArrayBuffer>(setArrayBufferIdentity(__alloc(sizeof<f64>() * 6, idof<ArrayBuffer>())));\r\n\r\n  /**\r\n   * An operation that generates a DOMMatrix reflecting the current transform on the `_transformStack\r\n   */\r\n  @inline\r\n  private _getTransform(): DOMMatrix {\r\n    var result: DOMMatrix = new DOMMatrix();\r\n    var stack = this._stack.reference();\r\n    result.m11 = stack.a;\r\n    result.m12 = stack.b;\r\n    result.m21 = stack.c;\r\n    result.m22 = stack.d;\r\n    result.m41 = stack.e;\r\n    result.m42 = stack.f;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * An function that sets the current transform on the `_transformStack` to the specified\r\n   * DOMMatrix values.\r\n   *\r\n   * @param {f64} a - The a property of the transform matrix.\r\n   * @param {f64} b - The b property of the transform matrix.\r\n   * @param {f64} c - The c property of the transform matrix.\r\n   * @param {f64} d - The d property of the transform matrix.\r\n   * @param {f64} e - The e property of the transform matrix.\r\n   * @param {f64} f - The f property of the transform matrix.\r\n   */\r\n  @inline\r\n  private _setTransform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    var stack = this._stack.reference();\r\n    stack.a = a;\r\n    stack.b = b;\r\n    stack.c = c;\r\n    stack.d = d;\r\n    stack.e = e;\r\n    stack.f = f;\r\n  }\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.currentTransform property of the Canvas 2D API returns or sets a\r\n   * DOMMatrix (current specification) object for the current transformation matrix\r\n  */\r\n  public get currentTransform(): DOMMatrix {\r\n    return this._getTransform();\r\n  }\r\n\r\n  public set currentTransform(value: DOMMatrix) {\r\n    this._setTransform(value.m11, value.m12, value.m21, value.m22, value.m41, value.m42);\r\n  }\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.getTransform() method of the Canvas 2D API gets the current\r\n   * transformation matrix, and returns a DOMMatrix\r\n   */\r\n  public getTransform(): DOMMatrix {\r\n    return this._getTransform();\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current transform value on the _transformStack to the\r\n   * buffer if it currently does not match the last written transform.\r\n   */\r\n  private _updateTransform(): void {\r\n    var stack = this._stack.reference();\r\n    var a = stack.a;\r\n    var b = stack.b;\r\n    var c = stack.c;\r\n    var d = stack.d;\r\n    var e = stack.e;\r\n    var f = stack.f;\r\n\r\n    var current = changetype<usize>(this._currentTransform);\r\n    if ( a != LOAD<f64>(current, 0)\r\n      || b != LOAD<f64>(current, 1)\r\n      || c != LOAD<f64>(current, 2)\r\n      || d != LOAD<f64>(current, 3)\r\n      || e != LOAD<f64>(current, 4)\r\n      || f != LOAD<f64>(current, 5)) {\r\n      super._writeSix(CanvasInstruction.SetTransform, a, b, c, d, e, f);\r\n      STORE<f64>(current, 0, a);\r\n      STORE<f64>(current, 1, b);\r\n      STORE<f64>(current, 2, c);\r\n      STORE<f64>(current, 3, d);\r\n      STORE<f64>(current, 4, e);\r\n      STORE<f64>(current, 5, f);\r\n    }\r\n  }\r\n  //#endregion TRANSFORM\r\n\r\n  //#region DIRECTION\r\n\r\n  /**\r\n   * A private member that contains a single CanvasDirection value that represents the last\r\n   * CanvasDirection value written by a drawing operation\r\n   */\r\n  private _currentDirection: CanvasDirection = CanvasDirection.inherit;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.direction property of the Canvas 2D API specifies the current text\r\n   * direction used to draw text\r\n   */\r\n  public get direction(): CanvasDirection {\r\n    return this._stack.reference().direction;\r\n  }\r\n\r\n  public set direction(value: CanvasDirection) {\r\n    this._stack.reference().direction = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current CanvasDirection value on the _directionStack to\r\n   * the buffer if it currently does not match the last written CanvasDirection.\r\n   */\r\n  @inline\r\n  private _updateDirection(): void {\r\n    var value: CanvasDirection = this._stack.reference().direction;\r\n    if (value != this._currentDirection) {\r\n      this._currentDirection = value;\r\n      super._writeOne(CanvasInstruction.Direction, <f64>value);\r\n    }\r\n  }\r\n  //#endregion DIRECTION\r\n\r\n  //#region FILLSTYLE\r\n  /**\r\n   * A private member that contains a single StrokeFillStyleType value that represents the last\r\n   * fillStyle value written by a drawing operation\r\n   */\r\n  private _currentFillStyleType: FillStrokeStyleType = FillStrokeStyleType.String;\r\n\r\n  /**\r\n   * A private member that contains a single pointer or id value that represents the last\r\n   * fillStyle value written by a drawing operation\r\n   */\r\n  private _currentFillStyleValue: usize = changetype<usize>(defaultBlack);\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.fillStyle property of the Canvas 2D API specifies the current text\r\n   * representing a CSS Color\r\n   */\r\n  public get fillStyle(): string | null {\r\n    var stack = this._stack.reference();\r\n    return stack.fillStyleType === FillStrokeStyleType.String\r\n      ? stack.fillStyleString\r\n      : null;\r\n  }\r\n\r\n  public set fillStyle(value: string | null) {\r\n    if (value == null) value = defaultBlack;\r\n    let stack = this._stack.reference();\r\n    let currentType = stack.fillStyleType;\r\n    stack.fillStyleType = FillStrokeStyleType.String;\r\n    __retain(changetype<usize>(value));\r\n    if (currentType == FillStrokeStyleType.CanvasGradient) {\r\n      __release(changetype<usize>(stack.fillStyleGradient));\r\n      stack.fillStyleGradient = null;\r\n    } else if (currentType == FillStrokeStyleType.CanvasPattern) {\r\n      __release(changetype<usize>(stack.fillStylePattern));\r\n      stack.fillStylePattern = null;\r\n    } else {\r\n      __release(changetype<usize>(stack.fillStyleString));\r\n    }\r\n    stack.fillStyleString = value!;\r\n    stack.fillStyleValue = changetype<usize>(value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current fillStyle value on the _fillStyleStack to the\r\n   * buffer if it currently does not match the last written fillStyle.\r\n   */\r\n  @inline\r\n  private _updateFillStyle(): void {\r\n    var stack = this._stack.reference();\r\n    var styleType = stack.fillStyleType;\r\n\r\n    var pointer: usize = 0;\r\n    var value: f64 = 0;\r\n    if (styleType === FillStrokeStyleType.String) {\r\n      pointer = changetype<usize>(stack.fillStyleString);\r\n      value = pointer;\r\n    } else if (styleType === FillStrokeStyleType.CanvasGradient) {\r\n      pointer = changetype<usize>(stack.fillStyleGradient);\r\n      value = <f64>load<i32>(pointer, offsetof<CanvasGradient>(\"id\"));\r\n    } else if (styleType === FillStrokeStyleType.CanvasPattern) {\r\n      pointer = changetype<usize>(stack.fillStylePattern);\r\n      value = <f64>load<i32>(pointer, offsetof<CanvasPattern>(\"id\"));\r\n    }\r\n    super._retain(pointer);\r\n\r\n    if (styleType != this._currentFillStyleType || value != this._currentFillStyleValue) {\r\n      var inst: CanvasInstruction;\r\n      if (styleType == FillStrokeStyleType.String) inst = CanvasInstruction.FillStyle;\r\n      else if (styleType == FillStrokeStyleType.CanvasGradient) inst = CanvasInstruction.FillGradient;\r\n      else inst = CanvasInstruction.FillPattern;\r\n      super._writeOne(inst, <f64>value);\r\n    }\r\n  }\r\n  //#endregion FILLSTYLE\r\n\r\n  //#region FILLPATTERN\r\n  /**\r\n   * The CanvasRenderingContext2D.fillPattern property of the Canvas 2D API specifies the current\r\n   * fillStyle pattern\r\n   */\r\n  public get fillPattern(): CanvasPattern | null {\r\n    var stack = this._stack.reference();\r\n    return stack.fillStyleType === FillStrokeStyleType.CanvasPattern\r\n      ? stack.fillStylePattern\r\n      : null;\r\n  }\r\n\r\n  public set fillPattern(value: CanvasPattern | null) {\r\n    if (value == null) {\r\n      this.fillStyle = defaultBlack;\r\n      return;\r\n    }\r\n    __retain(changetype<usize>(value));\r\n    var stack = this._stack.reference();\r\n    __release(changetype<usize>(stack.fillStylePattern));\r\n    stack.fillStyleType = FillStrokeStyleType.CanvasPattern;\r\n    stack.fillStylePattern = value;\r\n    stack.fillStyleValue = <usize>load<i32>(changetype<usize>(value), offsetof<CanvasPattern>(\"id\"));\r\n  }\r\n  //#endregion FILLPATTERN\r\n\r\n  //#region FILLGRADIENT\r\n  /**\r\n   * The CanvasRenderingContext2D.fillGradient property of the Canvas 2D API specifies the current\r\n   * fillStyle gradient\r\n   */\r\n  public get fillGradient(): CanvasGradient | null {\r\n    var stack = this._stack.reference();\r\n    return stack.fillStyleType == FillStrokeStyleType.CanvasGradient\r\n      ? stack.fillStyleGradient\r\n      : null;\r\n  }\r\n\r\n  public set fillGradient(value: CanvasGradient | null) {\r\n    if (value == null) {\r\n      this.fillStyle = defaultBlack;\r\n      return;\r\n    }\r\n    __retain(changetype<usize>(value));\r\n    var stack = this._stack.reference();\r\n    stack.fillStyleType = FillStrokeStyleType.CanvasGradient;\r\n    __release(changetype<usize>(stack.fillStyleGradient));\r\n    stack.fillStyleGradient = value;\r\n    stack.fillStyleValue = <usize>load<i32>(changetype<usize>(value), offsetof<CanvasGradient>(\"id\"));\r\n  }\r\n  //#endregion FILLGRADIENT\r\n\r\n  //#region CREATEPATTERN\r\n  /**\r\n   * The CanvasRenderingContext2D.createPattern() method of the Canvas 2D API creates a pattern\r\n   * using the specified image and repetition.\r\n   *\r\n   * @param {Image} img - A CanvasImageSource to be used as the pattern's Image.\r\n   * @param {CanvasPatternRepetition} repetition - An enum value indicating how to repeat the pattern's image.\r\n   */\r\n  public createPattern(img: Image, repetition: CanvasPatternRepetition): CanvasPattern {\r\n    var result = new CanvasPattern();\r\n    var id: i32 = load<i32>(changetype<usize>(img), offsetof<Image>(\"_id\"));\r\n    store<i32>(changetype<usize>(result), createPattern(this.id, id, repetition), offsetof<CanvasPattern>(\"id\"));\r\n    return result;\r\n  }\r\n  //#endregion CREATEPATTERN\r\n\r\n  //#region FILTER\r\n  /**\r\n   * A private member that contains a single string value that represents the last\r\n   * filter value written by a drawing operation.\r\n   */\r\n  private _currentFilter: string = defaultNone;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.filter property of the Canvas 2D API provides filter effects such\r\n   * as blurring and grayscaling. It is similar to the CSS filter property and accepts the same\r\n   * values.\r\n   */\r\n  public get filter(): string {\r\n    return this._stack.reference().filter;\r\n  }\r\n\r\n  public set filter(value: string) {\r\n    let stack = this._stack.reference();\r\n    __retain(changetype<usize>(value));\r\n    __release(changetype<usize>(stack.filter));\r\n    stack.filter = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current filter value on the _filterStack if it currently\r\n   * does not match the last written filter string value to the buffer using write_one.\r\n   */\r\n  @inline\r\n  private _updateFilter(): void {\r\n    var value: string = this._stack.reference().filter;\r\n    if (value != this._currentFilter) {\r\n      this._currentFilter = value;\r\n      super._writeOne(CanvasInstruction.Filter, changetype<usize>(value));\r\n    }\r\n  }\r\n  //#endregion FILTER\r\n\r\n  //#region FONT\r\n  /**\r\n   * A private member that contains a single string value that represents the last\r\n   * font value written by a drawing operation.\r\n   */\r\n  private _currentFont: string = defaultFont;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.font property of the Canvas 2D API specifies the current text\r\n   * style to use when drawing text. This string uses the same syntax as the CSS font specifier.\r\n   */\r\n  public get font(): string {\r\n    return this._stack.reference().font;\r\n  }\r\n\r\n  public set font(value: string) {\r\n    let stack = this._stack.reference();\r\n    __retain(changetype<usize>(value));\r\n    __release(changetype<usize>(stack.font));\r\n    stack.font = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current font value on the _fontStack to the buffer if it\r\n   * currently does not match the last written font string value.\r\n   */\r\n  @inline\r\n  private _updateFont(): void {\r\n    var value: string = this._stack.reference().font;\r\n    if (value != this._currentFont) {\r\n      this._currentFont = value;\r\n      super._retain(changetype<usize>(value));\r\n      super._writeOne(CanvasInstruction.Font, changetype<usize>(value));\r\n    }\r\n  }\r\n  //#endregion FONT\r\n\r\n  //#region GLOBALALPHA\r\n  /**\r\n   * A private member that contains a single float value that represents the last globalAlpha value\r\n   * written by a drawing operation.\r\n   */\r\n  private _currentGlobalAlpha: f64 = 1.0;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.globalAlpha property of the Canvas 2D API specifies the alpha\r\n   * (transparency) value that is applied to shapes and images before they are drawn onto the\r\n   * canvas.\r\n   */\r\n  public get globalAlpha(): f64 {\r\n    return this._stack.reference().globalAlpha;\r\n  }\r\n\r\n  public set globalAlpha(value: f64) {\r\n    if (!isFinite(value) || value < 0.0 || value > 1.0) return;\r\n    this._stack.reference().globalAlpha = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current globalAlpha value on the _globalAlphaStack to the\r\n   * buffer if it currently does not match the last written globalAlpha value.\r\n   */\r\n  @inline\r\n  private _updateGlobalAlpha(): void {\r\n    var value: f64 = this._stack.reference().globalAlpha;\r\n    if (value != this._currentGlobalAlpha) {\r\n      this._currentGlobalAlpha = value;\r\n      super._writeOne(CanvasInstruction.GlobalAlpha, value);\r\n    }\r\n  }\r\n  //#endregion GLOBALALPHA\r\n\r\n  //#region GLOBALCOMPOSITEOPERATION\r\n  /**\r\n   * A private member that contains a single GlobalCompositeOperation value that represents the last\r\n   * globalCompositeOperation value written by a drawing operation.\r\n   */\r\n  private _currentGlobalCompositeOperation: GlobalCompositeOperation = GlobalCompositeOperation.source_over;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.globalCompositeOperation property of the Canvas 2D API sets the\r\n   * type of compositing operation to apply when drawing new shapes.\r\n   */\r\n  public get globalCompositeOperation(): GlobalCompositeOperation {\r\n    return this._stack.reference().globalCompositeOperation;\r\n  }\r\n\r\n  public set globalCompositeOperation(value: GlobalCompositeOperation) {\r\n    this._stack.reference().globalCompositeOperation = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current globalCompositeOperation value on the\r\n   * _globalCompositeOperationStack to the buffer if it currently does not match the last written\r\n   * globalCompositeOperation value.\r\n   */\r\n  @inline\r\n  private _updateGlobalCompositeOperation(): void {\r\n    var value: GlobalCompositeOperation = this._stack.reference().globalCompositeOperation;\r\n    if (value != this._currentGlobalCompositeOperation) {\r\n      this._currentGlobalCompositeOperation = value;\r\n      super._writeOne(CanvasInstruction.GlobalCompositeOperation, <f64>value);\r\n    }\r\n  }\r\n  //#endregion GLOBALCOMPOSITEOPERATION\r\n\r\n  //#region IMAGESMOOTHINGENABLED\r\n\r\n  /**\r\n   * A private member that contains a single bool value that represents the last\r\n   * imageSmoothingEnabled value written by a drawing operation.\r\n   */\r\n  private _currentImageSmoothingEnabled: bool = true;\r\n\r\n  /**\r\n   * The imageSmoothingEnabled property of the CanvasRenderingContext2D interface, part of the\r\n   * Canvas API, determines whether scaled images are smoothed (true, default) or not (false). On\r\n   * getting the imageSmoothingEnabled property, the last value it was set to is returned.\r\n   */\r\n  public get imageSmoothingEnabled(): bool {\r\n    return this._stack.reference().imageSmoothingEnabled;\r\n  }\r\n\r\n  public set imageSmoothingEnabled(value: bool) {\r\n    this._stack.reference().imageSmoothingEnabled = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current imageSmoothingEnabled value on the\r\n   * _imageSmoothingEnabledStack to the buffer if it currently does not match the last written\r\n   * imageSmoothingEnabled value.\r\n   */\r\n  @inline\r\n  private _updateImageSmoothingEnabled(): void {\r\n    var value: bool = this._stack.reference().imageSmoothingEnabled;\r\n    if (value != this._currentImageSmoothingEnabled) {\r\n      this._currentImageSmoothingEnabled = value;\r\n      super._writeOne(CanvasInstruction.ImageSmoothingEnabled, value ? 1.0 : 0.0);\r\n    }\r\n  }\r\n  //#endregion IMAGESMOOTHINGENABLED\r\n\r\n  //#region IMAGESMOOTHINGQUALITY\r\n  /**\r\n   * A private member that contains a single ImageSmoothingQuality value that represents the last\r\n   * imageSmoothingQuality value written by a drawing operation.\r\n   */\r\n  private _currentImageSmoothingQuality: ImageSmoothingQuality = ImageSmoothingQuality.low;\r\n\r\n  /**\r\n   * The imageSmoothingQuality property of the CanvasRenderingContext2D interface, part of the\r\n   * Canvas API, lets you set the quality of image smoothing.\r\n   */\r\n  public get imageSmoothingQuality(): ImageSmoothingQuality {\r\n    return this._stack.reference().imageSmoothingQuality;\r\n  }\r\n\r\n  public set imageSmoothingQuality(value: ImageSmoothingQuality) {\r\n    this._stack.reference().imageSmoothingQuality = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current imageSmoothingQuality value on the\r\n   * _imageSmoothingQualityStack to the buffer if it currently does not match the last written\r\n   * imageSmoothingQuality value, and imageSmoothingEnabled is true.\r\n   */\r\n  @inline\r\n  private _updateImageSmoothingQuality(): void {\r\n    let stack = this._stack.reference();\r\n    let enabled = stack.imageSmoothingEnabled;\r\n    if (enabled) {\r\n      let value = stack.imageSmoothingQuality;\r\n      if (value != this._currentImageSmoothingQuality) {\r\n        this._currentImageSmoothingQuality = value;\r\n        super._writeOne(CanvasInstruction.ImageSmoothingQuality, <f64>value);\r\n      }\r\n    }\r\n  }\r\n  //#endregion IMAGESMOOTHINGQUALITY\r\n\r\n  //#region LINECAP\r\n  /**\r\n   * A private member that contains a single LineCap value that represents the last\r\n   * lineCap value written by a drawing operation.\r\n   */\r\n  private _currentLineCap: LineCap = LineCap.butt;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.lineCap property of the Canvas 2D API determines the shape used\r\n   * to draw the end points of lines.\r\n   */\r\n  public get lineCap(): LineCap {\r\n    return this._stack.reference().lineCap;\r\n  }\r\n\r\n  public set lineCap(value: LineCap) {\r\n    this._stack.reference().lineCap = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current lineCap value on the _lineCapStack to the buffer\r\n   * if it currently does not match the last written lineCap value.\r\n   */\r\n  @inline\r\n  private _updateLineCap(): void {\r\n    var value: LineCap = this._stack.reference().lineCap;\r\n    if (value != this._currentLineCap) {\r\n      this._currentLineCap = value;\r\n      super._writeOne(CanvasInstruction.LineCap, <f64>value);\r\n    }\r\n  }\r\n  //#endregion LINECAP\r\n\r\n  //#region LINEDASH\r\n  /**\r\n   * A private member that contains a single LineCap value that represents the last\r\n   * lineCap value written by a drawing operation.\r\n   */\r\n  private _currentLineDash: Float64Array = defaultLineDash;\r\n\r\n  /**\r\n   * The getLineDash() method of the Canvas 2D API's CanvasRenderingContext2D interface gets the\r\n   * current line dash pattern.\r\n   */\r\n  public getLineDash(): Float64Array {\r\n    return this._getLineDash();\r\n  }\r\n\r\n  /**\r\n   * The setLineDash() method of the Canvas 2D API's CanvasRenderingContext2D interface sets the\r\n   * line dash pattern used when stroking lines. It uses a Float64Array of values that specify\r\n   * alternating lengths of lines and gaps which describe the pattern.\r\n   *\r\n   * @param {Float64Array} value - An Array of numbers that specify distances to alternately draw a\r\n   * line and a gap (in coordinate space units). If the number of elements in the array is odd, the\r\n   * elements of the array get copied and concatenated. For example, Float64Array [5, 15, 25] will\r\n   * become Float64Array [5, 15, 25, 5, 15, 25]. If the array is empty, the line dash list is\r\n   * cleared and line strokes return to being solid.\r\n   */\r\n  public setLineDash(value: Float64Array): void {\r\n    let stack = this._stack.reference();\r\n    __release(changetype<usize>(stack.lineDash));\r\n    __retain(changetype<usize>(value));\r\n    stack.lineDash = value;\r\n  }\r\n\r\n  /**\r\n   * An internal getLineDash function that loops backwards from the current stackOffset until it\r\n   * doesn't find a null pointer, then returns the reference.\r\n   */\r\n  @inline\r\n  private _getLineDash(): Float64Array {\r\n    return this._stack.reference().lineDash;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current lineDash value on the _lineDashStack to the buffer\r\n   * if it currently does not match the last written lineCap value.\r\n   */\r\n  @inline\r\n  private _updateLineDash(): void {\r\n    var lineDash: Float64Array = this._getLineDash();\r\n    var current: Float64Array = this._currentLineDash;\r\n\r\n    if (!arraysEqual(current, lineDash)) {\r\n      this._currentLineDash = lineDash;\r\n      let pointer = changetype<usize>(lineDash);\r\n      super._retain(pointer);\r\n      super._writeOne(CanvasInstruction.LineDash, <f64>pointer);\r\n    }\r\n  }\r\n  //#endregion LINEDASH\r\n\r\n  //#region LINEDASHOFFSET\r\n  /**\r\n   * A private member that contains a single float value that represents the last lineDashOffset value\r\n   * written by a drawing operation.\r\n   */\r\n  private _currentLineDashOffset: f64 = 0.0;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.lineDashOffset property of the Canvas 2D API sets the line dash\r\n   * offset, or \"phase.\"\r\n   */\r\n  public get lineDashOffset(): f64 {\r\n    return this._stack.reference().lineDashOffset;\r\n  }\r\n\r\n  public set lineDashOffset(value: f64) {\r\n    if (!isFinite(value)) return;\r\n    this._stack.reference().lineDashOffset = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current lineDashOffset value on the _lineDashOffsetStack\r\n   * to the buffer if it currently does not match the last written lineDashOffset value.\r\n   */\r\n  @inline\r\n  private _updateLineDashOffset(): void {\r\n    var value: f64 = this._stack.reference().lineDashOffset;\r\n    if (value != this._currentLineDashOffset) {\r\n      this._currentLineDashOffset = value;\r\n      super._writeOne(CanvasInstruction.LineDashOffset, value);\r\n    }\r\n  }\r\n  //#endregion LINEDASHOFFSET\r\n\r\n  //#region LINEJOIN\r\n  /**\r\n   * A private member that contains a single LineJoin value that represents the last\r\n   * lineJoin value written by a drawing operation.\r\n   */\r\n  private _currentLineJoin: LineJoin = LineJoin.miter;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.lineJoin property of the Canvas 2D API determines the shape used\r\n   * to join two line segments where they meet.\r\n   *\r\n   * This property has no effect wherever two connected segments have the same direction, because\r\n   * no joining area will be added in this case. Degenerate segments with a length of zero (i.e.,\r\n   * with all endpoints and control points at the exact same position) are also ignored.\r\n   */\r\n  public get lineJoin(): LineJoin {\r\n    return this._stack.reference().lineJoin;\r\n  }\r\n\r\n  public set lineJoin(value: LineJoin) {\r\n    this._stack.reference().lineJoin = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current lineJoin value on the  _lineJoinStack if it\r\n   * currently does not match the last written lineJoin value.\r\n   */\r\n  @inline\r\n  private _updateLineJoin(): void {\r\n    var value: LineJoin = this._stack.reference().lineJoin;\r\n    if (value != this._currentLineJoin) {\r\n      this._currentLineJoin = value;\r\n      super._writeOne(CanvasInstruction.LineJoin, <f64>value);\r\n    }\r\n  }\r\n  //#endregion\r\n\r\n  //#region LINEWIDTH\r\n  /**\r\n   * A private member that contains a single float value that represents the last lineWidth value\r\n   * written by a drawing operation.\r\n   */\r\n  private _currentLineWidth: f64 = 1.0;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.lineWidth property of the Canvas 2D API sets the line dash\r\n   * offset, or \"phase.\"\r\n   */\r\n  public get lineWidth(): f64 {\r\n    return this._stack.reference().lineWidth;\r\n  }\r\n\r\n  public set lineWidth(value: f64) {\r\n    if (!isFinite(value) || value < 0) return;\r\n    this._stack.reference().lineWidth = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current lineWidth value on the _lineWidthStack to the\r\n   * buffer if it currently does not match the last written lineWidth value.\r\n   */\r\n  @inline\r\n  private _updateLineWidth(): void {\r\n    var value: f64 = this._stack.reference().lineWidth;\r\n    if (value != this._currentLineWidth) {\r\n      this._currentLineWidth = value;\r\n      super._writeOne(CanvasInstruction.LineWidth, value);\r\n    }\r\n  }\r\n  //#endregion\r\n\r\n  //#region MITERLIMIT\r\n  /**\r\n   * A private member that contains a single float value that represents the last miterLimit value\r\n   * written by a drawing operation.\r\n   */\r\n  private _currentMiterLimit: f64 = 10.0;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.miterLimit property of the Canvas 2D API sets the miter limit\r\n   * ratio. It establishes a limit on the miter when two lines join at a sharp angle, to let you\r\n   * control how thick the junction becomes.\r\n   */\r\n  public get miterLimit(): f64 {\r\n    return this._stack.reference().miterLimit;\r\n  }\r\n\r\n  public set miterLimit(value: f64) {\r\n    if (!isFinite(value) || value < 0) return;\r\n    this._stack.reference().miterLimit = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current miterLimit value on the _miterLimitStack to the\r\n   * buffer if it currently does not match the last written miterLimit value.\r\n   */\r\n  @inline\r\n  private _updateMiterLimit(): void {\r\n    var value: f64 = this._stack.reference().miterLimit;\r\n    if (value != this._currentMiterLimit) {\r\n      this._currentMiterLimit = value;\r\n      super._writeOne(CanvasInstruction.MiterLimit, value);\r\n    }\r\n  }\r\n  //#endregion MITERLIMIT\r\n\r\n  //#region SHADOWBLUR\r\n  /**\r\n   * A private member that contains a single float value that represents the last shadowBlur value\r\n   * written by a drawing operation.\r\n   */\r\n  private _currentShadowBlur: f64 = 0.0;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.shadowBlur property of the Canvas 2D API specifies the amount of\r\n   * blur applied to shadows. The default is 0 (no blur).\r\n   *\r\n   * The shadowBlur value is a non-negative float specifying the level of shadow blur, where 0\r\n   * represents no blur and larger numbers represent increasingly more blur. This value doesn't\r\n   * correspond to a number of pixels, and is not affected by the current transformation matrix. The\r\n   * default value is 0. Negative, Infinity, and NaN values are ignored.\r\n   */\r\n  public get shadowBlur(): f64 {\r\n    return this._stack.reference().shadowBlur;\r\n  }\r\n\r\n  public set shadowBlur(value: f64) {\r\n    if (!isFinite(value) || value < 0) return;\r\n    this._stack.reference().shadowBlur = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current shadowBlur value on the _shadowBlurStack to the\r\n   * buffer if it currently does not match the last written shadowBlur value.\r\n   */\r\n  @inline\r\n  private _updateShadowBlur(): void {\r\n    var value: f64 = this._stack.reference().shadowBlur;\r\n    if (value != this._currentShadowBlur) {\r\n      this._currentShadowBlur = value;\r\n      super._writeOne(CanvasInstruction.ShadowBlur, value);\r\n    }\r\n  }\r\n  //#endregion SHADOWBLUR\r\n\r\n  //#region SHADOWCOLOR\r\n  /**\r\n   * A private member that contains a single StrokeShadowColorType value that represents the last\r\n   * shadowColor value written by a drawing operation\r\n   */\r\n  private _currentShadowColor: string = defaultShadowColor;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.shadowColor property of the Canvas 2D API specifies the current text\r\n   * representing a CSS Color\r\n   */\r\n  public get shadowColor(): string {\r\n    return this._stack.reference().shadowColor;\r\n  }\r\n\r\n  public set shadowColor(value: string) {\r\n    if (value == null) value = defaultShadowColor;\r\n    var stack = this._stack.reference();\r\n    __retain(changetype<usize>(value));\r\n    __release(changetype<usize>(stack.shadowColor));\r\n    stack.shadowColor = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current shadowColor value on the _shadowColorStack to the\r\n   * buffer if it currently does not match the last written shadowColor.\r\n   */\r\n  @inline\r\n  private _updateShadowColor(): void {\r\n    var value: string = this._stack.reference().shadowColor;\r\n    if (value != this._currentShadowColor) {\r\n      this._currentFilter = value;\r\n      super._retain(changetype<usize>(value));\r\n      super._writeOne(CanvasInstruction.ShadowColor, changetype<usize>(value));\r\n    }\r\n  }\r\n  //#endregion\r\n\r\n  //#region SHADOWOFFSETX\r\n  /**\r\n   * A private member that contains a single float value that represents the last shadowOffsetX value\r\n   * written by a drawing operation.\r\n   */\r\n  private _currentShadowOffsetX: f64 = 0.0;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.shadowOffsetX property of the Canvas 2D API specifies the distance\r\n   * that shadows will be offset horizontally.\r\n   *\r\n   * The value is a f64 specifying the distance that shadows will be offset horizontally. Positive\r\n   * values are to the right, and negative to the left. The default value is 0 (no horizontal\r\n   * offset). Infinity and NaN values are ignored.\r\n   */\r\n  public get shadowOffsetX(): f64 {\r\n    return this._stack.reference().shadowOffsetX;\r\n  }\r\n\r\n  public set shadowOffsetX(value: f64) {\r\n    if (!isFinite(value)) return;\r\n    this._stack.reference().shadowOffsetX = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current shadowOffsetX value on the _shadowOffsetXStack to the\r\n   * buffer if it currently does not match the last written shadowOffsetX value.\r\n   */\r\n  @inline\r\n  private _updateShadowOffsetX(): void {\r\n    var value: f64 = this._stack.reference().shadowOffsetX;\r\n    if (value != this._currentShadowOffsetX) {\r\n      this._currentShadowOffsetX = value;\r\n      super._writeOne(CanvasInstruction.ShadowOffsetX, value);\r\n    }\r\n  }\r\n  //#endregion SHADOWOFFSETX\r\n\r\n  //#region SHADOWOFFSETY\r\n  /**\r\n   * A private member that contains a single float value that represents the last shadowOffsetY value\r\n   * written by a drawing operation.\r\n   */\r\n  private _currentShadowOffsetY: f64 = 0.0;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.shadowOffsetY property of the Canvas 2D API specifies the distance\r\n   * that shadows will be offset vertically.\r\n   *\r\n   * The value is a f64 specifying the distance that shadows will be offset horizontally. Positive\r\n   * values are down, and negative are up. The default value is 0 (no vertical offset). Infinity and\r\n   * NaN values are ignored\r\n   */\r\n  public get shadowOffsetY(): f64 {\r\n    return this._stack.reference().shadowOffsetY;\r\n  }\r\n\r\n  public set shadowOffsetY(value: f64) {\r\n    if (!isFinite(value)) return;\r\n    this._stack.reference().shadowOffsetY = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current shadowOffsetY value on the _shadowOffsetYStack to the\r\n   * buffer if it currently does not match the last written shadowOffsetY value.\r\n   */\r\n  @inline\r\n  private _updateShadowOffsetY(): void {\r\n    var value: f64 = this._stack.reference().shadowOffsetY;\r\n    if (value != this._currentShadowOffsetY) {\r\n      this._currentShadowOffsetY = value;\r\n      super._writeOne(CanvasInstruction.ShadowOffsetY, value);\r\n    }\r\n  }\r\n  //#endregion SHADOWOFFSETY\r\n\r\n\r\n  //#region STROKESTYLE\r\n  /**\r\n   * A private member that contains a single StrokeFillStyleType value that represents the last\r\n   * strokeStyle value written by a drawing operation\r\n   */\r\n  private _currentStrokeStyleType: FillStrokeStyleType = FillStrokeStyleType.String;\r\n\r\n  /**\r\n   * A private member that contains a single pointer or id value that represents the last\r\n   * fillStyle value written by a drawing operation\r\n   */\r\n  private _currentStrokeStyleValue: usize = changetype<usize>(defaultBlack);\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.strokeStyle property of the Canvas 2D API specifies the current text\r\n   * representing a CSS Color\r\n   */\r\n  public get strokeStyle(): string | null {\r\n    var stack = this._stack.reference();\r\n    return stack.strokeStyleType === FillStrokeStyleType.String\r\n      ? stack.strokeStyleString\r\n      : null;\r\n  }\r\n\r\n  public set strokeStyle(value: string | null) {\r\n    if (value == null) value = defaultBlack;\r\n    let stack = this._stack.reference();\r\n    let currentType = stack.strokeStyleType;\r\n    stack.strokeStyleType = FillStrokeStyleType.String;\r\n    __retain(changetype<usize>(value));\r\n    if (currentType == FillStrokeStyleType.CanvasGradient) {\r\n      __release(changetype<usize>(stack.strokeStyleGradient));\r\n      stack.strokeStyleGradient = null;\r\n    } else if (currentType == FillStrokeStyleType.CanvasPattern) {\r\n      __release(changetype<usize>(stack.strokeStylePattern));\r\n      stack.strokeStylePattern = null;\r\n    } else {\r\n      __release(changetype<usize>(stack.strokeStyleString));\r\n    }\r\n    stack.strokeStyleString = value!;\r\n    stack.strokeStyleValue = changetype<usize>(value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current strokeStyle value on the _strokeStyleStack to the\r\n   * buffer if it currently does not match the last written strokeStyle.\r\n   */\r\n  @inline\r\n  private _updateStrokeStyle(): void {\r\n    var stack = this._stack.reference();\r\n    var styleType = stack.strokeStyleType;\r\n\r\n    var pointer: usize = 0;\r\n    var value: f64 = 0;\r\n    if (styleType === FillStrokeStyleType.String) {\r\n      pointer = changetype<usize>(stack.strokeStyleString);\r\n      value = pointer;\r\n    } else if (styleType === FillStrokeStyleType.CanvasGradient) {\r\n      pointer = changetype<usize>(stack.strokeStyleGradient);\r\n      value = <f64>load<i32>(pointer, offsetof<CanvasGradient>(\"id\"));\r\n    } else if (styleType === FillStrokeStyleType.CanvasPattern) {\r\n      pointer = changetype<usize>(stack.strokeStylePattern);\r\n      value = <f64>load<i32>(pointer, offsetof<CanvasPattern>(\"id\"));\r\n    }\r\n    super._retain(pointer);\r\n\r\n    if (styleType != this._currentStrokeStyleType || value != this._currentStrokeStyleValue) {\r\n      var inst: CanvasInstruction;\r\n      if (styleType == FillStrokeStyleType.String) inst = CanvasInstruction.StrokeStyle;\r\n      else if (styleType == FillStrokeStyleType.CanvasGradient) inst = CanvasInstruction.StrokeGradient;\r\n      else inst = CanvasInstruction.StrokePattern;\r\n      super._writeOne(inst, <f64>value);\r\n    }\r\n  }\r\n  //#endregion STROKESTYLE\r\n\r\n  //#region STROKEPATTERN\r\n  /**\r\n   * The CanvasRenderingContext2D.strokePattern property of the Canvas 2D API specifies the current\r\n   * strokeStyle pattern\r\n   */\r\n  public get strokePattern(): CanvasPattern | null {\r\n    var stack = this._stack.reference();\r\n    return stack.strokeStyleType === FillStrokeStyleType.CanvasPattern\r\n      ? stack.strokeStylePattern\r\n      : null;\r\n  }\r\n\r\n  public set strokePattern(value: CanvasPattern | null) {\r\n    if (value == null) {\r\n      this.strokeStyle = defaultBlack;\r\n      return;\r\n    }\r\n    __retain(changetype<usize>(value));\r\n    var stack = this._stack.reference();\r\n    __release(changetype<usize>(stack.strokeStylePattern));\r\n    stack.strokeStyleType = FillStrokeStyleType.CanvasPattern;\r\n    stack.strokeStylePattern = value;\r\n    stack.strokeStyleValue = <usize>load<i32>(changetype<usize>(value), offsetof<CanvasPattern>(\"id\"));\r\n  }\r\n  //#endregion STROKEPATTERN\r\n\r\n  //#region STROKEGRADIENT\r\n  /**\r\n   * The CanvasRenderingContext2D.strokeGradient property of the Canvas 2D API specifies the current\r\n   * strokeStyle gradient.\r\n   */\r\n  public get strokeGradient(): CanvasGradient | null {\r\n    var stack = this._stack.reference();\r\n    return stack.strokeStyleType == FillStrokeStyleType.CanvasGradient\r\n      ? stack.strokeStyleGradient\r\n      : null;\r\n  }\r\n\r\n  public set strokeGradient(value: CanvasGradient | null) {\r\n    if (value == null) {\r\n      this.strokeStyle = defaultBlack;\r\n      return;\r\n    }\r\n    __retain(changetype<usize>(value));\r\n    var stack = this._stack.reference();\r\n    stack.strokeStyleType = FillStrokeStyleType.CanvasGradient;\r\n    __release(changetype<usize>(stack.strokeStyleGradient));\r\n    stack.strokeStyleGradient = value;\r\n    stack.strokeStyleValue = <usize>load<i32>(changetype<usize>(value), offsetof<CanvasGradient>(\"id\"));\r\n  }\r\n  //#endregion STROKEGRADIENT\r\n\r\n  //#region TEXTALIGN\r\n  /**\r\n   * A private member that contains a single LineCap value that represents the last\r\n   * lineCap value written by a drawing operation.\r\n   */\r\n  private _currentTextAlign: TextAlign = TextAlign.start;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.textAlign property of the Canvas 2D API specifies the current text\r\n   * alignment used when drawing text.\r\n   *\r\n   * The alignment is relative to the x value of the fillText() method. For example, if textAlign is\r\n   * \"center\", then the text's left edge will be at x - (textWidth / 2).\r\n   */\r\n  public get textAlign(): TextAlign {\r\n    return this._stack.reference().textAlign;\r\n  }\r\n\r\n  public set textAlign(value: TextAlign) {\r\n    this._stack.reference().textAlign = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current textAlign value on the _textAlignStack to the\r\n   * buffer if it currently does not match the last written textAlign value.\r\n   */\r\n  @inline\r\n  private _updateTextAlign(): void {\r\n    var value: TextAlign = this._stack.reference().textAlign;\r\n    if (value != this._currentTextAlign) {\r\n      this._currentTextAlign = value;\r\n      super._writeOne(CanvasInstruction.TextAlign, <f64>value);\r\n    }\r\n  }\r\n  //#endregion TEXTALIGN\r\n\r\n  //#region TEXTBASELINE\r\n  /**\r\n   * A private member that contains a single TextBaseline value that represents the last\r\n   * TextBaseline value written by a drawing operation.\r\n   */\r\n  private _currentTextBaseline: TextBaseline = TextBaseline.alphabetic;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.textBaseline property of the Canvas 2D API specifies the current\r\n   * text baseline used when drawing text.\r\n   */\r\n  public get textBaseline(): TextBaseline {\r\n    return this._stack.reference().textBaseline;\r\n  }\r\n\r\n  public set textBaseline(value: TextBaseline) {\r\n    this._stack.reference().textBaseline = value;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current textBaseline value on the _textBaselineStack to the\r\n   * buffer if it currently does not match the last written textBaseline value.\r\n   */\r\n  @inline\r\n  private _updateTextBaseline(): void {\r\n    var value: TextBaseline = this._stack.reference().textBaseline;\r\n    if (value != this._currentTextBaseline) {\r\n      this._currentTextBaseline = value;\r\n      super._writeOne(CanvasInstruction.TextBaseline, <f64>value);\r\n    }\r\n  }\r\n  //#endregion TEXTBASELINE\r\n\r\n  //#region SAVE\r\n  /**\r\n   * The CanvasRenderingContext2D.save() method of the Canvas 2D API saves the entire state of the\r\n   * canvas by pushing the current state onto a stack.\r\n   *\r\n   * The drawing state that gets saved onto a stack consists of:\r\n   *\r\n   * - The current transformation matrix.\r\n   * - The current clipping region.\r\n   * - The current dash list.\r\n   * - The current values of the following attributes: strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled.\r\n   *\r\n   * @param {bool} hard - Tells the context to perform an actual `save()` operation. Default value is false.\r\n   */\r\n  public save(hard: bool = false): void {\r\n    var offset: i32 = <i32>this._stackOffset;\r\n    var nextOffset: i32 = offset + 1;\r\n    if (nextOffset >= <i32>u8.MAX_VALUE) unreachable();\r\n    let stack = this._stack.push();\r\n    this._stack = stack;\r\n    let stackReference = stack.reference();\r\n    // hard saves\r\n    stackReference.save = hard;\r\n\r\n    // fillStyle\r\n    __retain(changetype<usize>(stackReference.fillStyleGradient));\r\n    __retain(changetype<usize>(stackReference.fillStylePattern));\r\n    __retain(changetype<usize>(stackReference.fillStyleString));\r\n\r\n    // filter\r\n    __retain(changetype<usize>(stackReference.filter));\r\n\r\n    // font\r\n    __retain(changetype<usize>(stackReference.font));\r\n\r\n    // lineDash\r\n    __retain(changetype<usize>(stackReference.lineDash));\r\n\r\n    // shadowColor\r\n    __retain(changetype<usize>(stackReference.shadowColor));\r\n\r\n    // strokeStyle\r\n    __retain(changetype<usize>(stackReference.strokeStyleGradient));\r\n    __retain(changetype<usize>(stackReference.strokeStylePattern));\r\n    __retain(changetype<usize>(stackReference.strokeStyleString));\r\n\r\n    if (hard) super._writeZero(CanvasInstruction.Save);\r\n\r\n    this._stackOffset = <u8>nextOffset;\r\n  }\r\n  //#endregion SAVE\r\n\r\n  //#region RESTORE\r\n  /**\r\n   * The CanvasRenderingContext2D.restore() method of the Canvas 2D API restores the most recently\r\n   * saved canvas state by popping the top entry in the drawing state stack. If there is no saved\r\n   * state, this method does nothing.\r\n   *\r\n   * In the case of the hard restore, this function will mirror what the browser does, and modifies\r\n   * the last written values instead of just moving the stack pointer. This ensures that the writer\r\n   * emulates the browser state machine as accurately as possible.\r\n   */\r\n  public restore(): void {\r\n    if (this._stackOffset == <u8>0) return;\r\n    let currentStack = this._stack;\r\n    let nextStack = currentStack.pop();\r\n    this._stack = nextStack;\r\n    let currentStackReference = currentStack.reference();\r\n    let nextStackReference = nextStack.reference();\r\n    // fillStyle\r\n    __release(changetype<usize>(currentStackReference.fillStyleGradient));\r\n    __release(changetype<usize>(currentStackReference.fillStylePattern));\r\n    __release(changetype<usize>(currentStackReference.fillStyleString));\r\n\r\n    // filter\r\n    __release(changetype<usize>(currentStackReference.filter));\r\n\r\n    // font\r\n    __release(changetype<usize>(currentStackReference.font));\r\n\r\n    // lineDash\r\n    __release(changetype<usize>(currentStackReference.lineDash));\r\n\r\n    // shadowColor\r\n    __release(changetype<usize>(currentStackReference.shadowColor));\r\n\r\n    // strokeStyle\r\n    __release(changetype<usize>(currentStackReference.strokeStyleGradient));\r\n    __release(changetype<usize>(currentStackReference.strokeStylePattern));\r\n    __release(changetype<usize>(currentStackReference.strokeStyleString));\r\n\r\n\r\n    if (currentStackReference.save) {\r\n      super._writeZero(CanvasInstruction.Restore);\r\n\r\n      // currentTransform\r\n      memory.copy(\r\n        changetype<usize>(this._currentTransform),\r\n        changetype<usize>(nextStackReference) + offsetof<CanvasStack>(\"a\"),\r\n        48,\r\n      );\r\n\r\n      this._currentDirection = nextStackReference.direction;\r\n\r\n      this._currentFillStyleType = nextStackReference.fillStyleType;\r\n      this._currentFillStyleValue = <usize>nextStackReference.fillStyleValue;\r\n\r\n      this._currentFilter = nextStackReference.filter;\r\n\r\n      this._currentFont = nextStackReference.font;\r\n\r\n      this._currentGlobalAlpha = nextStackReference.globalAlpha;\r\n      this._currentGlobalCompositeOperation = nextStackReference.globalCompositeOperation;\r\n\r\n      this._currentImageSmoothingEnabled = nextStackReference.imageSmoothingEnabled;\r\n      this._currentImageSmoothingQuality = nextStackReference.imageSmoothingQuality;\r\n\r\n      this._currentLineCap = nextStackReference.lineCap;\r\n      this._currentLineDash = nextStackReference.lineDash;\r\n      this._currentLineJoin = nextStackReference.lineJoin;\r\n      this._currentLineWidth = nextStackReference.lineWidth;\r\n      this._currentMiterLimit = nextStackReference.miterLimit;\r\n\r\n      this._currentShadowBlur = nextStackReference.shadowBlur;\r\n      this._currentShadowColor = nextStackReference.shadowColor;\r\n      this._currentShadowOffsetX = nextStackReference.shadowOffsetX;\r\n      this._currentShadowOffsetY = nextStackReference.shadowOffsetY;\r\n\r\n      this._currentStrokeStyleType = nextStackReference.strokeStyleType;\r\n      this._currentStrokeStyleValue = <usize>nextStackReference.strokeStyleValue;\r\n\r\n      this._currentTextAlign = nextStackReference.textAlign;\r\n      this._currentTextBaseline = nextStackReference.textBaseline;\r\n    }\r\n\r\n    this._stackOffset -= <u8>1;\r\n  }\r\n  //#endregion RESTORE\r\n\r\n  //#region PATH\r\n  /**\r\n   * A c like pointer that always points to the next path element to write to.\r\n   */\r\n  private _path: StackPointer<Path2DElement> = createPathElements().increment();\r\n\r\n  /**\r\n   * A reference to the path start for quick path resetting.\r\n   */\r\n  private _pathStart: StackPointer<Path2DElement> = this._path.decrement();\r\n\r\n  /**\r\n   * A pointer that points to the end of the path.\r\n   */\r\n  private _pathEnd: StackPointer<Path2DElement> =\r\n    changetype<StackPointer<Path2DElement>>(changetype<usize>(this._pathStart) + offsetof<Path2DElement>() * 0x1000);\r\n\r\n  /**\r\n   * A reference to the next path item that should be written to the buffer.\r\n   */\r\n  private _pathCurrent: StackPointer<Path2DElement> = this._pathStart;\r\n\r\n  /**\r\n   * An internal function that writes a single path item to the _path.\r\n   *\r\n   * @param {CanvasInstruction} inst - The CanvasInstruction that represents the current pathing\r\n   * operation that should be written to the path buffer.\r\n   * @param {bool} updateTransform - The bool value that determines if the PathElement should store\r\n   * the _currentTransform values.\r\n   * @param {i32} count - The number of parameters for this PathElement's instruction.\r\n   * @param {f64} a - The first parameter for this PathElement's instruction.\r\n   * @param {f64} b - The second parameter for this PathElement's instruction.\r\n   * @param {f64} c - The third parameter for this PathElement's instruction.\r\n   * @param {f64} d - The fourth parameter for this PathElement's instruction.\r\n   * @param {f64} e - The five parameter for this PathElement's instruction.\r\n   * @param {f64} f - The six parameter for this PathElement's instruction.\r\n   * @param {f64} g - The seven parameter for this PathElement's instruction.\r\n   * @param {f64} h - The eighth parameter for this PathElement's instruction.\r\n   */\r\n  @inline\r\n  private _writePath(\r\n    inst: CanvasInstruction,\r\n    updateTransform: bool = false,\r\n    count: i32 = 0,\r\n    a: f64 = 0.0,\r\n    b: f64 = 0.0,\r\n    c: f64 = 0.0,\r\n    d: f64 = 0.0,\r\n    e: f64 = 0.0,\r\n    f: f64 = 0.0,\r\n    g: f64 = 0.0,\r\n    h: f64 = 0.0,\r\n  ): void {\r\n    let _path = this._path;\r\n    let element = _path.reference();\r\n    assert(changetype<usize>(_path) < changetype<usize>(this._pathEnd));\r\n    element.instruction = inst;\r\n    element.updateTransform = updateTransform;\r\n    if (updateTransform) {\r\n      let current = this._stack.reference();\r\n      element.transformA = current.a;\r\n      element.transformB = current.b;\r\n      element.transformC = current.c;\r\n      element.transformD = current.d;\r\n      element.transformE = current.e;\r\n      element.transformF = current.f;\r\n    }\r\n    element.count = count;\r\n    element.a = a;\r\n    element.b = b;\r\n    element.c = c;\r\n    element.d = d;\r\n    element.e = e;\r\n    element.f = f;\r\n    element.g = g;\r\n    element.h = h;\r\n    this._path = _path.increment();\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the queued up path items to the buffer. It optionally calls\r\n   * setTransform if the transform was modified between path calls.\r\n   */\r\n  @inline\r\n  private _updatePath(): void {\r\n    var nextPath = this._path;\r\n    var el: Path2DElement;\r\n    var a: f64;\r\n    var b: f64;\r\n    var c: f64;\r\n    var d: f64;\r\n    var e: f64;\r\n    var f: f64;\r\n    var currentTransform: usize = changetype<usize>(this._currentTransform);\r\n    var currentPath = this._pathCurrent;\r\n    while (currentPath.dereference() < nextPath.dereference()) {\r\n      el = currentPath.reference();\r\n      if (el.updateTransform) {\r\n        a = el.transformA;\r\n        b = el.transformB;\r\n        c = el.transformC;\r\n        d = el.transformD;\r\n        e = el.transformE;\r\n        f = el.transformF;\r\n\r\n        let diff = memory.compare(\r\n          currentTransform,\r\n          changetype<usize>(el) + offsetof<Path2DElement>(\"transformA\"),\r\n          48,\r\n        );\r\n        if (diff != 0) {\r\n          super._writeSix(CanvasInstruction.SetTransform, a, b, c, d, e, f);\r\n          STORE<f64>(currentTransform, 0, a);\r\n          STORE<f64>(currentTransform, 1, b);\r\n          STORE<f64>(currentTransform, 2, c);\r\n          STORE<f64>(currentTransform, 3, d);\r\n          STORE<f64>(currentTransform, 4, e);\r\n          STORE<f64>(currentTransform, 5, f);\r\n        }\r\n      }\r\n      switch (el.count) {\r\n        case 0: {\r\n          super._writeZero(el.instruction);\r\n          break;\r\n        }\r\n        case 1: {\r\n          super._writeOne(el.instruction, el.a);\r\n          break;\r\n        }\r\n        case 2: {\r\n          super._writeTwo(el.instruction, el.a, el.b);\r\n          break;\r\n        }\r\n        case 4: {\r\n          super._writeFour(el.instruction, el.a, el.b, el.c, el.d);\r\n          break;\r\n        }\r\n        case 5: {\r\n          super._writeFive(el.instruction, el.a, el.b, el.c, el.d, el.e);\r\n          break;\r\n        }\r\n        case 6: {\r\n          super._writeSix(el.instruction, el.a, el.b, el.c, el.d, el.e, el.f);\r\n          break;\r\n        }\r\n        case 8: {\r\n          super._writeEight(el.instruction, el.a, el.b, el.c, el.d, el.e, el.f, el.g, el.h);\r\n        }\r\n      }\r\n      currentPath = currentPath.increment();\r\n    }\r\n    this._pathCurrent = currentPath;\r\n  }\r\n  //#endregion PATH\r\n\r\n  //#region ARC\r\n  /**\r\n   * The CanvasRenderingContext2D.arc() method of the Canvas 2D API adds a circular arc to\r\n   * the current sub-path.\r\n   *\r\n   * @param {f64} x - The x-axis (horizontal) coordinate of the arc's center.\r\n   * @param {f64} y - The y-axis (vertical) coordinate of the arc's center.\r\n   * @param {f64} radius - The arc's radius. Must be non-negative.\r\n   * @param {f64} startAngle - The angle at which the arc starts, measured clockwise from the positive x-axis\r\n   * and expressed in radians.\r\n   * @param {f64} endAngle - The angle at which the arc ends, measured clockwise from the positive x-axis and\r\n   * expressed in radians.\r\n   * @param {bool} anticlockwise - An optional bool which, if true, causes the arc to be drawn\r\n   * counter-clockwise between the start and end angles. The default value is false (clockwise).\r\n   */\r\n  public arc(x: f64, y: f64, radius: f64, startAngle: f64, endAngle: f64 , anticlockwise: bool = false): void {\r\n    if (!isFinite(x + y + radius + startAngle + endAngle) || radius < 0) return;\r\n    this._writePath(CanvasInstruction.Arc, true, 6, x, y, radius, startAngle, endAngle, anticlockwise ? 1.0 : 0.0);\r\n  }\r\n  //#endregion ARC\r\n\r\n  //#region ARCTO\r\n  /**\r\n   * The CanvasRenderingContext2D.arcTo() method of the Canvas 2D API adds a circular arc to the current\r\n   * sub-path, using the given control points and radius. The arc is automatically connected to the\r\n   * path's latest point with a straight line, if necessary for the specified parameters. This method is\r\n   * commonly used for making rounded corners.\r\n   *\r\n   * @param {f64} x1 - The x-axis coordinate of the first control point.\r\n   * @param {f64} y1 - The y-axis coordinate of the first control point.\r\n   * @param {f64} x2 - The x-axis coordinate of the second control point.\r\n   * @param {f64} y2 - The y-axis coordinate of the second control point.\r\n   * @param {f64} radius - The arc's radius. Must be non-negative.\r\n   */\r\n  public arcTo(x1: f64, y1: f64, x2: f64, y2: f64, radius: f64): void {\r\n    if (!isFinite(x1 + y1 + x2 + y2 + radius) || radius < 0) return;\r\n    this._writePath(CanvasInstruction.ArcTo, true, 5, x1, y1, x2, y2, radius);\r\n  }\r\n  //#endregion ARCTO\r\n\r\n  //#region BEGINPATH\r\n  /**\r\n   * The CanvasRenderingContext2D.beginPath() method of the Canvas 2D API starts a new path by\r\n   * emptying the list of sub-paths. Call this method when you want to create a new path.\r\n   */\r\n  public beginPath(): void {\r\n    let start = this._pathStart;\r\n    this._path = start.increment();\r\n    this._pathCurrent = start;\r\n  }\r\n  //#endregion BEGINPATH\r\n\r\n  //#region BEZIERCURVETO\r\n  /**\r\n   * The CanvasRenderingContext2D.bezierCurveTo() method of the Canvas 2D API adds a cubic Bézier\r\n   * curve to the current sub-path. It requires three points: the first two are control points and\r\n   * the third one is the end point. The starting point is the latest point in the current path, which\r\n   * can be changed using moveTo() before creating the Bézier curve.\r\n   *\r\n   * @param {f64} cp1x - The x-axis coordinate of the first control point.\r\n   * @param {f64} cp1y - The y-axis coordinate of the first control point.\r\n   * @param {f64} cp2x - The x-axis coordinate of the second control point.\r\n   * @param {f64} cp2y - The y-axis coordinate of the second control point.\r\n   * @param {f64} x - The x-axis coordinate of the end point.\r\n   * @param {f64} y - The y-axis coordinate of the end point.\r\n   */\r\n  public bezierCurveTo(cp1x: f64, cp1y: f64, cp2x: f64, cp2y: f64, x: f64, y: f64): void {\r\n    if (!isFinite(cp1x + cp1y + cp2x + cp2y + x + y)) return;\r\n    this._writePath(CanvasInstruction.BezierCurveTo, true, 6, cp1x, cp1y, cp2x, cp2y, x, y);\r\n  }\r\n  //#endregion BEZIERCURVETO\r\n\r\n  //#region CLEARRECT\r\n  /**\r\n   * The CanvasRenderingContext2D.clearRect() method of the Canvas 2D API erases the pixels in a\r\n   * rectangular area by setting them to transparent black.\r\n   *\r\n   * @param {f64} x - The x-axis coordinate of the rectangle's starting point.\r\n   * @param {f64} y - The y-axis coordinate of the rectangle's starting point.\r\n   * @param {f64} width - The rectangle's width. Positive values are to the right, and negative to\r\n   * the left.\r\n   * @param {f64} height - The rectangle's height. Positive values are down, and negative are up.\r\n   */\r\n  public clearRect(x: f64, y: f64, width: f64, height: f64): void {\r\n    if (!isFinite(x + y + width + height)) return;\r\n    this._updateTransform();\r\n    super._writeFour(CanvasInstruction.ClearRect, x, y, width, height);\r\n  }\r\n  //#endregion CLEARRECT\r\n\r\n  //#region CLIP\r\n  /**\r\n   * The CanvasRenderingContext2D.clip() method of the Canvas 2D API turns the current or given path\r\n   * into the current clipping region. It replaces any previous clipping region. In the image below,\r\n   * the red outline represents a clipping region shaped like a star. Only those parts of the\r\n   * checkerboard pattern that are within the clipping region get drawn.\r\n   */\r\n  public clip(): void {\r\n    this._updatePath();\r\n    super._writeZero(CanvasInstruction.Clip);\r\n  }\r\n  //#endregion CLIP\r\n\r\n  //#region CLOSEPATH\r\n  /**\r\n   * The CanvasRenderingContext2D.closePath() method of the Canvas 2D API attempts to add a straight\r\n   * line from the current point to the start of the current sub-path. If the shape has already been\r\n   * closed or has only one point, this function does nothing. This method doesn't draw anything to\r\n   * the canvas directly. You can render the path using the stroke() or fill() methods.\r\n   */\r\n  public closePath(): void {\r\n    let previous = this._path.decrement().reference();\r\n    if (i32(previous.instruction == CanvasInstruction.BeginPath) | i32(previous.instruction == CanvasInstruction.ClosePath)) return;\r\n    this._writePath(CanvasInstruction.ClosePath, true, 0);\r\n  }\r\n\r\n  //#endregion CLOSEPATH\r\n\r\n  //#region DRAWIMAGE\r\n  /**\r\n   * The CanvasRenderingContext2D.drawImagePosition() method of the Canvas 2D API provides a simple\r\n   * method for drawing an image onto the canvas at a specific position.\r\n   *\r\n   * @param {Image} image - An element to draw into the context. The specification permits any canvas\r\n   * image source (Image).\r\n   * @param {f64} dx - The x-axis coordinate in the destination canvas at which to place the top-left\r\n   * corner of the source image.\r\n   * @param {f64} dy - The y-axis coordinate in the destination canvas at which to place the top-left\r\n   * corner of the source image.\r\n   */\r\n  public drawImage(image: Image | null, dx: f64, dy: f64): void {\r\n    if (image == null || !isFinite(dx + dy) || !image.loaded) return;\r\n    this._updateFilter();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateTransform();\r\n    this._writeNine(\r\n      CanvasInstruction.DrawImage,\r\n      <f64>getImageID(image),\r\n      0.0, 0.0, <f64>image.width, <f64>image.height,\r\n      dx, dy, <f64>image.width, <f64>image.height,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.drawImageSize() method of the Canvas 2D API provides a simple\r\n   * method for drawing an image onto the canvas at a specific position.\r\n   *\r\n   * @param {Image} image - An element to draw into the context. The specification permits any canvas\r\n   * image source (Image).\r\n   * @param {f64} dx - The x-axis coordinate in the destination canvas at which to place the top-left\r\n   * corner of the source image.\r\n   * @param {f64} dy - The y-axis coordinate in the destination canvas at which to place the top-left\r\n   * corner of the source image.\r\n   * @param {f64} dWidth - The width to draw the image in the destination canvas. This allows scaling\r\n   * of the drawn image. If not specified, the image is not scaled in width when drawn.\r\n   * @param {f64} dHeight - The height to draw the image in the destination canvas. This allows scaling\r\n   * of the drawn image. If not specified, the image is not scaled in height when drawn.\r\n   */\r\n  public drawImageSize(image: Image | null, dx: f64, dy: f64, dWidth: f64, dHeight: f64): void {\r\n    if (image == null || !isFinite(dx + dy + dWidth + dHeight) || !image.loaded) return;\r\n    this._updateFilter();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateTransform();\r\n    this._writeNine(\r\n      CanvasInstruction.DrawImage,\r\n      <f64>getImageID(image),\r\n      0.0, 0.0, <f64>image.width, <f64>image.height,\r\n      dx, dy, dWidth, dHeight,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.drawImageSource() method of the Canvas 2D API provides a simple\r\n   * method for drawing an image onto the canvas at a specific position.\r\n   *\r\n   * @param {Image} image - An element to draw into the context. The specification permits any canvas\r\n   * image source (Image).\r\n   * @param {f64} sx - The x-axis coordinate of the top left corner of the sub-rectangle of the source\r\n   * image to draw into the destination context.\r\n   * @param {f64} sy - The y-axis coordinate of the top left corner of the sub-rectangle of the source\r\n   * image to draw into the destination context.\r\n   * @param {f64} sWidth - The width of the sub-rectangle of the source image to draw into the\r\n   * destination context. If not specified, the entire rectangle from the coordinates specified by sx\r\n   * and sy to the bottom-right corner of the image is used.\r\n   * @param {f64} sHeight - The height of the sub-rectangle of the source image to draw into the\r\n   * destination context.\r\n   * @param {f64} dx - The x-axis coordinate in the destination canvas at which to place the top-left\r\n   * corner of the source image.\r\n   * @param {f64} dy - The y-axis coordinate in the destination canvas at which to place the top-left\r\n   * corner of the source image.\r\n   * @param {f64} dWidth - The width to draw the image in the destination canvas. This allows scaling\r\n   * of the drawn image. If not specified, the image is not scaled in width when drawn.\r\n   * @param {f64} dHeight - The height to draw the image in the destination canvas. This allows scaling\r\n   * of the drawn image. If not specified, the image is not scaled in height when drawn.\r\n   */\r\n  public drawImageSource(image: Image | null, sx: f64, sy: f64, sWidth: f64, sHeight: f64, dx: f64, dy: f64, dWidth: f64, dHeight: f64): void {\r\n    if (image == null || !isFinite(sx + sy + sWidth + sHeight + dx + dy + dWidth + dHeight) || !image.loaded) return;\r\n    this._updateFilter();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateTransform();\r\n    this._writeNine(\r\n      CanvasInstruction.DrawImage,\r\n      <f64>getImageID(image),\r\n      sx, sy, sWidth, sHeight,\r\n      dx, dy, dWidth, dHeight,\r\n    );\r\n  }\r\n  //#endregion DRAWIMAGE\r\n\r\n  //#region ELLIPSE\r\n  /**\r\n   * The CanvasRenderingContext2D.ellipse() method of the Canvas 2D API adds an elliptical arc to the current sub-path.\r\n   *\r\n   * @param {f64} x - The x-axis (horizontal) coordinate of the ellipse's center.\r\n   * @param {f64} y - The y-axis (vertical) coordinate of the ellipse's center.\r\n   * @param {f64} radiusX - The ellipse's major-axis radius. Must be non-negative.\r\n   * @param {f64} radiusY - The ellipse's minor-axis radius. Must be non-negative.\r\n   * @param {f64} rotation - The rotation of the ellipse, expressed in radians.\r\n   * @param {f64} startAngle - The angle at which the ellipse starts, measured clockwise from the positive x-axis\r\n   * and expressed in radians.\r\n   * @param {f64} endAngle - The angle at which the ellipse ends, measured clockwise from the positive x-axis and\r\n   * expressed in radians.\r\n   * @param {bool} anticlockwise - An optional Boolean which, if true, draws the ellipse anticlockwise\r\n   * (counter-clockwise). The default value is false (clockwise).\r\n   */\r\n  public ellipse(x: f64, y: f64, radiusX: f64, radiusY: f64, rotation: f64, startAngle: f64, endAngle: f64, anticlockwise: bool = false): void {\r\n    if (!isFinite(x + y + radiusX + radiusY + rotation + startAngle + endAngle) || radiusX < 0 || radiusY < 0) return;\r\n    this._writePath(\r\n      CanvasInstruction.Ellipse,\r\n      true, 8,\r\n      x, y, radiusX, radiusY,\r\n      rotation, startAngle, endAngle, anticlockwise ? 1.0 : 0.0,\r\n    );\r\n  }\r\n  //#endregion ELLIPSE\r\n\r\n  //#region FILL\r\n  /**\r\n   * The CanvasRenderingContext2D.fill() method of the Canvas 2D API fills the current or given path\r\n   * with the current fillStyle.\r\n   *\r\n   * @param {FillRule} fillRule - The algorithm by which to determine if a point is inside or\r\n   * outside the filling region.\r\n   *\r\n   * Possible values:\r\n   * - `FillRule.nonzero`: The non-zero winding rule. Default rule.\r\n   * - `FillRule.evenodd`: The even-odd winding rule.\r\n   */\r\n  public fill(fillRule: FillRule = FillRule.nonzero): void {\r\n    /**\r\n     * If there are no items on the path, there is no reason to fill. Index 1 means the path buffer\r\n     * is pointing to a single `beginPath()` operation and it does not matter if fill is called at\r\n     * this point.\r\n     */\r\n    if (this._path == this._pathStart.increment()) return;\r\n    this._updateFillStyle();\r\n    this._updateFilter();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n\r\n    /**\r\n     * This function must be called *before* _updateTransform(), because both the path operations and the\r\n     * fill operations affect the transform. Each pathing operation has it's own transform, and the\r\n     * transform value when the fill operation occurs might be different.\r\n     */\r\n    this._updatePath();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateTransform();\r\n    super._writeOne(CanvasInstruction.Fill, <f64>fillRule);\r\n  }\r\n  //#endregion FILL\r\n\r\n  //#region FILLRECT\r\n  /**\r\n   * The CanvasRenderingContext2D.fillRect() method of the Canvas 2D API draws a rectangle that is\r\n   * filled according to the current fillStyle. This method draws directly to the canvas without\r\n   * modifying the current path, so any subsequent fill() or stroke() calls will have no effect on\r\n   * it.\r\n   *\r\n   * @param x - The x-axis coordinate of the rectangle's starting point.\r\n   * @param y - The y-axis coordinate of the rectangle's starting point.\r\n   * @param width - The rectangle's width. Positive values are to the right, and negative to the\r\n   * left.\r\n   * @param height - The rectangle's height. Positive values are down, and negative are up.\r\n   */\r\n  public fillRect(x: f64, y: f64, width: f64, height: f64): void {\r\n    if (!isFinite(x + y + width + height)) return;\r\n    this._updateFillStyle();\r\n    this._updateFilter();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateTransform();\r\n    super._writeFour(CanvasInstruction.FillRect, x, y, width, height);\r\n  }\r\n  //#endregion FILLRECT\r\n\r\n  //#region FILLTEXT\r\n  /**\r\n   * The CanvasRenderingContext2D method fillText(), part of the Canvas 2D API, draws a text string\r\n   * at the specified coordinates, filling the string's characters with the current fillStyle. An\r\n   * optional parameter allows specifying a maximum width for the rendered text, which the user\r\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\r\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\r\n   * calls will have no effect on it. The text is rendered using the font and text layout\r\n   * configuration as defined by the font, textAlign, textBaseline, and direction properties.\r\n   *\r\n   * The fillText function can accept an optional maxWidth property. Use the fillTextWidth function\r\n   * to enable the use of that parameter.\r\n   *\r\n   * @param text - A DOMString specifying the text string to render into the context. The text is\r\n   * rendered using the settings specified by font, textAlign, textBaseline, and direction.\r\n   * @param x - The x-axis coordinate of the point at which to begin drawing the text, in pixels.\r\n   * @param y - The y-axis coordinate of the point at which to begin drawing the text, in pixels.\r\n   */\r\n  public fillText(text: string, x: f64, y: f64): void {\r\n    if (!isFinite(x + y) || text == null || text.length == 0) return;\r\n    this._updateDirection();\r\n    this._updateFillStyle();\r\n    this._updateFilter();\r\n    this._updateFont();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateTextAlign();\r\n    this._updateTextBaseline();\r\n    this._updateTransform();\r\n    super._retain(changetype<usize>(text));\r\n    super._writeThree(CanvasInstruction.FillText, <f64>changetype<usize>(text), x, y);\r\n  }\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D method fillText(), part of the Canvas 2D API, draws a text string\r\n   * at the specified coordinates, filling the string's characters with the current fillStyle. An\r\n   * optional parameter allows specifying a maximum width for the rendered text, which the user\r\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\r\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\r\n   * calls will have no effect on it. The text is rendered using the font and text layout\r\n   * configuration as defined by the font, textAlign, textBaseline, and direction properties.\r\n   *\r\n   * The fillText function can accept an optional maxWidth property. Use the fillTextWidth function\r\n   * to enable the use of that parameter.\r\n   *\r\n   * @param text - A DOMString specifying the text string to render into the context. The text is\r\n   * rendered using the settings specified by font, textAlign, textBaseline, and direction.\r\n   * @param x - The x-axis coordinate of the point at which to begin drawing the text, in pixels.\r\n   * @param y - The y-axis coordinate of the point at which to begin drawing the text, in pixels.\r\n   * @param maxWidth - The maximum number of pixels wide the text may be once rendered. If not\r\n   * specified, there is no limit to the width of the text. However, if this value is provided, the\r\n   * user agent will adjust the kerning, select a more horizontally condensed font (if one is available or can be generated without loss of quality), or scale down to a smaller font size in order to fit the text in the specified width.\r\n   */\r\n  public fillTextWidth(text: string, x: f64, y: f64, maxWidth: f64): void {\r\n    if (!isFinite(x + y + maxWidth) || text == null || text.length == 0 || maxWidth < 0) return;\r\n    this._updateDirection();\r\n    this._updateFillStyle();\r\n    this._updateFilter();\r\n    this._updateFont();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateTextAlign();\r\n    this._updateTextBaseline();\r\n    this._updateTransform();\r\n    super._retain(changetype<usize>(text));\r\n    super._writeFour(CanvasInstruction.FillTextWidth, <f64>changetype<usize>(text), x, y, maxWidth);\r\n  }\r\n  //#endregion FILLTEXT\r\n\r\n  //#region ISPOINTINPATH\r\n  /**\r\n   * The CanvasRenderingContext2D.isPointInPath() method of the Canvas 2D API reports whether or not\r\n   * the specified point is contained in the current path. It forces a commit to flush all the\r\n   * current instructions to the buffer, updates the path, and then performs a pointInPath function\r\n   * call on the canvas.\r\n   *\r\n   * @param {f64} x - The x-axis coordinate of the point to check.\r\n   * @param {f64} y - The y-axis coordinate of the point to check.\r\n   * @param {FillRule} fillRule - The algorithm by which to determine if a point is inside or\r\n   * outside the path.\r\n   *\r\n   * Possible values:\r\n   * - `FillRule.nonzero`: The non-zero winding rule. Default rule.\r\n   * - `FillRule.evenodd`: The even-odd winding rule.\r\n   */\r\n  public isPointInPath(x: f64, y: f64, fillRule: FillRule = FillRule.nonzero): bool {\r\n    if (!isFinite(x + y)) return false;\r\n    this._updatePath();\r\n    this.commit();\r\n    return isPointInPath(this.id, x, y, fillRule);\r\n  }\r\n  //#endregion ISPOINTINPATH\r\n\r\n  //#region ISPOINTINSTROKE\r\n  /**\r\n   * The CanvasRenderingContext2D.isPointInStroke() method of the Canvas 2D API reports whether or\r\n   * not the specified point is inside the area contained by the stroking of a path. It forces a\r\n   * commit to flush all the current instructions to the buffer, updates the path, and then performs\r\n   * a pointInPath function call on the canvas.\r\n   *\r\n   * @param {f64} x - The x-axis coordinate of the point to check.\r\n   * @param {f64} y - The y-axis coordinate of the point to check.\r\n   */\r\n  public isPointInStroke(x: f64, y: f64): bool {\r\n    if (!isFinite(x + y)) return false;\r\n    this._updatePath();\r\n    this.commit();\r\n    return isPointInStroke(this.id, x, y);\r\n  }\r\n  //#endregion ISPOINTINSTROKE\r\n\r\n  //#region LINETO\r\n  /**\r\n   * The CanvasRenderingContext2D method lineTo(), part of the Canvas 2D API, adds a straight line\r\n   * to the current sub-path by connecting the sub-path's last point to the specified (x, y)\r\n   * coordinates. Like other methods that modify the current path, this method does not directly\r\n   * render anything. To draw the path onto a canvas, you can use the fill() or stroke() methods.\r\n   *\r\n   * @param {f64} x - The x-axis coordinate of the line's end point.\r\n   * @param {f64} y - The y-axis coordinate of the line's end point.\r\n   */\r\n  public lineTo(x: f64, y: f64): void {\r\n    if (!isFinite(x + y)) return;\r\n    this._writePath(CanvasInstruction.LineTo, true, 2, x, y);\r\n  }\r\n  //#endregion LINETO\r\n\r\n  //#region MEASURETEXT\r\n  /**\r\n   * The CanvasRenderingContext2D.measureText() method returns a TextMetrics object that contains\r\n   * information about the measured text (such as its width, for example). The as2d implementation\r\n   * only returns the resulting width property value.\r\n   *\r\n   * @param {string} text - The text string to measure.\r\n   */\r\n  public measureText(text: string): f64 {\r\n    this._updateFont();\r\n    this.commit();\r\n    return measureText(this.id, text);\r\n  }\r\n  //#endregion MEASURETEXT\r\n\r\n  //#region MOVETO\r\n  /**\r\n   * The CanvasRenderingContext2D.moveTo() method of the Canvas 2D API begins a new sub-path at the\r\n   * point specified by the given (x, y) coordinates.\r\n   *\r\n   * @param {f64} x - The x-axis (horizontal) coordinate of the point.\r\n   * @param {f64} y - The y-axis (vertical) coordinate of the point.\r\n   */\r\n  public moveTo(x: f64, y: f64): void {\r\n    if (!isFinite(x + y)) return;\r\n    this._writePath(CanvasInstruction.MoveTo, true, 2, x, y);\r\n  }\r\n  //#endregion MOVETO\r\n\r\n  //#region QUADRATICCURVETO\r\n  /**\r\n   * The CanvasRenderingContext2D.quadraticCurveTo() method of the Canvas 2D API adds a quadratic\r\n   * Bézier curve to the current sub-path. It requires two points: the first one is a control point\r\n   * and the second one is the end point. The starting point is the latest point in the current\r\n   * path, which can be changed using moveTo() before creating the quadratic Bézier curve.\r\n   *\r\n   * @param cpx - The x-axis coordinate of the control point.\r\n   * @param cpy - The y-axis coordinate of the control point.\r\n   * @param x - The x-axis coordinate of the end point.\r\n   * @param y - The y-axis coordinate of the end point.\r\n   */\r\n  public quadraticCurveTo(cpx: f64, cpy: f64, x: f64, y: f64): void {\r\n    if (!isFinite(cpx + cpy + x + y)) return;\r\n    this._writePath(CanvasInstruction.QuadraticCurveTo, true, 4, cpx, cpy, x, y);\r\n  }\r\n  //#endregion QUADRATICCURVETO\r\n\r\n  //#region RECT\r\n  /**\r\n   * The CanvasRenderingContext2D.rect() method of the Canvas 2D API adds a rectangle to the current\r\n   * path. Like other methods that modify the current path, this method does not directly render\r\n   * anything. To draw the rectangle onto a canvas, you can use the fill() or stroke() methods.\r\n   *\r\n   * @param {f64} x - The x-axis coordinate of the rectangle's starting point.\r\n   * @param {f64} y - The y-axis coordinate of the rectangle's starting point.\r\n   * @param {f64} width - The rectangle's width. Positive values are to the right, and negative to\r\n   * the left.\r\n   * @param {f64} height - The rectangle's height. Positive values are down, and negative are up.\r\n   */\r\n  public rect(x: f64, y: f64, width: f64, height: f64): void {\r\n    if (!isFinite(x + y + width + height)) return;\r\n    this._writePath(CanvasInstruction.Rect, true, 4, x, y, width, height);\r\n  }\r\n  //#endregion RECT\r\n\r\n  //#region RESETTRANSFORM\r\n  /**\r\n   * The CanvasRenderingContext2D.resetTransform() method of the Canvas 2D API resets the current\r\n   * transform to the identity matrix.\r\n   */\r\n  public resetTransform(): void {\r\n    this.setTransform(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);\r\n  }\r\n  //#endregion RESETTRANSFORM\r\n\r\n  //#region ROTATE\r\n  /**\r\n   * The CanvasRenderingContext2D.rotate() method of the Canvas 2D API adds a rotation to the\r\n   * transformation matrix.\r\n   *\r\n   * @param {f64} angle - The rotation angle, clockwise in radians. You can use\r\n   * `degree * Math.PI / 180` if you want to calculate from a degree value.\r\n   */\r\n  public rotate(angle: f64): void {\r\n    if (!isFinite(angle)) return;\r\n\r\n    var stack = this._stack.reference();\r\n\r\n    NativeMath.sincos(angle);\r\n    var cos: f64 = NativeMath.sincos_cos;\r\n    var sin: f64 = NativeMath.sincos_sin;\r\n\r\n    if (ASC_FEATURE_SIMD) {\r\n      let cossplat = v128.splat<f64>(cos);\r\n      let sinsplat = v128.splat<f64>(sin);\r\n      let aptr = changetype<usize>(stack) + offsetof<CanvasStack>(\"a\");\r\n      let cptr = changetype<usize>(stack) + offsetof<CanvasStack>(\"c\");\r\n      let ab = v128.load(aptr);\r\n      let cb = v128.load(cptr);\r\n      v128.store(aptr,\r\n        v128.add<f64>(\r\n          v128.mul<f64>(ab, cossplat),\r\n          v128.mul<f64>(cb, sinsplat),\r\n        ),\r\n      );\r\n      v128.store(cptr,\r\n        v128.sub<f64>(\r\n          v128.mul<f64>(cb, cossplat),\r\n          v128.mul<f64>(ab, sinsplat),\r\n        ),\r\n      );\r\n    } else {\r\n      var a = stack.a;\r\n      var b = stack.b;\r\n      var c = stack.c;\r\n      var d = stack.d;\r\n      stack.a = a * cos + c * sin;\r\n      stack.b = b * cos + d * sin;\r\n      stack.c = c * cos - a * sin;\r\n      stack.d = d * cos - b * sin;\r\n    }\r\n  }\r\n  //#endregion ROTATE\r\n\r\n  //#region SCALE\r\n  /**\r\n   * The CanvasRenderingContext2D.scale() method of the Canvas 2D API adds a scaling transformation\r\n   * to the canvas units horizontally and/or vertically. By default, one unit on the canvas is\r\n   * exactly one pixel. A scaling transformation modifies this behavior. For instance, a scaling\r\n   * factor of 0.5 results in a unit size of 0.5 pixels; shapes are thus drawn at half the normal\r\n   * size. Similarly, a scaling factor of 2.0 increases the unit size so that one unit becomes two\r\n   * pixels; shapes are thus drawn at twice the normal size.\r\n   *\r\n   * @param {f64} x - Scaling factor in the horizontal direction. A negative value flips pixels\r\n   * across the vertical axis. A value of 1 results in no horizontal scaling.\r\n   * @param {f64} y - Scaling factor in the vertical direction. A negative value flips pixels across\r\n   * the horizontal axis. A value of 1 results in no vertical scaling.\r\n   */\r\n  public scale(x: f64, y: f64): void {\r\n    if (!isFinite(x + y)) return;\r\n    let stack = this._stack.reference();\r\n    if (ASC_FEATURE_SIMD) {\r\n      let abptr = changetype<usize>(this) + offsetof<CanvasStack>(\"a\");\r\n      let cdptr = changetype<usize>(this) + offsetof<CanvasStack>(\"c\");\r\n      v128.store(abptr,\r\n        v128.mul<f64>(\r\n          v128.load(abptr),\r\n          v128.splat<f64>(x),\r\n        ),\r\n      );\r\n      v128.store(cdptr,\r\n        v128.mul<f64>(\r\n          v128.load(cdptr),\r\n          v128.splat<f64>(y),\r\n        ),\r\n      );\r\n    } else {\r\n      stack.a *= x;\r\n      stack.b *= x;\r\n      stack.c *= y;\r\n      stack.d *= y;\r\n    }\r\n  }\r\n  //#endregion SCALE\r\n\r\n  //#region SETTRANSFORM\r\n  /**\r\n   * The CanvasRenderingContext2D.setTransform() method of the Canvas 2D API resets (overrides) the\r\n   * current transformation to the identity matrix, and then invokes a transformation described by\r\n   * the arguments of this method. This lets you scale, rotate, translate (move), and skew the\r\n   * context.\r\n   *\r\n   * @param {f64} a - Horizontal scaling. A value of 1 results in no scaling.\r\n   * @param {f64} b - Vertical skewing.\r\n   * @param {f64} c - Horizontal skewing.\r\n   * @param {f64} d - Vertical scaling. A value of 1 results in no scaling.\r\n   * @param {f64} e - Horizontal translation (moving).\r\n   * @param {f64} f - Vertical translation (moving).\r\n   */\r\n  public setTransform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    if (!isFinite(a + b + c + d + e + f)) return ;\r\n    let stack = this._stack.reference();\r\n    stack.a = a;\r\n    stack.b = b;\r\n    stack.c = c;\r\n    stack.d = d;\r\n    stack.e = e;\r\n    stack.f = f;\r\n  }\r\n  //#endregion SETTRANSFORM\r\n\r\n  //#region STROKE\r\n  /**\r\n   * The CanvasRenderingContext2D.stroke() method of the Canvas 2D API strokes (outlines) the\r\n   * current or given path with the current stroke style. Strokes are aligned to the center of a\r\n   * path; in other words, half of the stroke is drawn on the inner side, and half on the outer\r\n   * side. The stroke is drawn using the non-zero winding rule, which means that path intersections\r\n   * will still get filled.\r\n   */\r\n  public stroke(): void {\r\n    /**\r\n     * If there are no items on the path, there is no reason to fill. Index 1 means the path buffer\r\n     * is pointing to a single `beginPath()` operation and it does not matter if fill is called at\r\n     * this point.\r\n     */\r\n    if (this._path == this._pathStart.increment()) return;\r\n\r\n    /**\r\n     * If the lineWidth is zero, there is no line and it does not matter if ctx.stroke() is called.\r\n     */\r\n    if (this._stack.reference().lineWidth <= 0.0) return;\r\n    this._updateFilter();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateLineCap();\r\n    this._updateLineDash();\r\n    this._updateLineDashOffset();\r\n    this._updateLineJoin();\r\n    this._updateLineWidth();\r\n    this._updateMiterLimit();\r\n    this._updatePath();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateStrokeStyle();\r\n    this._updateTransform();\r\n    super._writeZero(CanvasInstruction.Stroke);\r\n  }\r\n  //#endregion STROKE\r\n\r\n  //#region STROKERECT\r\n  /**\r\n   * The CanvasRenderingContext2D.strokeRect() method of the Canvas 2D API draws a rectangle that is\r\n   * stroked (outlined) according to the current strokeStyle and other context settings. This method\r\n   * draws directly to the canvas without modifying the current path, so any subsequent fill() or\r\n   * stroke() calls will have no effect on it.\r\n   *\r\n   * @param {f64} x - The x-axis coordinate of the rectangle's starting point.\r\n   * @param {f64} y - The y-axis coordinate of the rectangle's starting point.\r\n   * @param {f64} width - The rectangle's width. Positive values are to the right, and negative to\r\n   * the left.\r\n   * @param {f64} height - The rectangle's height. Positive values are down, and negative are up.\r\n   */\r\n  public strokeRect(x: f64, y: f64, width: f64, height: f64): void {\r\n    /**\r\n     * If the lineWidth is zero, there is no line and it does not matter if ctx.stroke() is called.\r\n     */\r\n    if (this._stack.reference().lineWidth <= 0.0) return;\r\n    this._updateFilter();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateLineCap();\r\n    this._updateLineDash();\r\n    this._updateLineDashOffset();\r\n    this._updateLineJoin();\r\n    this._updateLineWidth();\r\n    this._updateMiterLimit();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateStrokeStyle();\r\n    this._updateTransform();\r\n    super._writeFour(CanvasInstruction.StrokeRect, x, y, width, height);\r\n  }\r\n  //#endregion STROKERECT\r\n\r\n  //#region STROKETEXT\r\n  /**\r\n   * The CanvasRenderingContext2D method strokeText(), part of the Canvas 2D API, strokes — that is,\r\n   * draws the outlines of — the characters of a text string at the specified coordinates. An\r\n   * optional parameter allows specifying a maximum width for the rendered text, which the user\r\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\r\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\r\n   * calls will have no effect on it. To use the maxWidth parameter, use the strokeTextWidth\r\n   * function.\r\n   *\r\n   * @param {string} text - A DOMString specifying the text string to render into the context. The\r\n   * text is rendered using the settings specified by font, textAlign, textBaseline, and direction.\r\n   * @param {f64} x - The x-axis coordinate of the point at which to begin drawing the text.\r\n   * @param {f64} y - The y-axis coordinate of the point at which to begin drawing the text.\r\n   */\r\n  public strokeText(text: string, x: f64, y: f64): void {\r\n    if (!isFinite(x + y) || text == null || text.length == 0) return;\r\n    this._updateDirection();\r\n    this._updateFilter();\r\n    this._updateFont();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateLineCap();\r\n    this._updateLineDash();\r\n    this._updateLineDashOffset();\r\n    this._updateLineJoin();\r\n    this._updateLineWidth();\r\n    this._updateMiterLimit();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateStrokeStyle();\r\n    this._updateTextAlign();\r\n    this._updateTextBaseline();\r\n    this._updateTransform();\r\n    super._retain(changetype<usize>(text));\r\n    super._writeThree(CanvasInstruction.StrokeText, <f64>changetype<usize>(text), x, y)\r\n  }\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D method strokeTextWidth(), part of the Canvas 2D API, strokes —\r\n   * that is, draws the outlines of — the characters of a text string at the specified coordinates.\r\n   * An optional parameter allows specifying a maximum width for the rendered text, which the user\r\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\r\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\r\n   * calls will have no effect on it. To use the maxWidth parameter, use the strokeTextWidth\r\n   * function.\r\n   *\r\n   * @param {string} text - A DOMString specifying the text string to render into the context. The\r\n   * text is rendered using the settings specified by font, textAlign, textBaseline, and direction.\r\n   * @param {f64} x - The x-axis coordinate of the point at which to begin drawing the text.\r\n   * @param {f64} y - The y-axis coordinate of the point at which to begin drawing the text.\r\n   * @param {f64} maxWidth - The maximum width the text may be once rendered. If not specified,\r\n   * there is no limit to the width of the text. However, if this value is provided, the user agent\r\n   * will adjust the kerning, select a more horizontally condensed font (if one is available or can\r\n   * be generated without loss of quality), or scale down to a smaller font size in order to fit the\r\n   * text in the specified width.\r\n   */\r\n  public strokeTextWidth(text: string, x: f64, y: f64, maxWidth: f64): void {\r\n    if (!isFinite(x + y + maxWidth) || text == null || text.length == 0 || maxWidth < 0) return;\r\n    this._updateDirection();\r\n    this._updateFilter();\r\n    this._updateFont();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateLineCap();\r\n    this._updateLineDash();\r\n    this._updateLineDashOffset();\r\n    this._updateLineJoin();\r\n    this._updateLineWidth();\r\n    this._updateMiterLimit();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateStrokeStyle();\r\n    this._updateTextAlign();\r\n    this._updateTextBaseline();\r\n    this._updateTransform();\r\n    super._retain(changetype<usize>(text));\r\n    super._writeFour(CanvasInstruction.StrokeTextWidth, <f64>changetype<usize>(text), x, y, maxWidth);\r\n  }\r\n  //#endregion STROKETEXT\r\n\r\n  //#region TRANSFORM\r\n  /**\r\n   * The CanvasRenderingContext2D.transform() method of the Canvas 2D API multiplies the current\r\n   * transformation with the matrix described by the arguments of this method. This lets you scale,\r\n   * rotate, translate (move), and skew the context.\r\n   *\r\n   * @param {f64} a - Horizontal scaling. A value of 1 results in no scaling.\r\n   * @param {f64} b - Vertical skewing.\r\n   * @param {f64} c - Horizontal skewing.\r\n   * @param {f64} d - Vertical scaling. A value of 1 results in no scaling.\r\n   * @param {f64} e - Horizontal translation (moving).\r\n   * @param {f64} f - Vertical translation (moving).\r\n   */\r\n  public transform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    if (!isFinite(a + b + c + d + e + f)) return;\r\n    if (ASC_FEATURE_SIMD) {\r\n      let stack = this._stack.dereference();\r\n      let abptr = stack + offsetof<CanvasStack>(\"a\");\r\n      let cdptr = stack + offsetof<CanvasStack>(\"c\");\r\n      let efptr = stack + offsetof<CanvasStack>(\"e\");\r\n      let ab = v128.load(abptr);\r\n      let cd = v128.load(cdptr);\r\n      let ef = v128.load(efptr);\r\n      v128.store(\r\n        abptr,\r\n        v128.add<f64>(\r\n          v128.mul(ab, v128.splat<f64>(a)),\r\n          v128.mul(cd, v128.splat<f64>(b)),\r\n        ),\r\n      );\r\n      v128.store(\r\n        cdptr,\r\n        v128.add<f64>(\r\n          v128.mul(ab, v128.splat<f64>(c)),\r\n          v128.mul(cd, v128.splat<f64>(d)),\r\n        ),\r\n      );\r\n      v128.store(\r\n        efptr,\r\n        v128.add<f64>(\r\n          v128.add<f64>(\r\n            v128.mul(ab, v128.splat<f64>(e)),\r\n            v128.mul(cd, v128.splat<f64>(f)),\r\n          ),\r\n          ef,\r\n        ),\r\n      );\r\n    } else {\r\n      let stack = this._stack.reference();\r\n      var sa = stack.a;\r\n      var sb = stack.b;\r\n      var sc = stack.c;\r\n      var sd = stack.d;\r\n      var se = stack.e;\r\n      var sf = stack.f;\r\n      stack.a = sa * a + sc * b;\r\n      stack.b = sb * a + sd * b;\r\n      stack.c = sa * c + sc * d;\r\n      stack.d = sb * c + sd * d;\r\n      stack.e = sa * e + sc * f + se;\r\n      stack.f = sb * e + sd * f + sf;\r\n    }\r\n  }\r\n  //#endregion TRANSFORM\r\n\r\n  //#region TRANSLATE\r\n  /**\r\n   * The CanvasRenderingContext2D.translate() method of the Canvas 2D API adds a translation\r\n   * transformation to the current matrix.\r\n   * @param {f64} x - Distance to move in the horizontal direction. Positive values are to the\r\n   * right, and negative to the left.\r\n   * @param {f64} y - Distance to move in the vertical direction. Positive values are down, and\r\n   * negative are up.\r\n   */\r\n  public translate(x: f64, y: f64): void {\r\n    if (!isFinite(x + y)) return;\r\n\r\n    if (ASC_FEATURE_SIMD) {\r\n      let stack = this._stack.dereference();\r\n      let efptr = stack + offsetof<CanvasStack>(\"e\");\r\n      v128.store(\r\n        efptr,\r\n        v128.add<f64>(\r\n          v128.mul<f64>(\r\n            v128.load(stack + offsetof<CanvasStack>(\"a\")),\r\n            v128.splat<f64>(x),\r\n          ),\r\n          v128.mul<f64>(\r\n            v128.load(stack + offsetof<CanvasStack>(\"c\")),\r\n            v128.splat<f64>(y),\r\n          ),\r\n        ),\r\n      );\r\n    } else {\r\n      let stack = this._stack.reference();\r\n      stack.e += stack.a * x + stack.c * y;\r\n      stack.f += stack.b * x + stack.d * y;\r\n    }\r\n  }\r\n  //#endregion TRANSLATE\r\n\r\n  public commit(): void {\r\n    super._writeZero(CanvasInstruction.Commit);\r\n    render(this.id, changetype<usize>(this._buffer));\r\n    super._resetBuffer();\r\n  }\r\n}\r\n","/// <reference path=\"./rt/index.d.ts\" />\r\n\r\nimport { BLOCK, BLOCK_MAXSIZE, BLOCK_OVERHEAD } from \"./rt/common\";\r\nimport { idof } from \"./builtins\";\r\nimport { E_INVALIDLENGTH } from \"./util/error\";\r\n\r\nexport abstract class ArrayBufferView {\r\n\r\n  readonly buffer: ArrayBuffer;\r\n  @unsafe readonly dataStart: usize;\r\n  readonly byteLength: i32;\r\n\r\n  get byteOffset(): i32 {\r\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\r\n  }\r\n\r\n  get length(): i32 {\r\n    ERROR(\"missing implementation: subclasses must implement ArrayBufferView#length\");\r\n    return unreachable();\r\n  }\r\n\r\n  protected constructor(length: i32, alignLog2: i32) {\r\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\r\n    var buffer = __alloc(length = length << alignLog2, idof<ArrayBuffer>());\r\n    memory.fill(buffer, 0, <usize>length);\r\n    this.buffer = changetype<ArrayBuffer>(buffer); // retains\r\n    this.dataStart = buffer;\r\n    this.byteLength = length;\r\n  }\r\n}\r\n\r\n@sealed export class ArrayBuffer {\r\n\r\n  static isView<T>(value: T): bool {\r\n    if (value) {\r\n      if (value instanceof Int8Array) return true;\r\n      if (value instanceof Uint8Array) return true;\r\n      if (value instanceof Uint8ClampedArray) return true;\r\n      if (value instanceof Int16Array) return true;\r\n      if (value instanceof Uint16Array) return true;\r\n      if (value instanceof Int32Array) return true;\r\n      if (value instanceof Uint32Array) return true;\r\n      if (value instanceof Int64Array) return true;\r\n      if (value instanceof Uint64Array) return true;\r\n      if (value instanceof Float32Array) return true;\r\n      if (value instanceof Float64Array) return true;\r\n      if (value instanceof DataView) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  constructor(length: i32) {\r\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\r\n    var buffer = __alloc(<usize>length, idof<ArrayBuffer>());\r\n    memory.fill(buffer, 0, <usize>length);\r\n    return changetype<ArrayBuffer>(buffer); // retains\r\n  }\r\n\r\n  get byteLength(): i32 {\r\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize;\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\r\n    var length = this.byteLength;\r\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\r\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\r\n    var outSize = <usize>max(end - begin, 0);\r\n    var out = __alloc(outSize, idof<ArrayBuffer>());\r\n    memory.copy(out, changetype<usize>(this) + <usize>begin, outSize);\r\n    return changetype<ArrayBuffer>(out); // retains\r\n  }\r\n\r\n  toString(): string {\r\n    return \"[object ArrayBuffer]\";\r\n  }\r\n}\r\n","/// <reference path=\"../rt/index.d.ts\" />\r\n\r\nimport { idof } from \"../builtins\";\r\nimport { CharCode } from \"./string\";\r\nimport { ArrayBufferView } from \"../arraybuffer\";\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport const MAX_DOUBLE_LENGTH = 28;\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nconst POWERS10: u32[] = [\r\n  1,\r\n  10,\r\n  100,\r\n  1000,\r\n  10000,\r\n  100000,\r\n  1000000,\r\n  10000000,\r\n  100000000,\r\n  1000000000\r\n];\r\n\r\n/*\r\n  Lookup table for pairwise char codes in range [0-99]\r\n\r\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\r\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\r\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\r\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\r\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\r\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\r\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\r\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\r\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\r\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\r\n*/\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nconst DIGITS: u32[] = [\r\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\r\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\r\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\r\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\r\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\r\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\r\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\r\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\r\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\r\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\r\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\r\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\r\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\r\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\r\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\r\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\r\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\r\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\r\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\r\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\r\n];\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nconst EXP_POWERS: i16[] = [\r\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\r\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\r\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\r\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\r\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\r\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\r\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\r\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\r\n    907,   933,   960,   986,  1013,  1039,  1066\r\n];\r\n\r\n// 1e-348, 1e-340, ..., 1e340\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nconst FRC_POWERS: u64[] = [\r\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\r\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\r\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\r\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\r\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\r\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\r\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\r\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\r\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\r\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\r\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\r\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\r\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\r\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\r\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\r\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\r\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\r\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\r\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\r\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\r\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\r\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\r\n];\r\n\r\n// Count number of decimals for u32 values\r\n// In our case input value always non-zero so we can simplify some parts\r\nexport function decimalCount32(value: u32): u32 {\r\n  if (value < 100000) {\r\n    if (value < 100) {\r\n      return select<u32>(1, 2, value < 10);\r\n    } else {\r\n      let m = select<u32>(4, 5, value < 10000);\r\n      return select<u32>(3, m, value < 1000);\r\n    }\r\n  } else {\r\n    if (value < 10000000) {\r\n      return select<u32>(6, 7, value < 1000000);\r\n    } else {\r\n      let m = select<u32>(9, 10, value < 1000000000);\r\n      return select<u32>(8, m, value < 100000000);\r\n    }\r\n  }\r\n}\r\n\r\n// Count number of decimals for u64 values\r\n// In our case input value always greater than 2^32-1 so we can skip some parts\r\nexport function decimalCount64(value: u64): u32 {\r\n  if (value < 1000000000000000) {\r\n    if (value < 1000000000000) {\r\n      let m = select<u32>(11, 12, value < 100000000000);\r\n      return select<u32>(10, m, value < 10000000000);\r\n    } else {\r\n      let m = select<u32>(14, 15, value < 100000000000000);\r\n      return select<u32>(13, m, value < 10000000000000);\r\n    }\r\n  } else {\r\n    if (value < 100000000000000000) {\r\n      return select<u32>(16, 17, value < 10000000000000000);\r\n    } else {\r\n      let m = select<u32>(19, 20, value < 10000000000000000000);\r\n      return select<u32>(18, m, value < 1000000000000000000);\r\n    }\r\n  }\r\n}\r\n\r\nfunction utoa32_lut(buffer: usize, num: u32, offset: usize): void {\r\n  var lut = changetype<ArrayBufferView>(DIGITS).dataStart;\r\n  while (num >= 10000) {\r\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\r\n    let t = num / 10000;\r\n    let r = num % 10000;\r\n    num = t;\r\n\r\n    let d1 = r / 100;\r\n    let d2 = r % 100;\r\n\r\n    let digits1 = <u64>load<u32>(lut + (<usize>d1 << alignof<u32>()));\r\n    let digits2 = <u64>load<u32>(lut + (<usize>d2 << alignof<u32>()));\r\n\r\n    offset -= 4;\r\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\r\n  }\r\n\r\n  if (num >= 100) {\r\n    let t  = num / 100;\r\n    let d1 = num % 100;\r\n    num = t;\r\n    offset -= 2;\r\n    let digits = load<u32>(lut + (<usize>d1 << alignof<u32>()));\r\n    store<u32>(buffer + (offset << 1), digits);\r\n  }\r\n\r\n  if (num >= 10) {\r\n    offset -= 2;\r\n    let digits = load<u32>(lut + (<usize>num << alignof<u32>()));\r\n    store<u32>(buffer + (offset << 1), digits);\r\n  } else {\r\n    offset -= 1;\r\n    let digit = CharCode._0 + num;\r\n    store<u16>(buffer + (offset << 1), digit);\r\n  }\r\n}\r\n\r\nfunction utoa64_lut(buffer: usize, num: u64, offset: usize): void {\r\n  var lut = changetype<ArrayBufferView>(DIGITS).dataStart;\r\n  while (num >= 100000000) {\r\n    let t = num / 100000000;\r\n    let r = <usize>(num - t * 100000000);\r\n    num = t;\r\n\r\n    let b = r / 10000;\r\n    let c = r % 10000;\r\n\r\n    let b1 = b / 100;\r\n    let b2 = b % 100;\r\n    let c1 = c / 100;\r\n    let c2 = c % 100;\r\n\r\n    let digits1 = <u64>load<u32>(lut + (<usize>c1 << alignof<u32>()));\r\n    let digits2 = <u64>load<u32>(lut + (<usize>c2 << alignof<u32>()));\r\n\r\n    offset -= 4;\r\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\r\n\r\n    digits1 = <u64>load<u32>(lut + (<usize>b1 << alignof<u32>()));\r\n    digits2 = <u64>load<u32>(lut + (<usize>b2 << alignof<u32>()));\r\n\r\n    offset -= 4;\r\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\r\n  }\r\n\r\n  utoa32_lut(buffer, <u32>num, offset);\r\n}\r\n\r\nfunction utoa_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\r\n  do {\r\n    let t = num / 10;\r\n    let r = <u32>(num % 10);\r\n    num = changetype<T>(t);\r\n    offset -= 1;\r\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\r\n  } while (num);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function utoa32_core(buffer: usize, num: u32, offset: u32): void {\r\n  if (ASC_SHRINK_LEVEL >= 1) {\r\n    utoa_simple(buffer, num, offset);\r\n  } else {\r\n    utoa32_lut(buffer, num, offset);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function utoa64_core(buffer: usize, num: u64, offset: u32): void {\r\n  if (ASC_SHRINK_LEVEL >= 1) {\r\n    utoa_simple(buffer, num, offset);\r\n  } else {\r\n    utoa64_lut(buffer, num, offset);\r\n  }\r\n}\r\n\r\nexport function utoa32(value: u32): String {\r\n  if (!value) return \"0\";\r\n\r\n  var decimals = decimalCount32(value);\r\n  var out = __alloc(decimals << 1, idof<String>());\r\n\r\n  utoa32_core(out, value, decimals);\r\n  return changetype<String>(out); // retains\r\n}\r\n\r\nexport function itoa32(value: i32): String {\r\n  if (!value) return \"0\";\r\n\r\n  var sign = value < 0;\r\n  if (sign) value = -value;\r\n\r\n  var decimals = decimalCount32(value) + u32(sign);\r\n  var out = __alloc(decimals << 1, idof<String>());\r\n\r\n  utoa32_core(out, value, decimals);\r\n  if (sign) store<u16>(out, CharCode.MINUS);\r\n  return changetype<String>(out); // retains\r\n}\r\n\r\nexport function utoa64(value: u64): String {\r\n  if (!value) return \"0\";\r\n\r\n  var out: usize;\r\n  if (value <= u32.MAX_VALUE) {\r\n    let val32    = <u32>value;\r\n    let decimals = decimalCount32(val32);\r\n    out = __alloc(decimals << 1, idof<String>());\r\n    utoa32_core(out, val32, decimals);\r\n  } else {\r\n    let decimals = decimalCount64(value);\r\n    out = __alloc(decimals << 1, idof<String>());\r\n    utoa64_core(out, value, decimals);\r\n  }\r\n  return changetype<String>(out); // retains\r\n}\r\n\r\nexport function itoa64(value: i64): String {\r\n  if (!value) return \"0\";\r\n\r\n  var sign = value < 0;\r\n  if (sign) value = -value;\r\n\r\n  var out: usize;\r\n  if (<u64>value <= <u64>u32.MAX_VALUE) {\r\n    let val32    = <u32>value;\r\n    let decimals = decimalCount32(val32) + u32(sign);\r\n    out = __alloc(decimals << 1, idof<String>());\r\n    utoa32_core(out, val32, decimals);\r\n  } else {\r\n    let decimals = decimalCount64(value) + u32(sign);\r\n    out = __alloc(decimals << 1, idof<String>());\r\n    utoa64_core(out, value, decimals);\r\n  }\r\n  if (sign) store<u16>(out, CharCode.MINUS);\r\n\r\n  return changetype<String>(out); // retains\r\n}\r\n\r\nexport function itoa<T extends number>(value: T): String {\r\n  if (!isInteger<T>()) ERROR(\"integer type expected\");\r\n  if (isSigned<T>()) {\r\n    if (sizeof<T>() <= 4) {\r\n      return itoa32(<i32>value);\r\n    } else {\r\n      return itoa64(<i64>value);\r\n    }\r\n  } else {\r\n    if (sizeof<T>() <= 4) {\r\n      return utoa32(<u32>value);\r\n    } else {\r\n      return utoa64(<u64>value);\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar _K: i32 = 0;\r\n\r\n// // @ts-ignore: decorator\r\n// @lazy\r\n// var _frc: u64 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar _exp: i32 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar _frc_minus: u64 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar _frc_plus:  u64 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar _frc_pow: u64 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar _exp_pow: i32 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction umul64f(u: u64, v: u64): u64 {\r\n  var u0 = u & 0xFFFFFFFF;\r\n  var v0 = v & 0xFFFFFFFF;\r\n\r\n  var u1 = u >> 32;\r\n  var v1 = v >> 32;\r\n\r\n  var l = u0 * v0;\r\n  var t = u1 * v0 + (l >> 32);\r\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\r\n\r\n  w += 0x7FFFFFFF; // rounding\r\n\r\n  t >>= 32;\r\n  w >>= 32;\r\n\r\n  return u1 * v1 + t + w;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction umul64e(e1: i32, e2: i32): i32 {\r\n  return e1 + e2 + 64; // where 64 is significand size\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction normalizedBoundaries(f: u64, e: i32): void {\r\n  var frc = (f << 1) + 1;\r\n  var exp = e - 1;\r\n  var off = <i32>clz<u64>(frc);\r\n  frc <<= off;\r\n  exp  -= off;\r\n\r\n  var m = 1 + i32(f == 0x0010000000000000);\r\n\r\n  _frc_plus  = frc;\r\n  _frc_minus = ((f << m) - 1) << e - m - exp;\r\n  _exp = exp;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\r\n  var lastp = buffer + ((len - 1) << 1);\r\n  var digit = load<u16>(lastp);\r\n  while (\r\n    rest < wp_w &&\r\n    delta - rest >= ten_kappa && (\r\n      rest + ten_kappa < wp_w ||\r\n      wp_w - rest > rest + ten_kappa - wp_w\r\n    )\r\n  ) {\r\n    --digit;\r\n    rest += ten_kappa;\r\n  }\r\n  store<u16>(lastp, digit);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction getCachedPower(minExp: i32): void {\r\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\r\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\r\n  var k = <i32>dk;\r\n      k += i32(k != dk); // conversion with ceil\r\n\r\n  var index = (k >> 3) + 1;\r\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\r\n  _frc_pow = unchecked(FRC_POWERS[index]);\r\n  _exp_pow = unchecked(<i32>EXP_POWERS[index]);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\r\n\r\n  // frexp routine\r\n  var uv  = reinterpret<u64>(value);\r\n  var exp = <i32>((uv & 0x7FF0000000000000) >>> 52);\r\n  var sid = uv & 0x000FFFFFFFFFFFFF;\r\n  var frc = (u64(exp != 0) << 52) + sid;\r\n      exp = select<i32>(exp, 1, exp != 0) - (0x3FF + 52);\r\n\r\n  normalizedBoundaries(frc, exp);\r\n  getCachedPower(_exp);\r\n\r\n  // normalize\r\n  var off = <i32>clz<u64>(frc);\r\n  frc <<= off;\r\n  exp  -= off;\r\n\r\n  var frc_pow = _frc_pow;\r\n  var exp_pow = _exp_pow;\r\n\r\n  var w_frc = umul64f(frc, frc_pow);\r\n  var w_exp = umul64e(exp, exp_pow);\r\n\r\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\r\n  var wp_exp = umul64e(_exp,      exp_pow);\r\n\r\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\r\n  var delta  = wp_frc - wm_frc;\r\n\r\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\r\n}\r\n\r\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\r\n  var one_exp = -mp_exp;\r\n  var one_frc = (<u64>1) << one_exp;\r\n  var mask    = one_frc - 1;\r\n\r\n  var wp_w_frc = mp_frc - w_frc;\r\n  var wp_w_exp = mp_exp;\r\n\r\n  var p1 = <u32>(mp_frc >> one_exp);\r\n  var p2 = mp_frc & mask;\r\n\r\n  var kappa = <i32>decimalCount32(p1);\r\n  var len = sign;\r\n\r\n  var lut = changetype<ArrayBufferView>(POWERS10).dataStart;\r\n\r\n  while (kappa > 0) {\r\n    let d: u32;\r\n    switch (kappa) {\r\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\r\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\r\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\r\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\r\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\r\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\r\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\r\n      case  3: { d = p1 /        100; p1 %=        100; break; }\r\n      case  2: { d = p1 /         10; p1 %=         10; break; }\r\n      case  1: { d = p1;              p1 =           0; break; }\r\n      default: { d = 0; break; }\r\n    }\r\n\r\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\r\n\r\n    --kappa;\r\n    let tmp = ((<u64>p1) << one_exp) + p2;\r\n    if (tmp <= delta) {\r\n      _K += kappa;\r\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(lut + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\r\n      return len;\r\n    }\r\n  }\r\n\r\n  while (1) {\r\n    p2    *= 10;\r\n    delta *= 10;\r\n\r\n    let d = p2 >> one_exp;\r\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\r\n\r\n    p2 &= mask;\r\n    --kappa;\r\n    if (p2 < delta) {\r\n      _K += kappa;\r\n      wp_w_frc *= <u64>load<u32>(lut + (<usize>-kappa << alignof<u32>()));\r\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\r\n      return len;\r\n    }\r\n  }\r\n\r\n  return len;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction genExponent(buffer: usize, k: i32): i32 {\r\n  var sign = k < 0;\r\n  if (sign) k = -k;\r\n  var decimals = decimalCount32(k) + 1;\r\n  utoa32_core(buffer, k, decimals);\r\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\r\n  return decimals;\r\n}\r\n\r\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\r\n  if (!k) {\r\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\r\n    return length + 2;\r\n  }\r\n\r\n  var kk = length + k;\r\n  if (length <= kk && kk <= 21) {\r\n    // 1234e7 -> 12340000000\r\n    for (let i = length; i < kk; ++i) {\r\n      store<u16>(buffer + (i << 1), CharCode._0);\r\n    }\r\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\r\n    return kk + 2;\r\n  } else if (kk > 0 && kk <= 21) {\r\n    // 1234e-2 -> 12.34\r\n    let ptr = buffer + (kk << 1);\r\n    memory.copy(\r\n      ptr + 2,\r\n      ptr,\r\n      -k << 1\r\n    );\r\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\r\n    return length + 1;\r\n  } else if (-6 < kk && kk <= 0) {\r\n    // 1234e-6 -> 0.001234\r\n    let offset = 2 - kk;\r\n    memory.copy(\r\n      buffer + (offset << 1),\r\n      buffer,\r\n      length << 1\r\n    );\r\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\r\n    for (let i = 2; i < offset; ++i) {\r\n      store<u16>(buffer + (i << 1), CharCode._0);\r\n    }\r\n    return length + offset;\r\n  } else if (length == 1) {\r\n    // 1e30\r\n    store<u16>(buffer, CharCode.e, 2);\r\n    length = genExponent(buffer + 4, kk - 1);\r\n    return length + 2;\r\n  } else {\r\n    let len = length << 1;\r\n    memory.copy(\r\n      buffer + 4,\r\n      buffer + 2,\r\n      len - 2\r\n    );\r\n    store<u16>(buffer,       CharCode.DOT, 2);\r\n    store<u16>(buffer + len, CharCode.e,   2);\r\n    length += genExponent(buffer + len + 4, kk - 1);\r\n    return length + 2;\r\n  }\r\n}\r\n\r\nexport function dtoa_core(buffer: usize, value: f64): i32 {\r\n  var sign = i32(value < 0);\r\n  if (sign) {\r\n    value = -value;\r\n    store<u16>(buffer, CharCode.MINUS);\r\n  }\r\n  // assert(value > 0 && value <= 1.7976931348623157e308);\r\n  var len = grisu2(value, buffer, sign);\r\n      len = prettify(buffer + (sign << 1), len - sign, _K);\r\n  return len + sign;\r\n}\r\n\r\nexport function dtoa(value: f64): String {\r\n  if (value == 0) return \"0.0\";\r\n  if (!isFinite<f64>(value)) {\r\n    if (isNaN<f64>(value)) return \"NaN\";\r\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\r\n  }\r\n  var buffer = __alloc(MAX_DOUBLE_LENGTH << 1, idof<String>());\r\n  var length = dtoa_core(buffer, value);\r\n  if (length == MAX_DOUBLE_LENGTH) return changetype<String>(buffer);\r\n  var result = changetype<String>(buffer).substring(0, length);\r\n  __free(buffer);\r\n  return result;\r\n}\r\n\r\nexport function itoa_stream<T extends number>(buffer: usize, offset: usize, value: T): u32 {\r\n  buffer += (offset << 1);\r\n  if (!value) {\r\n    store<u16>(buffer, CharCode._0);\r\n    return 1;\r\n  }\r\n  var decimals: u32 = 0;\r\n  if (isSigned<T>()) {\r\n    let sign = i32(value < 0);\r\n    if (sign) value = changetype<T>(-value);\r\n    if (sizeof<T>() <= 4) {\r\n      decimals = decimalCount32(value) + <u32>sign;\r\n      utoa32_core(buffer, value, decimals);\r\n    } else {\r\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\r\n        let val32 = <u32>value;\r\n        decimals = decimalCount32(val32) + <u32>sign;\r\n        utoa32_core(buffer, val32, decimals);\r\n      } else {\r\n        decimals = decimalCount64(value) + <u32>sign;\r\n        utoa64_core(buffer, value, decimals);\r\n      }\r\n    }\r\n    if (sign) store<u16>(buffer, CharCode.MINUS);\r\n  } else {\r\n    if (sizeof<T>() <= 4) {\r\n      decimals = decimalCount32(value);\r\n      utoa32_core(buffer, value, decimals);\r\n    } else {\r\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\r\n        let val32 = <u32>value;\r\n        decimals = decimalCount32(val32);\r\n        utoa32_core(buffer, val32, decimals);\r\n      } else {\r\n        decimals = decimalCount64(value);\r\n        utoa64_core(buffer, value, decimals);\r\n      }\r\n    }\r\n  }\r\n  return decimals;\r\n}\r\n\r\nexport function dtoa_stream(buffer: usize, offset: usize, value: f64): u32 {\r\n  buffer += (offset << 1);\r\n  if (value == 0.0) {\r\n    store<u16>(buffer, CharCode._0);\r\n    store<u16>(buffer, CharCode.DOT, 2);\r\n    store<u16>(buffer, CharCode._0,  4);\r\n    return 3;\r\n  }\r\n  if (!isFinite<f64>(value)) {\r\n    if (isNaN<f64>(value)) {\r\n      store<u16>(buffer, CharCode.N);\r\n      store<u16>(buffer, CharCode.a, 2);\r\n      store<u16>(buffer, CharCode.N, 4);\r\n      return 3;\r\n    } else {\r\n      let sign = i32(value < 0);\r\n      let len  = 8 + sign;\r\n      memory.copy(buffer, changetype<usize>(select<String>(\"-Infinity\", \"Infinity\", sign)), len << 1);\r\n      return len;\r\n    }\r\n  }\r\n  return dtoa_core(buffer, value);\r\n}\r\n","import { itoa, dtoa, itoa_stream, dtoa_stream, MAX_DOUBLE_LENGTH } from \"./number\";\r\nimport { ipow32 } from \"../math\";\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport const enum CharCode {\r\n  PLUS = 0x2B,\r\n  MINUS = 0x2D,\r\n  DOT = 0x2E,\r\n  _0 = 0x30,\r\n  _1 = 0x31,\r\n  _2 = 0x32,\r\n  _3 = 0x33,\r\n  _4 = 0x34,\r\n  _5 = 0x35,\r\n  _6 = 0x36,\r\n  _7 = 0x37,\r\n  _8 = 0x38,\r\n  _9 = 0x39,\r\n  A = 0x41,\r\n  B = 0x42,\r\n  E = 0x45,\r\n  I = 0x49,\r\n  N = 0x4E,\r\n  O = 0x4F,\r\n  X = 0x58,\r\n  Z = 0x5A,\r\n  a = 0x61,\r\n  b = 0x62,\r\n  e = 0x65,\r\n  n = 0x6E,\r\n  o = 0x6F,\r\n  x = 0x78,\r\n  z = 0x7A\r\n}\r\n\r\n// 9 * 8 = 72 bytes\r\n// @ts-ignore: decorator\r\n@lazy\r\nconst Powers10Hi: f64[] = [1, 1e32, 1e64, 1e96, 1e128, 1e160, 1e192, 1e224, 1e256, 1e288];\r\n// 32 * 8 = 256 bytes\r\n// @ts-ignore: decorator\r\n@lazy\r\nconst Powers10Lo: f64[] = [\r\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\r\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\r\n  1e20, 1e21, 1e22, 1e23, 1e24, 1e25, 1e26, 1e27, 1e28, 1e29,\r\n  1e30, 1e31\r\n];\r\n\r\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\r\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\r\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\r\n  if (ASC_SHRINK_LEVEL < 2) {\r\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\r\n      do {\r\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\r\n        ptr1 += 8;\r\n        ptr2 += 8;\r\n        len  -= 4;\r\n      } while (len >= 4);\r\n    }\r\n  }\r\n  while (len--) {\r\n    let a = <i32>load<u16>(ptr1);\r\n    let b = <i32>load<u16>(ptr2);\r\n    if (a != b) return a - b;\r\n    ptr1 += 2;\r\n    ptr2 += 2;\r\n  }\r\n  return 0;\r\n}\r\n\r\nexport function isSpace(c: i32): bool {\r\n  if (c <= 0xFF) {\r\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\r\n    return c == 0x20 || <u32>(c - 0x09) <= 0x0D - 0x09 || c == 0xA0;\r\n  }\r\n  if (<u32>(c - 0x2000) <= 0x200A - 0x2000) return true;\r\n  switch (c) {\r\n    case 0x1680: // <LS> (1)\r\n    case 0x2028: // <LS> (2)\r\n    case 0x2029: // <PS>\r\n    case 0x202F: // <NNS>\r\n    case 0x205F: // <MMSP>\r\n    case 0x3000: // <IS>\r\n    case 0xFEFF: return true; // <ZWNBSP>\r\n  }\r\n  return false;\r\n}\r\n\r\n/** Parses a string to an integer (usually), using the specified radix. */\r\nexport function strtol<T>(str: string, radix: i32 = 0): T {\r\n  var len = str.length;\r\n  if (!len) {\r\n    // @ts-ignore: cast\r\n    if (isFloat<T>()) return <T>NaN;\r\n    // @ts-ignore: cast\r\n    return <T>0;\r\n  }\r\n\r\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\r\n  var code = <u32>load<u16>(ptr);\r\n\r\n  // determine sign\r\n  // @ts-ignore: cast\r\n  var sign: T = 1;\r\n  // trim white spaces\r\n  while (isSpace(code)) {\r\n    code = <u32>load<u16>(ptr += 2);\r\n    --len;\r\n  }\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) {\r\n      // @ts-ignore: cast\r\n      if (isFloat<T>()) return <T>NaN;\r\n      // @ts-ignore: cast\r\n      return <T>0;\r\n    }\r\n    code = <u32>load<u16>(ptr += 2);\r\n    // @ts-ignore: type\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) {\r\n      // @ts-ignore: cast\r\n      if (isFloat<T>()) return <T>NaN;\r\n      // @ts-ignore: cast\r\n      return <T>0;\r\n    }\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n\r\n  // determine radix\r\n  if (!radix) {\r\n    if (code == CharCode._0 && len > 2) {\r\n      switch (<u32>load<u16>(ptr + 2) | 32) {\r\n        case CharCode.b: {\r\n          ptr += 4; len -= 2;\r\n          radix = 2;\r\n          break;\r\n        }\r\n        case CharCode.o: {\r\n          ptr += 4; len -= 2;\r\n          radix = 8;\r\n          break;\r\n        }\r\n        case CharCode.x: {\r\n          ptr += 4; len -= 2;\r\n          radix = 16;\r\n          break;\r\n        }\r\n        default: radix = 10;\r\n      }\r\n    } else radix = 10;\r\n  } else if (radix < 2 || radix > 36) {\r\n    // @ts-ignore: cast\r\n    if (isFloat<T>()) return <T>NaN;\r\n    // @ts-ignore: cast\r\n    return <T>0;\r\n  }\r\n\r\n  // calculate value\r\n  // @ts-ignore: type\r\n  var num: T = 0;\r\n  while (len--) {\r\n    code = <u32>load<u16>(ptr);\r\n    if (code - CharCode._0 < 10) {\r\n      code -= CharCode._0;\r\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\r\n      code -= CharCode.A - 10;\r\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\r\n      code -= CharCode.a - 10;\r\n    } else break;\r\n    if (code >= <u32>radix) break;\r\n    // @ts-ignore: type\r\n    num = num * radix + code;\r\n    ptr += 2;\r\n  }\r\n  // @ts-ignore: type\r\n  return sign * num;\r\n}\r\n\r\nexport function strtod(str: string): f64 {\r\n  var len = str.length;\r\n  if (!len) return NaN;\r\n\r\n  var ptr  = changetype<usize>(str);\r\n  var code = <u32>load<u16>(ptr);\r\n\r\n  var sign = 1.;\r\n  // skip white spaces\r\n  while (len && isSpace(code)) {\r\n    code = <u32>load<u16>(ptr += 2);\r\n    --len;\r\n  }\r\n  if (!len) return NaN;\r\n\r\n  // try parse '-' or '+'\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) return NaN;\r\n    code = <u32>load<u16>(ptr += 2);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) return NaN;\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n\r\n  // try parse Infinity\r\n  if (len >= 8 && code == CharCode.I) {\r\n    if (\r\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\r\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\r\n    ) {\r\n      return copysign<f64>(Infinity, sign);\r\n    }\r\n    return NaN;\r\n  }\r\n  // validate next symbol\r\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\r\n    return NaN;\r\n  }\r\n  var savedPtr = ptr;\r\n  // skip zeros\r\n  while (code == CharCode._0) {\r\n    code = <u32>load<u16>(ptr += 2);\r\n    --len;\r\n  }\r\n  if (len <= 0) return 0;\r\n  const capacity = 19; // int(64 * 0.3010)\r\n  var pointed = false;\r\n  var consumed = 0;\r\n  var position = 0;\r\n  var x: u64 = 0;\r\n  if (code == CharCode.DOT) {\r\n    let noDigits = !(savedPtr - ptr);\r\n    ptr += 2; --len;\r\n    if (!len && noDigits) return NaN;\r\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\r\n    if (len <= 0) return 0;\r\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\r\n  }\r\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\r\n    if (digit < 10) {\r\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\r\n      ++consumed;\r\n    } else {\r\n      position = consumed;\r\n      pointed = true;\r\n    }\r\n    if (!--len) break;\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n\r\n  if (!pointed) position = consumed;\r\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\r\n}\r\n\r\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\r\n\r\n  var sepLen = separator.length;\r\n  var valueLen = 5; // max possible length of element len(\"false\")\r\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\r\n  var offset = 0;\r\n  var value: bool;\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<bool>(dataStart + i);\r\n    valueLen = 4 + i32(!value);\r\n    memory.copy(\r\n      changetype<usize>(result) + (<usize>offset << 1),\r\n      changetype<usize>(select(\"true\", \"false\", value)),\r\n      <usize>valueLen << 1\r\n    );\r\n    offset += valueLen;\r\n    if (sepLen) {\r\n      memory.copy(\r\n        changetype<usize>(result) + (<usize>offset << 1),\r\n        changetype<usize>(separator),\r\n        <usize>sepLen << 1\r\n      );\r\n      offset += sepLen;\r\n    }\r\n  }\r\n  value = load<bool>(dataStart + <usize>lastIndex);\r\n  valueLen = 4 + i32(!value);\r\n  memory.copy(\r\n    changetype<usize>(result) + (<usize>offset << 1),\r\n    changetype<usize>(select(\"true\", \"false\", value)),\r\n    valueLen << 1\r\n  );\r\n  offset += valueLen;\r\n\r\n  if (estLen > offset) return result.substring(0, offset);\r\n  return result;\r\n}\r\n\r\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  // @ts-ignore: type\r\n  if (!lastIndex) return changetype<string>(itoa<T>(load<T>(dataStart))); // retains\r\n\r\n  var sepLen = separator.length;\r\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\r\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\r\n  var offset = 0;\r\n  var value: T;\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\r\n    // @ts-ignore: type\r\n    offset += itoa_stream<T>(changetype<usize>(result), offset, value);\r\n    if (sepLen) {\r\n      memory.copy(\r\n        changetype<usize>(result) + (<usize>offset << 1),\r\n        changetype<usize>(separator),\r\n        <usize>sepLen << 1\r\n      );\r\n      offset += sepLen;\r\n    }\r\n  }\r\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\r\n  // @ts-ignore: type\r\n  offset += itoa_stream<T>(changetype<usize>(result), offset, value);\r\n  if (estLen > offset) return result.substring(0, offset);\r\n  return result;\r\n}\r\n\r\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  if (!lastIndex) {\r\n    return changetype<string>(dtoa(\r\n      // @ts-ignore: type\r\n      load<T>(dataStart))\r\n    ); // retains\r\n  }\r\n\r\n  const valueLen = MAX_DOUBLE_LENGTH;\r\n  var sepLen = separator.length;\r\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\r\n  var offset = 0;\r\n  var value: T;\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\r\n    offset += dtoa_stream(changetype<usize>(result), offset,\r\n      // @ts-ignore: type\r\n      value\r\n    );\r\n    if (sepLen) {\r\n      memory.copy(\r\n        changetype<usize>(result) + (<usize>offset << 1),\r\n        changetype<usize>(separator),\r\n        <usize>sepLen << 1\r\n      );\r\n      offset += sepLen;\r\n    }\r\n  }\r\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\r\n  offset += dtoa_stream(changetype<usize>(result), offset,\r\n    // @ts-ignore: type\r\n    value\r\n  );\r\n  if (estLen > offset) return result.substring(0, offset);\r\n  return result;\r\n}\r\n\r\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  if (!lastIndex) {\r\n    // @ts-ignore: type\r\n    return load<string>(dataStart) || \"\";\r\n  }\r\n  var estLen = 0;\r\n  var value: string;\r\n  for (let i = 0; i < length; ++i) {\r\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\r\n    // @ts-ignore: type\r\n    if (value !== null) estLen += value.length;\r\n  }\r\n  var offset = 0;\r\n  var sepLen = separator.length;\r\n  var result = __alloc((estLen + sepLen * lastIndex) << 1, idof<string>());\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\r\n    if (value !== null) {\r\n      let valueLen = value.length;\r\n      memory.copy(\r\n        result + (<usize>offset << 1),\r\n        changetype<usize>(value),\r\n        <usize>valueLen << 1\r\n      );\r\n      offset += valueLen;\r\n    }\r\n    if (sepLen) {\r\n      memory.copy(\r\n        result + (<usize>offset << 1),\r\n        changetype<usize>(separator),\r\n        <usize>sepLen << 1\r\n      );\r\n      offset += sepLen;\r\n    }\r\n  }\r\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\r\n  if (value !== null) {\r\n    memory.copy(\r\n      result + (<usize>offset << 1),\r\n      changetype<usize>(value),\r\n      <usize>value.length << 1\r\n    );\r\n  }\r\n  return changetype<string>(result); // retains\r\n}\r\n\r\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  var value: T;\r\n  if (!lastIndex) {\r\n    value = load<T>(dataStart);\r\n    // @ts-ignore: type\r\n    return value !== null ? value.toString() : \"\";\r\n  }\r\n  var result = \"\";\r\n  var sepLen = separator.length;\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\r\n    // @ts-ignore: type\r\n    if (value !== null) result += value.toString();\r\n    if (sepLen) result += separator;\r\n  }\r\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\r\n  // @ts-ignore: type\r\n  if (value !== null) result += value.toString();\r\n  return result;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction scientific(significand: u64, exp: i32): f64 {\r\n  if (!significand || exp < -342) return 0;\r\n  if (exp > 308) return Infinity;\r\n  // Try use fast path\r\n  // Use fast path for string-to-double conversion if possible\r\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\r\n  // Simple integer\r\n  var significandf = <f64>significand;\r\n  if (!exp) return significandf;\r\n  if (exp > 22 && exp <= 22 + 15) {\r\n    significandf *= pow10(exp - 22);\r\n    exp = 22;\r\n  }\r\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\r\n    if (exp > 0) return significandf * pow10(exp);\r\n    return significandf / pow10(-exp);\r\n  } else if (exp < 0) {\r\n    return scaledown(significand, exp);\r\n  } else {\r\n    return scaleup(significand, exp);\r\n  }\r\n}\r\n\r\n// Adopted from metallic lib:\r\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction scaledown(significand: u64, exp: i32): f64 {\r\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\r\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\r\n\r\n  var shift = clz(significand);\r\n  significand <<= shift;\r\n  shift = exp - shift;\r\n\r\n  for (; exp <= -14; exp += 14) {\r\n    let q = significand / denom;\r\n    let r = significand % denom;\r\n    let s = clz(q);\r\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\r\n    shift -= s;\r\n  }\r\n  var b = <u64>ipow32(5, -exp);\r\n  var q = significand / b;\r\n  var r = significand % b;\r\n  var s = clz(q);\r\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\r\n  shift -= s;\r\n\r\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\r\n}\r\n\r\n// Adopted from metallic lib:\r\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction scaleup(significand: u64, exp: i32): f64 {\r\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\r\n  var shift = ctz(significand);\r\n  significand >>= shift;\r\n  shift += exp;\r\n\r\n  __fixmulShift = shift;\r\n  for (; exp >= 13; exp -= 13) {\r\n    significand = fixmul(significand, coeff);\r\n  }\r\n  significand = fixmul(significand, <u32>ipow32(5, exp));\r\n  shift = __fixmulShift;\r\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\r\n}\r\n\r\n// Adopted from metallic lib:\r\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction parseExp(ptr: usize, len: i32): i32 {\r\n  var sign = 1, magnitude = 0;\r\n  var code = <u32>load<u16>(ptr);\r\n  // check code is 'e' or 'E'\r\n  if ((code | 32) != CharCode.e) return 0;\r\n\r\n  code = <u32>load<u16>(ptr += 2);\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) return 0;\r\n    code = <u32>load<u16>(ptr += 2);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) return 0;\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n  // skip zeros\r\n  while (code == CharCode._0) {\r\n    if (!--len) return 0;\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\r\n    if (magnitude >= 3200) return sign * 3200;\r\n    magnitude = 10 * magnitude + digit;\r\n    code = <u32>load<u16>(ptr += 2);\r\n    --len;\r\n  }\r\n  return sign * magnitude;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar __fixmulShift: u64 = 0;\r\n\r\n// Adopted from metallic lib:\r\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction fixmul(a: u64, b: u32): u64 {\r\n  var low  = (a & 0xFFFFFFFF) * b;\r\n  var high = (a >> 32) * b + (low >> 32);\r\n  var overflow = <u32>(high >> 32);\r\n  var space = clz(overflow);\r\n  var revspace: u64 = 32 - space;\r\n  __fixmulShift += revspace;\r\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\r\n}\r\n\r\n// @ts-ignore: decorator\r\nfunction pow10(n: i32): f64 {\r\n  // @ts-ignore: type\r\n  const hi = Powers10Hi.dataStart;\r\n  // @ts-ignore: type\r\n  const lo = Powers10Lo.dataStart;\r\n  return (\r\n    load<f64>(hi + ((n >> 5) << alignof<f64>())) *\r\n    load<f64>(lo + ((n & 31) << alignof<f64>()))\r\n  );\r\n}\r\n","import { COMPARATOR, SORT as SORT_IMPL } from \"./util/sort\";\r\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from \"./util/error\";\r\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\r\nimport { idof } from \"./builtins\";\r\nimport { ArrayBufferView } from \"./arraybuffer\";\r\n\r\nexport class Int8Array extends ArrayBufferView {\r\n  [key: number]: i8;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i8>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<i8>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength;\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): i8 {\r\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<i8>(this.dataStart + <usize>index);\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): i8 {\r\n    return load<i8>(this.dataStart + <usize>index);\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: native<i8>): void {\r\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<i8>(this.dataStart + <usize>index, value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: native<i8>): void {\r\n    store<i8>(this.dataStart + <usize>index, value);\r\n  }\r\n\r\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\r\n    return FILL<Int8Array, i8>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\r\n    return SORT<Int8Array, i8>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\r\n    return SLICE<Int8Array, i8>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\r\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\r\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\r\n    return MAP<Int8Array, i8>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\r\n    return FILTER<Int8Array, i8>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\r\n    return FIND_INDEX<Int8Array, i8>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\r\n    return SOME<Int8Array, i8>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\r\n    return EVERY<Int8Array, i8>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\r\n    FOREACH<Int8Array, i8>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, i8>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\r\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Uint8Array extends ArrayBufferView {\r\n  [key: number]: u8;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<u8>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength;\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): u8 {\r\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<u8>(this.dataStart + <usize>index);\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): u8 {\r\n    return load<u8>(this.dataStart + <usize>index);\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: native<u8>): void {\r\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<u8>(this.dataStart + <usize>index, value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: native<u8>): void {\r\n    store<u8>(this.dataStart + <usize>index, value);\r\n  }\r\n\r\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\r\n    return FILL<Uint8Array, u8>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\r\n    return SORT<Uint8Array, u8>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\r\n    return SLICE<Uint8Array, u8>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\r\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\r\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\r\n    return MAP<Uint8Array, u8>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\r\n    return FILTER<Uint8Array, u8>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\r\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\r\n    return SOME<Uint8Array, u8>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\r\n    return EVERY<Uint8Array, u8>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\r\n    FOREACH<Uint8Array, u8>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u8>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\r\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Uint8ClampedArray extends ArrayBufferView {\r\n  [key: number]: u8;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<u8>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength;\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): u8 {\r\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<u8>(this.dataStart + <usize>index);\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): u8 {\r\n    return load<u8>(this.dataStart + <usize>index);\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: native<u8>): void {\r\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: native<u8>): void {\r\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\r\n  }\r\n\r\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\r\n    return FILL<Uint8ClampedArray, u8>(this, value, start, end);\r\n  }\r\n\r\n  sort(fn: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\r\n    return SORT<Uint8ClampedArray, u8>(this, fn);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\r\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\r\n  }\r\n\r\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\r\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\r\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\r\n    return MAP<Uint8ClampedArray, u8>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\r\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\r\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\r\n    return SOME<Uint8ClampedArray, u8>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\r\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\r\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u8>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\r\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Int16Array extends ArrayBufferView {\r\n  [key: number]: i16;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i16>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<i16>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<i16>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): i16 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): i16 {\r\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: native<i16>): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: native<i16>): void {\r\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\r\n  }\r\n\r\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\r\n    return FILL<Int16Array, i16>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\r\n    return SORT<Int16Array, i16>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\r\n    return SLICE<Int16Array, i16>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\r\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\r\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\r\n    return MAP<Int16Array, i16>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\r\n    return FILTER<Int16Array, i16>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\r\n    return FIND_INDEX<Int16Array, i16>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\r\n    return SOME<Int16Array, i16>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\r\n    return EVERY<Int16Array, i16>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\r\n    FOREACH<Int16Array, i16>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, i16>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\r\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Uint16Array extends ArrayBufferView {\r\n  [key: number]: u16;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u16>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<u16>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<u16>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): u16 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): u16 {\r\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: native<u16>): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: native<u16>): void {\r\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\r\n  }\r\n\r\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\r\n    return FILL<Uint16Array, u16>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\r\n    return SORT<Uint16Array, u16>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\r\n    return SLICE<Uint16Array, u16>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\r\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\r\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\r\n    return MAP<Uint16Array, u16>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\r\n    return FILTER<Uint16Array, u16>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\r\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\r\n    return SOME<Uint16Array, u16>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\r\n    return EVERY<Uint16Array, u16>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\r\n    FOREACH<Uint16Array, u16>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u16>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\r\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Int32Array extends ArrayBufferView {\r\n  [key: number]: i32;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i32>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<i32>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<i32>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): i32 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): i32 {\r\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: i32): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: i32): void {\r\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\r\n  }\r\n\r\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\r\n    return FILL<Int32Array, i32>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\r\n    return SORT<Int32Array, i32>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\r\n    return SLICE<Int32Array, i32>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\r\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\r\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\r\n    return MAP<Int32Array, i32>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\r\n    return FILTER<Int32Array, i32>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\r\n    return FIND_INDEX<Int32Array, i32>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\r\n    return SOME<Int32Array, i32>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\r\n    return EVERY<Int32Array, i32>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\r\n    FOREACH<Int32Array, i32>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, i32>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\r\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Uint32Array extends ArrayBufferView {\r\n  [key: number]: u32;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u32>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<u32>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<u32>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): u32 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): u32 {\r\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: u32): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: u32): void {\r\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\r\n  }\r\n\r\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\r\n    return FILL<Uint32Array, u32>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\r\n    return SORT<Uint32Array, u32>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\r\n    return SLICE<Uint32Array, u32>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\r\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\r\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\r\n    return MAP<Uint32Array, u32>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\r\n    return FILTER<Uint32Array, u32>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\r\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\r\n    return SOME<Uint32Array, u32>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\r\n    return EVERY<Uint32Array, u32>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\r\n    FOREACH<Uint32Array, u32>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u32>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\r\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Int64Array extends ArrayBufferView {\r\n  [key: number]: i64;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i64>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<i64>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<i64>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): i64 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): i64 {\r\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: i64): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: i64): void {\r\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\r\n  }\r\n\r\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\r\n    return FILL<Int64Array, i64>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\r\n    return SORT<Int64Array, i64>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\r\n    return SLICE<Int64Array, i64>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\r\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\r\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\r\n    return MAP<Int64Array, i64>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\r\n    return FILTER<Int64Array, i64>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\r\n    return FIND_INDEX<Int64Array, i64>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\r\n    return SOME<Int64Array, i64>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\r\n    return EVERY<Int64Array, i64>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\r\n    FOREACH<Int64Array, i64>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, i64>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\r\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Uint64Array extends ArrayBufferView {\r\n  [key: number]: u64;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u64>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<u64>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<u64>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): u64 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): u64 {\r\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: u64): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: u64): void {\r\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\r\n  }\r\n\r\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\r\n    return FILL<Uint64Array, u64>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\r\n    return SORT<Uint64Array, u64>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\r\n    return SLICE<Uint64Array, u64>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\r\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\r\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\r\n    return MAP<Uint64Array, u64>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\r\n    return FILTER<Uint64Array, u64>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\r\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\r\n    return SOME<Uint64Array, u64>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\r\n    return EVERY<Uint64Array, u64>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\r\n    FOREACH<Uint64Array, u64>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u64>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\r\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Float32Array extends ArrayBufferView {\r\n  [key: number]: f32;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<f32>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<f32>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<f32>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): f32 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): f32 {\r\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: f32): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: f32): void {\r\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\r\n  }\r\n\r\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\r\n    return FILL<Float32Array, f32>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\r\n    return SORT<Float32Array, f32>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\r\n    return SLICE<Float32Array, f32>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\r\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\r\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\r\n    return MAP<Float32Array, f32>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\r\n    return FILTER<Float32Array, f32>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\r\n    return FIND_INDEX<Float32Array, f32>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\r\n    return SOME<Float32Array, f32>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\r\n    return EVERY<Float32Array, f32>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\r\n    FOREACH<Float32Array, f32>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, f32>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\r\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Float64Array extends ArrayBufferView {\r\n  [key: number]: f64;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<f64>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<f64>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<f64>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): f64 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): f64 {\r\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: f64): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: f64): void {\r\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\r\n  }\r\n\r\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\r\n    return FILL<Float64Array, f64>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\r\n    return SORT<Float64Array, f64>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\r\n    return SLICE<Float64Array, f64>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\r\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\r\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\r\n    return MAP<Float64Array, f64>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\r\n    return FILTER<Float64Array, f64>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\r\n    return FIND_INDEX<Float64Array, f64>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\r\n    return SOME<Float64Array, f64>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\r\n    return EVERY<Float64Array, f64>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\r\n    FOREACH<Float64Array, f64>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, f64>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\r\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction FILL<TArray extends ArrayBufferView, T extends number>(\r\n  array: TArray,\r\n  value: native<T>,\r\n  start: i32,\r\n  end: i32\r\n): TArray {\r\n  var dataStart = array.dataStart;\r\n  var len = array.length;\r\n  start = start < 0 ? max(len + start, 0) : min(start, len);\r\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\r\n  if (sizeof<T>() == 1) {\r\n    if (start < end) memory.fill(dataStart + <usize>start, <u8>value, <usize>(end - start));\r\n  } else {\r\n    for (; start < end; ++start) {\r\n      store<T>(dataStart + (<usize>start << alignof<T>()), value);\r\n    }\r\n  }\r\n  return array;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction SORT<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  comparator: (a: T, b: T) => i32\r\n): TArray {\r\n  var len = array.length;\r\n  if (len <= 1) return array;\r\n  var base = array.dataStart;\r\n  if (len == 2) {\r\n    let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\r\n    let b: T = load<T>(base); // b = arr[0]\r\n    if (comparator(a, b) < 0) {\r\n      store<T>(base, b, sizeof<T>()); // arr[1] = b\r\n      store<T>(base, a); // arr[0] = a\r\n    }\r\n    return array;\r\n  }\r\n  SORT_IMPL<T>(base, len, comparator);\r\n  return array;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction SLICE<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  start: i32,\r\n  end: i32\r\n): TArray {\r\n  var len = array.length;\r\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\r\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\r\n  len = max(end - start, 0);\r\n  var slice = instantiate<TArray>(len);\r\n  memory.copy(\r\n    slice.dataStart,\r\n    array.dataStart + (<usize>start << alignof<T>()),\r\n    <usize>len << alignof<T>()\r\n  );\r\n  return slice;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction SUBARRAY<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  begin: i32,\r\n  end: i32\r\n): TArray {\r\n  var len = array.length;\r\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\r\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\r\n  end   = max(end, begin);\r\n\r\n  var out = __alloc(offsetof<TArray>(), idof<TArray>());\r\n  store<usize>(out, __retain(changetype<usize>(array.buffer)), offsetof<TArray>(\"buffer\"));\r\n  store<usize>(out, array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\r\n  store<u32>(out, (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\r\n  return changetype<TArray>(out); // retains\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  target: i32,\r\n  start: i32,\r\n  end: i32\r\n): TArray {\r\n  var len = array.length;\r\n  var dataStart = array.dataStart;\r\n\r\n      end   = min<i32>(end, len);\r\n  var to    = target < 0 ? max(len + target, 0) : min(target, len);\r\n  var from  = start < 0 ? max(len + start, 0) : min(start, len);\r\n  var last  = end < 0 ? max(len + end, 0) : min(end, len);\r\n  var count = min(last - from, len - to);\r\n\r\n  memory.copy(\r\n    dataStart + (<usize>to << alignof<T>()),\r\n    dataStart + (<usize>from << alignof<T>()),\r\n    <usize>count << alignof<T>()\r\n  );\r\n  return array;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction REDUCE<TArray extends ArrayBufferView, T, TRet>(\r\n  array: TArray,\r\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\r\n  initialValue: TRet\r\n): TRet {\r\n  var dataStart = array.dataStart;\r\n  for (let i = 0, k = array.length; i < k; i++) {\r\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\r\n  }\r\n  return initialValue;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T, TRet>(\r\n  array: TArray,\r\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\r\n  initialValue: TRet\r\n): TRet {\r\n  var dataStart = array.dataStart;\r\n  for (let i = array.length - 1; i >= 0; i--) {\r\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\r\n  }\r\n  return initialValue;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction MAP<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  fn: (value: T, index: i32, self: TArray) => T,\r\n): TArray {\r\n  var len = array.length;\r\n  var dataStart = array.dataStart;\r\n\r\n  var byteLength = len << alignof<T>();\r\n  var out = __alloc(offsetof<TArray>(), idof<TArray>());\r\n  var buffer = __alloc(byteLength, idof<ArrayBuffer>());\r\n  for (let i = 0; i < len; i++) {\r\n    store<T>(\r\n      buffer + (<usize>i << alignof<T>()),\r\n      fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)\r\n    );\r\n  }\r\n  store<usize>(out, __retain(buffer), offsetof<TArray>(\"buffer\"));\r\n  store<usize>(out, buffer, offsetof<TArray>(\"dataStart\"));\r\n  store<u32>(out, byteLength, offsetof<TArray>(\"byteLength\"));\r\n  return changetype<TArray>(out); // retains\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction FILTER<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  fn: (value: T, index: i32, self: TArray) => bool,\r\n): TArray {\r\n  var len = array.length;\r\n  var out = __alloc(offsetof<TArray>(), idof<TArray>());\r\n  var buffer = __alloc(len << alignof<T>(), idof<ArrayBuffer>());\r\n  var dataStart  = array.dataStart;\r\n  var j: usize = 0;\r\n  for (let i = 0; i < len; i++) {\r\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\r\n    if (fn(value, i, array)) {\r\n      store<T>(\r\n        buffer + (j++ << alignof<T>()),\r\n        value\r\n      );\r\n    }\r\n  }\r\n  // shrink output buffer\r\n  var byteLength = j << alignof<T>();\r\n  var data = __realloc(buffer, byteLength);\r\n  store<usize>(out, __retain(data), offsetof<TArray>(\"buffer\"));\r\n  store<u32>(out, byteLength, offsetof<TArray>(\"byteLength\"));\r\n  store<usize>(out, data, offsetof<TArray>(\"dataStart\"));\r\n  return changetype<TArray>(out); // retains\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction FIND_INDEX<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  fn: (value: T, index: i32, array: TArray) => bool,\r\n): i32 {\r\n  var dataStart = array.dataStart;\r\n  for (let i = 0, k = array.length; i < k; i++) {\r\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return i;\r\n  }\r\n  return -1;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction INCLUDES<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  searchElement: T,\r\n  fromIndex: i32,\r\n): bool {\r\n  return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction INDEX_OF<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  searchElement: T,\r\n  fromIndex: i32,\r\n): i32 {\r\n  var index: isize = fromIndex;\r\n  var length: isize = array.length;\r\n  if (length == 0 || index >= length) return -1;\r\n  if (index < 0) index = max(length + index, 0);\r\n  var dataStart = array.dataStart;\r\n  while (index < length) {\r\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\r\n    ++index;\r\n  }\r\n  return -1;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  searchElement: T,\r\n  fromIndex: i32,\r\n): i32 {\r\n  var index: isize = fromIndex;\r\n  var length: isize = array.length;\r\n  if (length == 0) return -1;\r\n  if (index < 0) index = length + index; // no need to clamp\r\n  else if (index >= length) index = length - 1;\r\n  var dataStart = array.dataStart;\r\n  while (index >= 0) {\r\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\r\n    --index;\r\n  }\r\n  return -1;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction SOME<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  fn: (value: T, index: i32, array: TArray) => bool,\r\n): bool {\r\n  var dataStart = array.dataStart;\r\n  for (let i = 0, k = array.length; i < k; i++) {\r\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction EVERY<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  fn: (value: T, index: i32, array: TArray) => bool,\r\n): bool {\r\n  var dataStart = array.dataStart;\r\n  for (let i = 0, k = array.length; i < k; i++) {\r\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) continue;\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction FOREACH<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  fn: (value: T, index: i32, array: TArray) => void,\r\n): void {\r\n  var dataStart = array.dataStart;\r\n  for (let i = 0, k = array.length; i < k; i++) {\r\n    fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction REVERSE<TArray extends ArrayBufferView, T>(array: TArray): TArray {\r\n  var dataStart = array.dataStart;\r\n  for (let front: usize = 0, back: usize = array.length - 1; front < back; ++front, --back) {\r\n    let frontPtr = dataStart + (front << alignof<T>());\r\n    let backPtr = dataStart + (back << alignof<T>());\r\n    let temp = load<T>(frontPtr);\r\n    store<T>(frontPtr, load<T>(backPtr));\r\n    store<T>(backPtr, temp);\r\n  }\r\n  return array;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction WRAP<TArray extends ArrayBufferView, T>(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): TArray {\r\n  var bufferByteLength = buffer.byteLength;\r\n  if (<u32>byteOffset >= <u32>bufferByteLength) {\r\n    throw new RangeError(E_INDEXOUTOFRANGE);\r\n  }\r\n  var byteLength: i32;\r\n  if (length < 0) {\r\n    if (length == -1) {\r\n      const mask = <i32>(1 << alignof<T>() - 1);\r\n      if (buffer.byteLength & mask) {\r\n        throw new RangeError(E_INVALIDLENGTH);\r\n      } else {\r\n        byteLength = buffer.byteLength;\r\n      }\r\n    } else {\r\n      throw new RangeError(E_INVALIDLENGTH);\r\n    }\r\n  } else {\r\n    byteLength = length << alignof<T>();\r\n  }\r\n  if (byteOffset + byteLength > buffer.byteLength) {\r\n    throw new RangeError(E_INVALIDLENGTH);\r\n  }\r\n  var out = __alloc(offsetof<TArray>(), idof<TArray>());\r\n  store<usize>(out, __retain(changetype<usize>(buffer)), offsetof<TArray>(\"buffer\"));\r\n  store<u32>(out, byteLength, offsetof<TArray>(\"byteLength\"));\r\n  store<usize>(out, changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\r\n  return changetype<TArray>(out); // retains\r\n}\r\n","/// <reference path=\"./rt/index.d.ts\" />\r\n\r\nimport { HASH } from \"./util/hash\";\r\nimport { E_KEYNOTFOUND } from \"util/error\";\r\n\r\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nconst INITIAL_CAPACITY = 4;\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nconst FILL_FACTOR_N = 8;\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nconst FILL_FACTOR_D = 3;\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nconst FREE_FACTOR_N = 3;\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nconst FREE_FACTOR_D = 4;\r\n\r\n/** Structure of a map entry. */\r\n@unmanaged class MapEntry<K,V> {\r\n  key: K;\r\n  value: V;\r\n  taggedNext: usize; // LSB=1 indicates EMPTY\r\n}\r\n\r\n/** Empty bit. */\r\n// @ts-ignore: decorator\r\n@inline\r\nconst EMPTY: usize = 1 << 0;\r\n\r\n/** Size of a bucket. */\r\n// @ts-ignore: decorator\r\n@inline\r\nconst BUCKET_SIZE = sizeof<usize>();\r\n\r\n/** Computes the alignment of an entry. */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction ENTRY_ALIGN<K,V>(): usize {\r\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\r\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\r\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\r\n  return align;\r\n}\r\n\r\n/** Computes the aligned size of an entry. */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction ENTRY_SIZE<K,V>(): usize {\r\n  const align = ENTRY_ALIGN<K,V>();\r\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\r\n  return size;\r\n}\r\n\r\nexport class Map<K,V> {\r\n\r\n  // buckets holding references to the respective first entry within\r\n  private buckets: ArrayBuffer; // usize[bucketsMask + 1]\r\n  private bucketsMask: u32;\r\n\r\n  // entries in insertion order\r\n  private entries: ArrayBuffer; // MapEntry<K,V>[entriesCapacity]\r\n  private entriesCapacity: i32;\r\n  private entriesOffset: i32;\r\n  private entriesCount: i32;\r\n\r\n  get size(): i32 { return this.entriesCount; }\r\n\r\n  constructor() {\r\n    this.clear();\r\n  }\r\n\r\n  clear(): void {\r\n    const bucketsSize = INITIAL_CAPACITY * <i32>BUCKET_SIZE;\r\n    this.buckets = new ArrayBuffer(bucketsSize);\r\n    this.bucketsMask = INITIAL_CAPACITY - 1;\r\n    const entriesSize = INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>();\r\n    this.entries = new ArrayBuffer(entriesSize);\r\n    this.entriesCapacity = INITIAL_CAPACITY;\r\n    this.entriesOffset = 0;\r\n    this.entriesCount = 0;\r\n  }\r\n\r\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\r\n    var entry = load<MapEntry<K,V>>( // unmanaged!\r\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\r\n    );\r\n    while (entry) {\r\n      if (!(entry.taggedNext & EMPTY) && entry.key == key) return entry;\r\n      entry = changetype<MapEntry<K,V>>(entry.taggedNext & ~EMPTY);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  has(key: K): bool {\r\n    return this.find(key, HASH<K>(key)) !== null;\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  get(key: K): V {\r\n    var entry = this.find(key, HASH<K>(key));\r\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\r\n    return entry.value;\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  set(key: K, value: V): void {\r\n    var hashCode = HASH<K>(key);\r\n    var entry = this.find(key, hashCode); // unmanaged!\r\n    if (entry) {\r\n      if (isManaged<V>()) {\r\n        let oldRef = changetype<usize>(entry.value);\r\n        if (changetype<usize>(value) != oldRef) {\r\n          entry.value = changetype<V>(__retain(changetype<usize>(value)));\r\n          __release(oldRef);\r\n        }\r\n      } else {\r\n        entry.value = value;\r\n      }\r\n    } else {\r\n      // check if rehashing is necessary\r\n      if (this.entriesOffset == this.entriesCapacity) {\r\n        this.rehash(\r\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\r\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\r\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\r\n        );\r\n      }\r\n      // append new entry\r\n      let entries = this.entries;\r\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + this.entriesOffset++ * ENTRY_SIZE<K,V>());\r\n      // link with the map\r\n      entry.key = isManaged<K>()\r\n        ? changetype<K>(__retain(changetype<usize>(key)))\r\n        : key;\r\n      entry.value = isManaged<V>()\r\n        ? changetype<V>(__retain(changetype<usize>(value)))\r\n        : value;\r\n      ++this.entriesCount;\r\n      // link with previous entry in bucket\r\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\r\n      entry.taggedNext = load<usize>(bucketPtrBase);\r\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\r\n    }\r\n  }\r\n\r\n  delete(key: K): bool {\r\n    var entry = this.find(key, HASH<K>(key));\r\n    if (!entry) return false;\r\n    if (isManaged<K>()) __release(changetype<usize>(entry.key));\r\n    if (isManaged<V>()) __release(changetype<usize>(entry.value));\r\n    entry.taggedNext |= EMPTY;\r\n    --this.entriesCount;\r\n    // check if rehashing is appropriate\r\n    var halfBucketsMask = this.bucketsMask >> 1;\r\n    if (\r\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\r\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\r\n    ) this.rehash(halfBucketsMask);\r\n    return true;\r\n  }\r\n\r\n  private rehash(newBucketsMask: u32): void {\r\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\r\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\r\n    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\r\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\r\n\r\n    // copy old entries to new entries\r\n    var oldPtr = changetype<usize>(this.entries);\r\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\r\n    var newPtr = changetype<usize>(newEntries);\r\n    while (oldPtr != oldEnd) {\r\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\r\n      if (!(oldEntry.taggedNext & EMPTY)) {\r\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\r\n        newEntry.key = oldEntry.key;\r\n        newEntry.value = oldEntry.value;\r\n        let newBucketIndex = HASH<K>(oldEntry.key) & newBucketsMask;\r\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\r\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\r\n        store<usize>(newBucketPtrBase, newPtr);\r\n        newPtr += ENTRY_SIZE<K,V>();\r\n      }\r\n      oldPtr += ENTRY_SIZE<K,V>();\r\n    }\r\n\r\n    this.buckets = newBuckets;\r\n    this.bucketsMask = newBucketsMask;\r\n    this.entries = newEntries;\r\n    this.entriesCapacity = newEntriesCapacity;\r\n    this.entriesOffset = this.entriesCount;\r\n  }\r\n\r\n  keys(): K[] {\r\n    // FIXME: this is preliminary, needs iterators/closures\r\n    var start = changetype<usize>(this.entries);\r\n    var size = this.entriesOffset;\r\n    var keys = new Array<K>(size);\r\n    var length = 0;\r\n    for (let i = 0; i < size; ++i) {\r\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\r\n      if (!(entry.taggedNext & EMPTY)) {\r\n        keys.push(entry.key);\r\n        ++length;\r\n      }\r\n    }\r\n    keys.length = length;\r\n    return keys;\r\n  }\r\n\r\n  values(): V[] {\r\n    // FIXME: this is preliminary, needs iterators/closures\r\n    var start = changetype<usize>(this.entries);\r\n    var size = this.entriesOffset;\r\n    var values = new Array<V>(size);\r\n    var length = 0;\r\n    for (let i = 0; i < size; ++i) {\r\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\r\n      if (!(entry.taggedNext & EMPTY)) {\r\n        values.push(entry.value);\r\n        ++length;\r\n      }\r\n    }\r\n    values.length = length;\r\n    return values;\r\n  }\r\n\r\n  toString(): string {\r\n    return \"[object Map]\";\r\n  }\r\n\r\n  // RT integration\r\n\r\n  @unsafe private __visit_impl(cookie: u32): void {\r\n    __visit(changetype<usize>(this.buckets), cookie);\r\n    var entries = changetype<usize>(this.entries);\r\n    if (isManaged<K>() || isManaged<V>()) {\r\n      let cur = entries;\r\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\r\n      while (cur < end) {\r\n        let entry = changetype<MapEntry<K,V>>(cur);\r\n        if (!(entry.taggedNext & EMPTY)) {\r\n          if (isManaged<K>()) {\r\n            let val = changetype<usize>(entry.key);\r\n            if (isNullable<K>()) {\r\n              if (val) __visit(val, cookie);\r\n            } else __visit(val, cookie);\r\n          }\r\n          if (isManaged<V>()) {\r\n            let val = changetype<usize>(entry.value);\r\n            if (isNullable<V>()) {\r\n              if (val) __visit(val, cookie);\r\n            } else __visit(val, cookie);\r\n          }\r\n        }\r\n        cur += ENTRY_SIZE<K,V>();\r\n      }\r\n    }\r\n    __visit(entries, cookie);\r\n  }\r\n}\r\n","// @ts-ignore: decorator\r\n@inline\r\nexport function HASH<T>(key: T): u32 {\r\n  if (isString<T>()) {\r\n    return hashStr(changetype<string>(key));\r\n  } else if (isReference<T>()) {\r\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\r\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\r\n  } else if (isFloat<T>()) {\r\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\r\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\r\n  } else {\r\n    if (sizeof<T>() == 1) return hash8 (u32(key));\r\n    if (sizeof<T>() == 2) return hash16(u32(key));\r\n    if (sizeof<T>() == 4) return hash32(u32(key));\r\n    if (sizeof<T>() == 8) return hash64(u64(key));\r\n  }\r\n  return unreachable();\r\n}\r\n\r\n// FNV-1a 32-bit as a starting point, see: http://isthe.com/chongo/tech/comp/fnv/\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nconst FNV_OFFSET: u32 = 2166136261;\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nconst FNV_PRIME: u32 = 16777619;\r\n\r\nfunction hash8(key: u32): u32 {\r\n  return (FNV_OFFSET ^ key) * FNV_PRIME;\r\n}\r\n\r\nfunction hash16(key: u32): u32 {\r\n  var v = FNV_OFFSET;\r\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( key >>  8        )) * FNV_PRIME;\r\n  return v;\r\n}\r\n\r\nfunction hash32(key: u32): u32 {\r\n  var v = FNV_OFFSET;\r\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((key >>  8) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((key >> 16) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( key >> 24        )) * FNV_PRIME;\r\n  return v;\r\n}\r\n\r\nfunction hash64(key: u64): u32 {\r\n  var l = <u32> key;\r\n  var h = <u32>(key >>> 32);\r\n  var v = FNV_OFFSET;\r\n  v = (v ^ ( l        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((l >>  8) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((l >> 16) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( l >> 24        )) * FNV_PRIME;\r\n  v = (v ^ ( h        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((h >>  8) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((h >> 16) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( h >> 24        )) * FNV_PRIME;\r\n  return v;\r\n}\r\n\r\nfunction hashStr(key: string): u32 {\r\n  var v = FNV_OFFSET;\r\n  if (key !== null) {\r\n    for (let i: usize = 0, k: usize = key.length << 1; i < k; ++i) {\r\n      v = (v ^ <u32>load<u8>(changetype<usize>(key) + i)) * FNV_PRIME;\r\n    }\r\n  }\r\n  return v;\r\n}\r\n","import { CanvasRenderingContext2D } from \"../renderer/CanvasRenderingContext2D\";\r\n\r\nlet map = new Map<string, CanvasRenderingContext2D>();\r\n\r\n/**\r\n * This internal function is exported via the `./assembly/glue.ts` file. It receives an id from the\r\n * host, and a name. It's responsible for creating a new CanvasRenderingContext2D object, then\r\n * stores it on the map object by it's name. This allows developers to call `getContextById(name)`\r\n * to obtain the created reference to the canvas context.\r\n *\r\n * @param {string} name - The name of the CanvasRenderingContext2D object\r\n * @param {i32} id - The unique objectid created by the browser that identifies the context.\r\n */\r\nexport function __use_context(name: string, id: i32): void {\r\n  var result = new CanvasRenderingContext2D();\r\n  store<i32>(changetype<usize>(result) + offsetof<CanvasRenderingContext2D>(\"id\"), id);\r\n  map.set(name, result);\r\n}\r\n\r\n/**\r\n * This function is the only way to obtain a named canvas provided by the JavaScript host.\r\n *\r\n * @param {string} name - This is the name of the provided context.\r\n */\r\nexport function getContextById(name: string): CanvasRenderingContext2D {\r\n  if (!map.has(name)) throw new Error(\"Cannot find context with name: \" + name);\r\n  return map.get(name);\r\n}\r\n","import { STORE } from \"./util\";\r\n/**\r\n * The Buffer class is an ArrayBuffer backed data writer that utilizes the internal STORE function\r\n * provided by AssemblyScript to write data as fast as possible to memory. The generic type\r\n * parameter represents an enum indicating the instruction type values coupled with the memory\r\n * writes. Each instruction write results in the following values written to the buffer:\r\n *\r\n * 1. [instruction] `T` - This value is the instruction type cast to a `f64`\r\n * 2. [nextIndex] `i32` - This value is the pointer to the next instruction index\r\n * 3. [...args] `f64[]` - These values are the argument values for the instruction\r\n */\r\nexport class Buffer<T extends i32> {\r\n  /**\r\n   * The buffer property is a reference to an allocated block of memory that contains all the\r\n   * currently written values to the buffer. The browser eventually should obtain a pointer to this\r\n   * block and read the values from it to perform actions.\r\n   */\r\n  protected _buffer: ArrayBuffer = new ArrayBuffer(0x10000 * sizeof<f64>());\r\n\r\n  /**\r\n   * The set of retained pointers that need to be cleaned up after a commit().\r\n   */\r\n  protected _retained: ArrayBuffer = new ArrayBuffer(0x10000 << alignof<usize>());\r\n\r\n  /**\r\n   * The offset into the _retained pointer list.\r\n   */\r\n  protected _retainedOffset: i32 = 0;\r\n\r\n  /**\r\n   * The offset property is a pointer to the next index that will receive a written value.\r\n   */\r\n  private _offset: i32 = 0;\r\n\r\n  /**\r\n   * Write a single instruction to the buffer without any parameters. This results in two values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeZero(inst: T): void {\r\n    var buff = changetype<usize>(this._buffer);\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 2;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with a single parameter. This results in three values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeOne(inst: T, a: f64): void {\r\n    var buff = changetype<usize>(this._buffer);\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 3;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with two parameters. This results in four values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeTwo(inst: T, a: f64, b: f64): void {\r\n    var buff = changetype<usize>(this._buffer);\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 4;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with three parameters. This results in five values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\r\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeThree(inst: T, a: f64, b: f64, c: f64): void {\r\n    var buff = changetype<usize>(this._buffer);\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 5;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    STORE<f64>(buff, index + 4, c);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with four parameters. This results in six values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\r\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\r\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeFour(inst: T, a: f64, b: f64, c: f64, d: f64): void {\r\n    var buff = changetype<usize>(this._buffer);\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 6;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    STORE<f64>(buff, index + 4, c);\r\n    STORE<f64>(buff, index + 5, d);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with five parameters. This results in seven values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\r\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\r\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} d - The fifth parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeFive(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64): void {\r\n    var buff = changetype<usize>(this._buffer);\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 7;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    STORE<f64>(buff, index + 4, c);\r\n    STORE<f64>(buff, index + 5, d);\r\n    STORE<f64>(buff, index + 6, e);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with six parameters. This results in eight values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\r\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\r\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} e - The fifth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} f - The sixth parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeSix(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    var buff = changetype<usize>(this._buffer);\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 8;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    STORE<f64>(buff, index + 4, c);\r\n    STORE<f64>(buff, index + 5, d);\r\n    STORE<f64>(buff, index + 6, e);\r\n    STORE<f64>(buff, index + 7, f);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with eight parameters. This results in ten values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\r\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\r\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} e - The fifth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} f - The sixth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} g - The seventh parameter for the instruction to be written to the buffer.\r\n   * @param {f64} h - The eighth parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeEight(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64, g: f64, h: f64): void {\r\n    var buff = changetype<usize>(this._buffer);\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 10;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    STORE<f64>(buff, index + 4, c);\r\n    STORE<f64>(buff, index + 5, d);\r\n    STORE<f64>(buff, index + 6, e);\r\n    STORE<f64>(buff, index + 7, f);\r\n    STORE<f64>(buff, index + 8, g);\r\n    STORE<f64>(buff, index + 9, h);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with nine parameters. This results in eleven values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\r\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\r\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} e - The fifth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} f - The sixth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} g - The seventh parameter for the instruction to be written to the buffer.\r\n   * @param {f64} h - The eighth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} i - The ninth parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeNine(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64, g: f64, h: f64, i: f64): void {\r\n    var buff = changetype<usize>(this._buffer);\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 11;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    STORE<f64>(buff, index + 4, c);\r\n    STORE<f64>(buff, index + 5, d);\r\n    STORE<f64>(buff, index + 6, e);\r\n    STORE<f64>(buff, index + 7, f);\r\n    STORE<f64>(buff, index + 8, g);\r\n    STORE<f64>(buff, index + 9, h);\r\n    STORE<f64>(buff, index + 10, i);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Reset the buffer back to position 0.\r\n   */\r\n  @inline\r\n  protected _resetBuffer(): void {\r\n    this._offset = 0;\r\n    let length = this._retainedOffset;\r\n    let pointer = changetype<usize>(this._retained);\r\n    for (let i = 0; i < length; i++) {\r\n      __release(load<usize>(pointer + (<usize>i << alignof<usize>())));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retain a pointer in the buffer for later use.\r\n   *\r\n   * @param {usize} pointer - The pointer to be retained and released after the buffer is reset.\r\n   */\r\n  protected _retain(pointer: usize): void {\r\n    __retain(pointer);\r\n    var retained = changetype<usize>(this._retained);\r\n    var index = this._retainedOffset;\r\n    store<usize>(retained + (index << alignof<usize>()), pointer);\r\n    this._retainedOffset = index + 1;\r\n  }\r\n}\r\n","\r\n@unmanaged\r\nexport class StackPointer<T> {\r\n  static create<T>(count: i32): StackPointer<T> {\r\n    assert(!isManaged<T>());\r\n    assert(isReference<T>());\r\n    assert(count > 0);\r\n    let length = offsetof<T>() * count;\r\n    let ptr = __alloc(length, idof<ArrayBuffer>());\r\n    memory.fill(ptr, 0, length);\r\n    return changetype<StackPointer<T>>(ptr);\r\n  }\r\n\r\n  @inline\r\n  push(): StackPointer<T> {\r\n    let current = changetype<usize>(this);\r\n    let next = current + offsetof<T>();\r\n    memory.copy(next, current, offsetof<T>());\r\n    return changetype<StackPointer<T>>(next);\r\n  }\r\n\r\n  @inline @operator.prefix(\"++\")\r\n  increment(): StackPointer<T> {\r\n    return changetype<StackPointer<T>>(changetype<usize>(this) + offsetof<T>());\r\n  }\r\n\r\n  @inline @operator.prefix(\"--\")\r\n  decrement(): StackPointer<T> {\r\n    return changetype<StackPointer<T>>(changetype<usize>(this) - offsetof<T>());\r\n  }\r\n\r\n  @inline\r\n  pop(): StackPointer<T> {\r\n    return changetype<StackPointer<T>>(changetype<usize>(this) - offsetof<T>());\r\n  }\r\n\r\n  reference(): T {\r\n    return changetype<T>(this);\r\n  }\r\n\r\n  dereference(): usize {\r\n    return changetype<usize>(this);\r\n  }\r\n}\r\n","@inline\r\nexport function arraysEqual(left: Float64Array, right: Float64Array): bool {\r\n  var len: i32 = left.length;\r\n  var valid = true;\r\n  if (len == right.length) {\r\n    for (var i = 0; i < len; i++) {\r\n      if (unchecked(left[i]) != unchecked(right[i])) {\r\n        valid = false;\r\n        break;\r\n      }\r\n    }\r\n  } else {\r\n    valid = false;\r\n  }\r\n  return valid;\r\n}\r\n\r\n@inline\r\nexport function checkDoubleArray(value: Float64Array): Float64Array {\r\n  var len: i32 = value.length;\r\n  var double: bool = <bool>(len & 1);\r\n  var result: Float64Array = new Float64Array(double ? len * 2 : len);\r\n  var doublelen: i32;\r\n  var i: i32 = 0;\r\n  for (;i < len; ++i) {\r\n    unchecked(result[i] = value[i]);\r\n  }\r\n  if (double) {\r\n    doublelen = len << 1;\r\n    for(;i < doublelen; i++) {\r\n      unchecked(result[i] = value[i - len]);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n// @ts-ignore: decorators *are* valid here\r\n@inline\r\nexport function STORE<T>(pointer: usize, index: i32, value: T): void {\r\n  store<T>(pointer + (index << alignof<T>()), value);\r\n}\r\n\r\n// @ts-ignore: decorators *are* valid here\r\n@inline\r\nexport function LOAD<T>(pointer: usize, index: i32): T {\r\n  return load<T>(pointer + (index << alignof<T>()));\r\n}\r\n","/// <reference path=\"./rt/index.d.ts\" />\r\n\r\nimport { BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./rt/common\";\r\nimport { compareImpl, strtol, strtod, isSpace } from \"./util/string\";\r\nimport { E_INVALIDLENGTH } from \"./util/error\";\r\nimport { ArrayBufferView } from \"./arraybuffer\";\r\nimport { idof } from \"./builtins\";\r\n\r\n@sealed export abstract class String {\r\n\r\n  @lazy static readonly MAX_LENGTH: i32 = BLOCK_MAXSIZE >>> alignof<u16>();\r\n\r\n  static fromCharCode(unit: i32, surr: i32 = -1): string {\r\n    var hasSur = surr > 0;\r\n    var out = __alloc(2 << i32(hasSur), idof<string>());\r\n    store<u16>(out, <u16>unit);\r\n    if (hasSur) store<u16>(out, <u16>surr, 2);\r\n    return changetype<string>(out); // retains\r\n  }\r\n\r\n  static fromCodePoint(code: i32): string {\r\n    assert(<u32>code <= 0x10FFFF);\r\n    var hasSur = code > 0xFFFF;\r\n    var out = __alloc(2 << i32(hasSur), idof<string>());\r\n    if (!hasSur) {\r\n      store<u16>(out, <u16>code);\r\n    } else {\r\n      code -= 0x10000;\r\n      let lo: u32 = (code & 0x3FF) + 0xDC00;\r\n      let hi: u32 = (code >>> 10) + 0xD800;\r\n      store<u32>(out, hi | (lo << 16));\r\n    }\r\n    return changetype<string>(out); // retains\r\n  }\r\n\r\n  get length(): i32 {\r\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize >> 1;\r\n  }\r\n\r\n  @operator(\"[]\") charAt(pos: i32): String {\r\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\r\n    var out = __alloc(2, idof<String>());\r\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\r\n    return changetype<String>(out); // retains\r\n  }\r\n\r\n  charCodeAt(pos: i32): i32 {\r\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\r\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\r\n  }\r\n\r\n  codePointAt(pos: i32): i32 {\r\n    if (<u32>pos >= <u32>this.length) return -1; // (undefined)\r\n    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\r\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) return first;\r\n    var second = <i32>load<u16>(changetype<usize>(this) + ((<usize>pos + 1) << 1));\r\n    if (second < 0xDC00 || second > 0xDFFF) return first;\r\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\r\n  }\r\n\r\n  @operator(\"+\") private static __concat(left: String, right: String): String {\r\n    return select<String>(left, changetype<String>(\"null\"), left !== null).concat(right);\r\n  }\r\n\r\n  concat(other: String): String {\r\n    if (other === null) other = changetype<String>(\"null\");\r\n    var thisSize: isize = this.length << 1;\r\n    var otherSize: isize = other.length << 1;\r\n    var outSize: usize = thisSize + otherSize;\r\n    if (outSize == 0) return changetype<String>(\"\");\r\n    var out = changetype<String>(__alloc(outSize, idof<String>())); // retains\r\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\r\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\r\n    return out;\r\n  }\r\n\r\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\r\n    if (search === null) return false;\r\n    end = min(max(end, 0), this.length);\r\n    var searchLength = <isize>search.length;\r\n    var searchStart = <isize>end - searchLength;\r\n    if (searchStart < 0) return false;\r\n    // @ts-ignore: string <-> String\r\n    return !compareImpl(this, searchStart, search, 0, searchLength);\r\n  }\r\n\r\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\r\n    if (left === right) return true;\r\n    if (left === null || right === null) return false;\r\n    var leftLength = left.length;\r\n    if (leftLength != right.length) return false;\r\n    // @ts-ignore: string <-> String\r\n    return !compareImpl(left, 0, right, 0, leftLength);\r\n  }\r\n\r\n  @operator.prefix(\"!\")\r\n  private static __not(str: String | null): bool {\r\n    return str === null || !str.length;\r\n  }\r\n\r\n  @operator(\"!=\")\r\n  private static __ne(left: String | null, right: String | null): bool {\r\n    return !this.__eq(left, right);\r\n  }\r\n\r\n  @operator(\">\") private static __gt(left: String | null, right: String | null): bool {\r\n    if (left === right || left === null || right === null) return false;\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n    if (!leftLength)  return false;\r\n    if (!rightLength) return true;\r\n    // @ts-ignore: string <-> String\r\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) > 0;\r\n  }\r\n\r\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\r\n    return !this.__lt(left, right);\r\n  }\r\n\r\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\r\n    if (left === right || left === null || right === null) return false;\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n    if (!rightLength) return false;\r\n    if (!leftLength)  return true;\r\n    // @ts-ignore: string <-> String\r\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) < 0;\r\n  }\r\n\r\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\r\n    return !this.__gt(left, right);\r\n  }\r\n\r\n  includes(search: String, start: i32 = 0): bool {\r\n    return this.indexOf(search, start) != -1;\r\n  }\r\n\r\n  indexOf(search: String, start: i32 = 0): i32 {\r\n    var searchLen = <isize>search.length;\r\n    if (!searchLen) return 0;\r\n    var len = <isize>this.length;\r\n    if (!len) return -1;\r\n    var searchStart = min(max(<isize>start, 0), len);\r\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\r\n      // @ts-ignore: string <-> String\r\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\r\n    var searchLen = <isize>search.length;\r\n    if (!searchLen) return this.length;\r\n    var len = this.length;\r\n    if (!len) return -1;\r\n    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\r\n    for (; searchStart >= 0; --searchStart) {\r\n      // @ts-ignore: string <-> String\r\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  startsWith(search: String, start: i32 = 0): bool {\r\n    if (search === null) search = changetype<String>(\"null\");\r\n    var len = <isize>this.length;\r\n    var searchStart = min(max(<isize>start, 0), len);\r\n    var searchLength = <isize>search.length;\r\n    if (searchLength + searchStart > len) return false;\r\n    // @ts-ignore: string <-> String\r\n    return !compareImpl(this, searchStart, search, 0, searchLength);\r\n  }\r\n\r\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\r\n    var intStart: isize = start;\r\n    var end: isize = length;\r\n    var size: isize = this.length;\r\n    if (intStart < 0) intStart = max(size + intStart, 0);\r\n    var resultLength = min(max(end, 0), size - intStart);\r\n    if (resultLength <= 0) return changetype<String>(\"\");\r\n    var out = __alloc(resultLength << 1, idof<String>());\r\n    memory.copy(out, changetype<usize>(this) + intStart, resultLength);\r\n    return changetype<String>(out); // retains\r\n  }\r\n\r\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\r\n    var len: isize = this.length;\r\n    var finalStart = min<isize>(max(start, 0), len);\r\n    var finalEnd = min<isize>(max(end, 0), len);\r\n    var fromPos = min<isize>(finalStart, finalEnd) << 1;\r\n    var toPos = max<isize>(finalStart, finalEnd) << 1;\r\n    len = toPos - fromPos;\r\n    if (!len) return changetype<String>(\"\");\r\n    if (!fromPos && toPos == this.length << 1) return this;\r\n    var out = __alloc(len, idof<String>());\r\n    memory.copy(out, changetype<usize>(this) + fromPos, len);\r\n    return changetype<String>(out); // retains\r\n  }\r\n\r\n  trim(): String {\r\n    var length = this.length;\r\n    var size: usize = length << 1;\r\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\r\n      size -= 2;\r\n    }\r\n    var offset: usize = 0;\r\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\r\n      offset += 2; size -= 2;\r\n    }\r\n    if (!size) return changetype<String>(\"\");\r\n    if (!offset && size == length << 1) return this;\r\n    var out = __alloc(size, idof<String>());\r\n    memory.copy(out, changetype<usize>(this) + offset, size);\r\n    return changetype<String>(out); // retains\r\n  }\r\n\r\n  @inline\r\n  trimLeft(): String {\r\n    return this.trimStart();\r\n  }\r\n\r\n  @inline\r\n  trimRight(): String {\r\n    return this.trimEnd();\r\n  }\r\n\r\n  trimStart(): String {\r\n    var size = <usize>this.length << 1;\r\n    var offset: usize = 0;\r\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\r\n      offset += 2;\r\n    }\r\n    if (!offset) return this;\r\n    size -= offset;\r\n    if (!size) return changetype<String>(\"\");\r\n    var out = __alloc(size, idof<String>());\r\n    memory.copy(out, changetype<usize>(this) + offset, size);\r\n    return changetype<String>(out); // retains\r\n  }\r\n\r\n  trimEnd(): String {\r\n    var originalSize = <usize>this.length << 1;\r\n    var size = originalSize;\r\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\r\n      size -= 2;\r\n    }\r\n    if (!size) return changetype<String>(\"\");\r\n    if (size == originalSize) return this;\r\n    var out = __alloc(size, idof<String>());\r\n    memory.copy(out, changetype<usize>(this), size);\r\n    return changetype<String>(out); // retains\r\n  }\r\n\r\n  padStart(length: i32, pad: string = \" \"): String {\r\n    var thisSize = <usize>this.length << 1;\r\n    var targetSize = <usize>length << 1;\r\n    var padSize = <usize>pad.length << 1;\r\n    if (targetSize < thisSize || !padSize) return this;\r\n    var prependSize = targetSize - thisSize;\r\n    var out = __alloc(targetSize, idof<String>());\r\n    if (prependSize > padSize) {\r\n      let repeatCount = (prependSize - 2) / padSize;\r\n      let restBase = repeatCount * padSize;\r\n      let restSize = prependSize - restBase;\r\n      memory.repeat(out, changetype<usize>(pad), padSize, repeatCount);\r\n      memory.copy(out + restBase, changetype<usize>(pad), restSize);\r\n    } else {\r\n      memory.copy(out, changetype<usize>(pad), prependSize);\r\n    }\r\n    memory.copy(out + prependSize, changetype<usize>(this), thisSize);\r\n    return changetype<String>(out); //  retains\r\n  }\r\n\r\n  padEnd(length: i32, pad: string = \" \"): String {\r\n    var thisSize = <usize>this.length << 1;\r\n    var targetSize = <usize>length << 1;\r\n    var padSize = <usize>pad.length << 1;\r\n    if (targetSize < thisSize || !padSize) return this;\r\n    var appendSize = targetSize - thisSize;\r\n    var out = __alloc(targetSize, idof<String>());\r\n    memory.copy(out, changetype<usize>(this), thisSize);\r\n    if (appendSize > padSize) {\r\n      let repeatCount = (appendSize - 2) / padSize;\r\n      let restBase = repeatCount * padSize;\r\n      let restSize = appendSize - restBase;\r\n      memory.repeat(out + thisSize, changetype<usize>(pad), padSize, repeatCount);\r\n      memory.copy(out + thisSize + restBase, changetype<usize>(pad), restSize);\r\n    } else {\r\n      memory.copy(out + thisSize, changetype<usize>(pad), appendSize);\r\n    }\r\n    return changetype<String>(out); // retains\r\n  }\r\n\r\n  repeat(count: i32 = 0): String {\r\n    var length = this.length;\r\n\r\n    // Most browsers can't handle strings 1 << 28 chars or longer\r\n    if (count < 0 || <u64>length * count > (1 << 28)) {\r\n      throw new RangeError(E_INVALIDLENGTH);\r\n    }\r\n\r\n    if (count == 0 || !length) return changetype<String>(\"\");\r\n    if (count == 1) return this;\r\n    var out = __alloc((length * count) << 1, idof<String>());\r\n    memory.repeat(out, changetype<usize>(this), <usize>length << 1, count);\r\n    return changetype<String>(out); // retains\r\n  }\r\n\r\n  replace(search: String, replacement: String): String {\r\n    var len: usize = this.length;\r\n    var slen: usize = search.length;\r\n    if (len <= slen) {\r\n      return len < slen ? this : select<String>(replacement, this, search == this);\r\n    }\r\n    var index: isize = this.indexOf(search);\r\n    if (~index) {\r\n      let rlen: usize = replacement.length;\r\n      len -= slen;\r\n      let olen = len + rlen;\r\n      if (olen) {\r\n        let out = __alloc(olen << 1, idof<String>());\r\n        memory.copy(out, changetype<usize>(this), index << 1);\r\n        memory.copy(\r\n          out + (index << 1),\r\n          changetype<usize>(replacement),\r\n          rlen << 1\r\n        );\r\n        memory.copy(\r\n          out + ((index + rlen) << 1),\r\n          changetype<usize>(this) + ((index + slen) << 1),\r\n          (len - index) << 1\r\n        );\r\n        return changetype<String>(out);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  replaceAll(search: String, replacement: String): String {\r\n    var len: usize = this.length;\r\n    var slen: usize = search.length;\r\n    if (len <= slen) {\r\n      return len < slen ? this : select<String>(replacement, this, search == this);\r\n    }\r\n    var rlen: usize = replacement.length;\r\n    if (!slen) {\r\n      if (!rlen) return this;\r\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\r\n      let out = __alloc((len + (len + 1) * rlen) << 1, idof<String>());\r\n      memory.copy(out, changetype<usize>(replacement), rlen << 1);\r\n      let offset = rlen;\r\n      for (let i: usize = 0; i < len; ++i) {\r\n        store<u16>(\r\n          changetype<usize>(out) + (offset++ << 1),\r\n          load<u16>(changetype<usize>(this) + (i << 1))\r\n        );\r\n        memory.copy(\r\n          out + (offset << 1),\r\n          changetype<usize>(replacement),\r\n          rlen << 1\r\n        );\r\n        offset += rlen;\r\n      }\r\n      return changetype<String>(out);\r\n    }\r\n    var prev: isize = 0, next: isize = 0;\r\n    if (slen == rlen) {\r\n      // Fast path when search and replacement have same length\r\n      let size = len << 1;\r\n      let out = __alloc(size, idof<String>());\r\n      memory.copy(out, changetype<usize>(this), size);\r\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\r\n        memory.copy(out + (next << 1), changetype<usize>(replacement), rlen << 1);\r\n        prev = next + slen;\r\n      }\r\n      return changetype<String>(out);\r\n    }\r\n    var out: usize = 0, offset: usize = 0, resLen = len;\r\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\r\n      if (!out) out = __alloc(len << 1, idof<String>());\r\n      if (offset > resLen) {\r\n        let newLength = resLen << 1;\r\n        out = __realloc(out, newLength << 1);\r\n        resLen = newLength;\r\n      }\r\n      let chunk = next - prev;\r\n      memory.copy(\r\n        out + (offset << 1),\r\n        changetype<usize>(this) + (prev << 1),\r\n        chunk << 1\r\n      );\r\n      offset += chunk;\r\n      memory.copy(\r\n        out + (offset << 1),\r\n        changetype<usize>(replacement),\r\n        rlen << 1\r\n      );\r\n      offset += rlen;\r\n      prev = next + slen;\r\n    }\r\n    if (offset) {\r\n      if (offset > resLen) {\r\n        let newLength = resLen << 1;\r\n        out = __realloc(out, newLength << 1);\r\n        resLen = newLength;\r\n      }\r\n      let rest = len - prev;\r\n      if (rest) {\r\n        memory.copy(\r\n          out + (offset << 1),\r\n          changetype<usize>(this) + (prev << 1),\r\n          rest << 1\r\n        );\r\n      }\r\n      rest += offset;\r\n      if (resLen > rest) out = __realloc(out, rest << 1);\r\n      return changetype<String>(out);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\r\n    var len = this.length;\r\n    start = start < 0 ? max(start + len, 0) : min(start, len);\r\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\r\n    len   = end - start;\r\n    if (len <= 0) return changetype<String>(\"\");\r\n    var out = __alloc(len << 1, idof<String>());\r\n    memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\r\n    return changetype<String>(out); // retains\r\n  }\r\n\r\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\r\n    if (!limit) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\r\n    if (separator === null) return <String[]>[this];\r\n    var length: isize = this.length;\r\n    var sepLen: isize = separator.length;\r\n    if (limit < 0) limit = i32.MAX_VALUE;\r\n    if (!sepLen) {\r\n      if (!length) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>()));  // retains\r\n      // split by chars\r\n      length = min<isize>(length, <isize>limit);\r\n      let result = __allocArray(length, alignof<String>(), idof<Array<String>>());\r\n      let resultStart = changetype<ArrayBufferView>(result).dataStart;\r\n      for (let i: isize = 0; i < length; ++i) {\r\n        let charStr = __alloc(2, idof<String>());\r\n        store<u16>(charStr, load<u16>(changetype<usize>(this) + (<usize>i << 1)));\r\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), charStr); // result[i] = charStr\r\n        if (isManaged<String>()) __retain(charStr);\r\n      }\r\n      return changetype<Array<String>>(result); // retains\r\n    } else if (!length) {\r\n      let result = __allocArray(1, alignof<String>(), idof<Array<String>>());\r\n      store<usize>(changetype<ArrayBufferView>(result).dataStart, changetype<usize>(\"\")); // static \"\"\r\n      return changetype<Array<String>>(result); // retains\r\n    }\r\n    var result = changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\r\n    var end = 0, start = 0, i = 0;\r\n    while (~(end = this.indexOf(separator, start))) {\r\n      let len = end - start;\r\n      if (len > 0) {\r\n        let out = __alloc(<usize>len << 1, idof<String>());\r\n        memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\r\n        result.push(changetype<String>(out));\r\n      } else {\r\n        result.push(changetype<String>(\"\"));\r\n      }\r\n      if (++i == limit) return changetype<Array<String>>(result); // retains\r\n      start = end + sepLen;\r\n    }\r\n    if (!start) { // also means: loop above didn't do anything\r\n      result.push(this);\r\n      return changetype<Array<String>>(result); // retains\r\n    }\r\n    var len = length - start;\r\n    if (len > 0) {\r\n      let out = __alloc(<usize>len << 1, idof<String>());\r\n      memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\r\n      result.push(changetype<String>(out)); // retains\r\n    } else {\r\n      result.push(changetype<String>(\"\")); // static \"\"\r\n    }\r\n    return changetype<Array<String>>(result); // retains\r\n    // releases result\r\n  }\r\n\r\n  toString(): String {\r\n    return this;\r\n  }\r\n}\r\n\r\n// @ts-ignore: nolib\r\nexport type string = String;\r\n\r\nexport function parseInt(str: string, radix: i32 = 0): f64 {\r\n  return strtol<f64>(str, radix);\r\n}\r\n\r\nexport function parseFloat(str: string): f64 {\r\n  return strtod(str);\r\n}\r\n\r\n// Encoding helpers\r\nexport namespace String {\r\n\r\n  export namespace UTF8 {\r\n\r\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\r\n      var strOff = changetype<usize>(str);\r\n      var strEnd = strOff + <usize>changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\r\n      var bufLen = nullTerminated ? 1 : 0;\r\n      while (strOff < strEnd) {\r\n        let c1 = <u32>load<u16>(strOff);\r\n        if (c1 < 128) {\r\n          if (nullTerminated && !c1) break;\r\n          bufLen += 1; strOff += 2;\r\n        } else if (c1 < 2048) {\r\n          bufLen += 2; strOff += 2;\r\n        } else {\r\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\r\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\r\n              strOff += 4; bufLen += 4;\r\n              continue;\r\n            }\r\n          }\r\n          strOff += 2; bufLen += 3;\r\n        }\r\n      }\r\n      return bufLen;\r\n    }\r\n\r\n    export function encode(str: string, nullTerminated: bool = false): ArrayBuffer {\r\n      var strOff = changetype<usize>(str);\r\n      var strEnd = changetype<usize>(str) + <usize>changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\r\n      var buf = __alloc(UTF8.byteLength(str, nullTerminated), idof<ArrayBuffer>());\r\n      var bufOff = buf;\r\n      while (strOff < strEnd) {\r\n        let c1 = <u32>load<u16>(strOff);\r\n        if (c1 < 128) {\r\n          if (nullTerminated && !c1) break;\r\n          store<u8>(bufOff, c1);\r\n          bufOff += 1; strOff += 2;\r\n        } else if (c1 < 2048) {\r\n          store<u8>(bufOff, c1 >> 6      | 192);\r\n          store<u8>(bufOff, c1      & 63 | 128, 1);\r\n          bufOff += 2; strOff += 2;\r\n        } else {\r\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\r\n            let c2 = <u32>load<u16>(strOff, 2);\r\n            if ((c2 & 0xFC00) == 0xDC00) {\r\n              c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n              store<u8>(bufOff, c1 >> 18      | 240);\r\n              store<u8>(bufOff, c1 >> 12 & 63 | 128, 1);\r\n              store<u8>(bufOff, c1 >> 6  & 63 | 128, 2);\r\n              store<u8>(bufOff, c1       & 63 | 128, 3);\r\n              strOff += 4; bufOff += 4;\r\n              continue;\r\n            }\r\n          }\r\n          store<u8>(bufOff, c1 >> 12      | 224);\r\n          store<u8>(bufOff, c1 >> 6  & 63 | 128, 1);\r\n          store<u8>(bufOff, c1       & 63 | 128, 2);\r\n          strOff += 2; bufOff += 3;\r\n        }\r\n      }\r\n      if (nullTerminated) {\r\n        assert(strOff <= strEnd);\r\n        buf = __realloc(buf, bufOff - buf + 1);\r\n        store<u8>(bufOff, 0);\r\n      } else {\r\n        assert(strOff == strEnd);\r\n      }\r\n      return changetype<ArrayBuffer>(buf); // retains\r\n    }\r\n\r\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): string {\r\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\r\n    }\r\n\r\n    // @ts-ignore: decorator\r\n    @unsafe\r\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): string {\r\n      var bufOff = buf;\r\n      var bufEnd = buf + len;\r\n      assert(bufEnd >= bufOff); // guard wraparound\r\n      var str = __alloc(len << 1, idof<string>()); // max is one u16 char per u8 byte\r\n      var strOff = str;\r\n      while (bufOff < bufEnd) {\r\n        let cp = <u32>load<u8>(bufOff++);\r\n        if (cp < 128) {\r\n          if (nullTerminated && !cp) break;\r\n          store<u16>(strOff, cp);\r\n          strOff += 2;\r\n        } else if (cp > 191 && cp < 224) {\r\n          if (bufEnd - bufOff < 1) break;\r\n          store<u16>(strOff, (cp & 31) << 6 | load<u8>(bufOff++) & 63);\r\n          strOff += 2;\r\n        } else if (cp > 239 && cp < 365) {\r\n          if (bufEnd - bufOff < 3) break;\r\n          cp = (\r\n            (cp                  &  7) << 18 |\r\n            (load<u8>(bufOff)    & 63) << 12 |\r\n            (load<u8>(bufOff, 1) & 63) << 6  |\r\n             load<u8>(bufOff, 2) & 63\r\n          ) - 0x10000;\r\n          bufOff += 3;\r\n          store<u16>(strOff, 0xD800 + (cp >> 10));\r\n          store<u16>(strOff, 0xDC00 + (cp & 1023), 2);\r\n          strOff += 4;\r\n        } else {\r\n          if (bufEnd - bufOff < 2) break;\r\n          store<u16>(strOff,\r\n            (cp                  & 15) << 12 |\r\n            (load<u8>(bufOff)    & 63) << 6  |\r\n             load<u8>(bufOff, 1) & 63\r\n          );\r\n          bufOff += 2; strOff += 2;\r\n        }\r\n      }\r\n      return changetype<string>(__realloc(str, strOff - str)); // retains\r\n    }\r\n  }\r\n\r\n  export namespace UTF16 {\r\n\r\n    export function byteLength(str: string): i32 {\r\n      return changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\r\n    }\r\n\r\n    export function encode(str: string): ArrayBuffer {\r\n      var size = changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\r\n      var buf = __alloc(size, idof<ArrayBuffer>());\r\n      memory.copy(buf, changetype<usize>(str), <usize>size);\r\n      return changetype<ArrayBuffer>(buf); // retains\r\n    }\r\n\r\n    export function decode(buf: ArrayBuffer): string {\r\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\r\n    }\r\n\r\n    // @ts-ignore: decorator\r\n    @unsafe\r\n    export function decodeUnsafe(buf: usize, len: usize): string {\r\n      var str = __alloc(len &= ~1, idof<string>());\r\n      memory.copy(str, buf, len);\r\n      return changetype<string>(str); // retains\r\n    }\r\n  }\r\n}\r\n","// @ts-ignore\r\n@external(\"__canvas_sys\", \"loadImage\")\r\ndeclare function loadImage(img: Image, src: string): i32;\r\n\r\n// @ts-ignore\r\n@external(\"__canvas_sys\", \"disposeImage\")\r\ndeclare function disposeImage(id: i32): void;\r\n\r\nexport class Image {\r\n  private _id: i32 = -1;\r\n  private _width: i32 = 0;\r\n  private _height: i32 = 0;\r\n  private _loaded: bool = false;\r\n  private _src: string = \"\";\r\n\r\n  @inline\r\n  public get width(): number {\r\n    return this._width;\r\n  }\r\n\r\n  @inline\r\n  public get height(): number {\r\n    return this._height;\r\n  }\r\n\r\n  @inline\r\n  public get loaded(): bool {\r\n    return this._loaded;\r\n  }\r\n\r\n  @inline\r\n  public get src(): string {\r\n    return this._src;\r\n  }\r\n\r\n  public set src(value: string) {\r\n    this._src = value;\r\n    this._id = loadImage(this, value);\r\n  }\r\n\r\n  public dispose(): void {\r\n    disposeImage(this._id);\r\n  }\r\n}\r\n\r\nexport function __image_loaded(img: Image, width: i32, height: i32): void {\r\n  store<i32>(changetype<usize>(img) + offsetof<Image>(\"_width\"), width);\r\n  store<i32>(changetype<usize>(img) + offsetof<Image>(\"_height\"), height);\r\n  store<bool>(changetype<usize>(img) + offsetof<Image>(\"_loaded\"), true);\r\n}\r\n\r\n/**\r\n * Gets the image's external id.\r\n *\r\n * @param image - The target image.\r\n */\r\n// @ts-ignore: @inline is valid on regular functions\r\n@inline\r\nexport function getImageID(image: Image): i32 {\r\n  return load<i32>(changetype<usize>(image) + offsetof<Image>(\"_id\"));\r\n}\r\n","import {\r\n  CanvasGradient,\r\n  CanvasPattern,\r\n  CanvasPatternRepetition,\r\n  CanvasRenderingContext2D,\r\n  Image,\r\n  getContextById,\r\n} from \"./index\";\r\nimport { FillRule } from \"../src/shared/FillRule\";\r\n\r\nvar ctx: CanvasRenderingContext2D;\r\nvar grd: CanvasGradient;\r\nvar img: Image;\r\nvar pattern: CanvasPattern;\r\nexport function init(): void {\r\n  ctx = getContextById(\"main\");\r\n}\r\n\r\nexport function getCtxId(): i32 {\r\n  assert(ctx);\r\n  return load<i32>(changetype<usize>(ctx) + offsetof<CanvasRenderingContext2D>(\"id\"));\r\n}\r\n\r\nexport function addLinearGradient(): i32 {\r\n  grd = ctx.createLinearGradient(0, 0, 100, 100);\r\n  return load<i32>(changetype<usize>(grd) + offsetof<CanvasGradient>(\"id\"));\r\n}\r\n\r\nexport function addColorStop(): void {\r\n  assert(grd);\r\n  grd.addColorStop(1.0, \"blue\");\r\n}\r\n\r\nexport function addRadialGradient(): i32 {\r\n  grd = ctx.createRadialGradient(0, 0, 0, 100, 100, 100);\r\n  return load<i32>(changetype<usize>(grd) + offsetof<CanvasGradient>(\"id\"));\r\n}\r\n\r\nexport function createImage(): number {\r\n  img = new Image();\r\n  img.src = \"http://placekitten.com/400/300\";\r\n  return load<i32>(changetype<usize>(img) + offsetof<Image>(\"_id\"));\r\n}\r\n\r\nexport function createPattern(): i32 {\r\n  assert(ctx);\r\n  assert(img);\r\n  assert(img.loaded);\r\n  pattern = ctx.createPattern(img, CanvasPatternRepetition.repeat);\r\n  return load<i32>(changetype<usize>(pattern) + offsetof<CanvasPattern>(\"id\"));\r\n}\r\n\r\nexport function setBadID(): void {\r\n  assert(ctx);\r\n  store<i32>(changetype<usize>(ctx) + offsetof<CanvasRenderingContext2D>(\"id\"), -1);\r\n}\r\n\r\nexport function commit(): void {\r\n  assert(ctx);\r\n  ctx.commit();\r\n}\r\n\r\nexport function disposePattern(): void {\r\n  assert(pattern);\r\n  pattern.dispose();\r\n}\r\n\r\nexport function measureText(): void {\r\n  assert(ctx);\r\n  ctx.measureText(\"testing!\");\r\n}\r\n\r\nexport function disposeImage(): void {\r\n  assert(img);\r\n  img.dispose();\r\n}\r\n\r\nexport function disposeGradient(): void {\r\n  assert(grd);\r\n  grd.dispose();\r\n}\r\n\r\nexport function arc(x: f64, y: f64, r: f64, startAngle: f64, endAngle: f64, anticlockwise: bool): void {\r\n  assert(ctx);\r\n  ctx.arc(x, y, r, startAngle, endAngle, anticlockwise);\r\n}\r\n\r\nexport function closePath(): void {\r\n  assert(ctx);\r\n  ctx.closePath();\r\n}\r\n\r\nexport function isPointInPath(x: f64, y: f64, fillRule: FillRule): bool {\r\n  assert(ctx);\r\n  return ctx.isPointInPath(x, y, fillRule);\r\n}\r\n\r\nexport function isPointInStroke(x: f64, y: f64): bool {\r\n  assert(ctx);\r\n  return ctx.isPointInStroke(x, y);\r\n}","// @ts-ignore: decorators are valid here\r\n@external(\"__canvas_sys\", \"addColorStop\")\r\ndeclare function addColorStop(id: i32, offset: f64, color: string): void;\r\n\r\n// @ts-ignore: decorators are valid here\r\n@external(\"__canvas_sys\", \"disposeCanvasGradient\")\r\ndeclare function disposeCanvasGradient(id: i32): void;\r\n\r\n/**\r\n * The CanvasGradient interface represents an opaque object describing a gradient. It is returned\r\n * by the methods CanvasRenderingContext2D.createLinearGradient() or\r\n * CanvasRenderingContext2D.createRadialGradient().\r\n *\r\n * It can be used as a fillGradient or strokeGradient.\r\n */\r\nexport class CanvasGradient {\r\n  private id: i32 = -1;\r\n\r\n  /**\r\n   * The CanvasGradient.addColorStop() method adds a new color stop, defined by an offset and a\r\n   * color, to a given canvas gradient.\r\n   *\r\n   * @param {f64} offset - A number between 0 and 1, inclusive, representing the position of the\r\n   * color stop. 0 represents the start of the gradient and 1 represents the end; an INDEX_SIZE_ERR\r\n   * is raised if the number is outside that range. This number is clamped to the inclusive [0,1]\r\n   * range before it is passed to the browser.\r\n   * @param {string} color - A CSS <color> value representing the color of the stop. A SYNTAX_ERR is\r\n   * raised if the value cannot be parsed as a CSS <color> value.\r\n   */\r\n  public addColorStop(offset: f64, color: string): void {\r\n    addColorStop(this.id, max<f64>(min(offset, 0.0), 1.0), color);\r\n  }\r\n\r\n  /**\r\n   * This method frees the CanvasGradient from the host's gradient index.\r\n   */\r\n  public dispose(): void {\r\n    disposeCanvasGradient(this.id);\r\n  }\r\n}","// @ts-ignore\r\n@external(\"__canvas_sys\", \"disposeCanvasPattern\")\r\ndeclare function disposeCanvasPattern(id: i32): void;\r\n\r\n/**\r\n * The CanvasPattern interface represents an opaque object describing a pattern, based on an image,\r\n * a canvas, or a video, created by the CanvasRenderingContext2D.createPattern() method.\r\n */\r\nexport class CanvasPattern {\r\n  private id: i32 = -1;\r\n\r\n\r\n  /**\r\n   * This method frees the CanvasPattern from the host's pattern index.\r\n   */\r\n  public dispose(): void {\r\n    disposeCanvasPattern(this.id);\r\n  }\r\n}\r\n","import { itoa, dtoa } from \"./util/number\";\r\nimport { strtol } from \"./util/string\";\r\n\r\n// @ts-ignore: decorator\r\n@builtin @inline\r\nexport const NaN: f64 = 0 / 0;\r\n\r\n// @ts-ignore: decorator\r\n@builtin @inline\r\nexport const Infinity: f64 = 1 / 0;\r\n\r\nexport function isNaN<T extends number>(value: T): bool {\r\n  if (!isFloat<T>()) {\r\n    if (!isInteger<T>()) ERROR(\"numeric type expected\");\r\n  }\r\n  return value != value;\r\n}\r\n\r\nexport function isFinite<T extends number>(value: T): bool {\r\n  if (!isFloat<T>()) {\r\n    if (!isInteger<T>()) ERROR(\"numeric type expected\");\r\n  }\r\n  return value - value == 0;\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class I8 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): i8 {\r\n    return <i8>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: i8): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class I16 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): i16 {\r\n    return <i16>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: i16): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class I32 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): i32 {\r\n    return <i32>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: i32): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class I64 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): i64 {\r\n    return strtol<i64>(value, radix);\r\n  }\r\n\r\n  toString(this: i64): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class Isize {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): isize {\r\n    return <isize>strtol<i64>(value, radix);\r\n  }\r\n\r\n  toString(this: isize): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class U8 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): u8 {\r\n    return <u8>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: u8): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class U16 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): u16 {\r\n    return <u16>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: u16): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class U32 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): u32 {\r\n    return <u32>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: u32): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class U64 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): u64 {\r\n    return <u64>strtol<i64>(value, radix);\r\n  }\r\n\r\n  toString(this: u64): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class Usize {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): usize {\r\n    return <usize>strtol<i64>(value, radix);\r\n  }\r\n\r\n  toString(this: usize): String {\r\n    // TODO: radix\r\n    return itoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class Bool {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\r\n\r\n  toString(this: bool): String {\r\n    // TODO: radix?\r\n    return this ? \"true\" : \"false\";\r\n  }\r\n}\r\n\r\nexport { Bool as Boolean };\r\n\r\n@sealed @unmanaged\r\nexport abstract class F32 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly EPSILON: f32 = f32.EPSILON;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly POSITIVE_INFINITY: f32 = Infinity;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly NEGATIVE_INFINITY: f32 = -Infinity;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly NaN: f32 = NaN;\r\n\r\n  static isNaN(value: f32): bool {\r\n    return isNaN<f32>(value);\r\n  }\r\n\r\n  static isFinite(value: f32): bool {\r\n    return isFinite<f32>(value);\r\n  }\r\n\r\n  static isSafeInteger(value: f32): bool {\r\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\r\n  }\r\n\r\n  static isInteger(value: f32): bool {\r\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\r\n  }\r\n\r\n  static parseInt(value: string, radix: i32 = 0): f32 {\r\n    return <f32>strtol<i64>(value, radix);\r\n  }\r\n\r\n  static parseFloat(value: string): f32 {\r\n    return <f32>parseFloat(value);\r\n  }\r\n\r\n  toString(this: f32): String {\r\n    // TODO: radix\r\n    return dtoa(this);\r\n  }\r\n}\r\n\r\n@sealed @unmanaged\r\nexport abstract class F64 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly EPSILON: f64 = f64.EPSILON;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly POSITIVE_INFINITY: f64 = Infinity;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly NEGATIVE_INFINITY: f64 = -Infinity;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly NaN: f64 = NaN;\r\n\r\n  static isNaN(value: f64): bool {\r\n    return isNaN<f64>(value);\r\n  }\r\n\r\n  static isFinite(value: f64): bool {\r\n    return isFinite<f64>(value);\r\n  }\r\n\r\n  static isSafeInteger(value: f64): bool {\r\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\r\n  }\r\n\r\n  static isInteger(value: f64): bool {\r\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\r\n  }\r\n\r\n  static parseInt(value: string, radix: i32 = 0): f64 {\r\n    return <f64>strtol<i64>(value, radix);\r\n  }\r\n\r\n  static parseFloat(value: string): f64 {\r\n    return parseFloat(value);\r\n  }\r\n\r\n  toString(this: f64, radix: i32 = 0): String {\r\n    // TODO: radix\r\n    return dtoa(this);\r\n  }\r\n}\r\n\r\nexport { F64 as Number };\r\n"]}
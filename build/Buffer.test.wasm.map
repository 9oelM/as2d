{"version":3,"sources":["~lib/internal/allocator.ts","~lib/internal/arraybuffer.ts","assembly/renderer/CanvasRenderingContext2D.ts","~lib/memory.ts","~lib/allocator/arena.ts","~lib/map.ts","~lib/arraybuffer.ts","~lib/internal/memory.ts","assembly/internal/getContext.ts","assembly/internal/Buffer.ts","src/shared/CanvasDirection.ts","~lib/internal/hash.ts","~lib/internal/string.ts","~lib/string.ts","assembly/renderer/Image.ts","assembly/Buffer.test.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["/** Number of alignment bits. */\r\nexport const AL_BITS: u32 = 3;\r\n/** Number of possible alignment values. */\r\nexport const AL_SIZE: usize = 1 << <usize>AL_BITS;\r\n/** Mask to obtain just the alignment bits. */\r\nexport const AL_MASK: usize = AL_SIZE - 1;\r\n/** Maximum 32-bit allocation size. */\r\nexport const MAX_SIZE_32: usize = 1 << 30; // 1GB\r\n","import {\r\n  AL_MASK,\r\n  MAX_SIZE_32\r\n } from \"./allocator\";\r\n\r\n/** Size of an ArrayBuffer header. */\r\nexport const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\r\n/** Maximum byte length of an ArrayBuffer. */\r\nexport const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\r\n\r\nfunction computeSize(byteLength: i32): usize {\r\n  // round up to power of 2, with HEADER_SIZE=8:\r\n  // 0            -> 2^3  = 8\r\n  // 1..8         -> 2^4  = 16\r\n  // 9..24        -> 2^5  = 32\r\n  // ...\r\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\r\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\r\n}\r\n\r\n// Low-level utility\r\n\r\nfunction __gc(ref: usize): void {}\r\n\r\nexport function allocateUnsafe(byteLength: i32): ArrayBuffer {\r\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\r\n  var buffer: usize;\r\n  if (isManaged<ArrayBuffer>()) {\r\n    buffer = __gc_allocate(computeSize(byteLength), __gc); // tslint:disable-line\r\n  } else {\r\n    buffer = memory.allocate(computeSize(byteLength));\r\n  }\r\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n  return changetype<ArrayBuffer>(buffer);\r\n}\r\n\r\nexport function reallocateUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\r\n  var oldByteLength = buffer.byteLength;\r\n  if (newByteLength > oldByteLength) {\r\n    assert(newByteLength <= MAX_BLENGTH);\r\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\r\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n    } else { // slow path: copy to new buffer\r\n      let newBuffer = allocateUnsafe(newByteLength);\r\n      memory.copy(\r\n        changetype<usize>(newBuffer) + HEADER_SIZE,\r\n        changetype<usize>(buffer) + HEADER_SIZE,\r\n        <usize>oldByteLength\r\n      );\r\n      if (!isManaged<ArrayBuffer>()) {\r\n        memory.free(changetype<usize>(buffer));\r\n      }\r\n      buffer = newBuffer;\r\n    }\r\n    memory.fill(\r\n      changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\r\n      0,\r\n      <usize>(newByteLength - oldByteLength)\r\n    );\r\n  } else if (newByteLength < oldByteLength) { // fast path: override size\r\n    // TBD: worth to copy and release if size is significantly less than before?\r\n    assert(newByteLength >= 0);\r\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n  }\r\n  return buffer;\r\n}\r\n\r\n// The helpers below use two different types in order to emit loads and stores that load respectively\r\n// store one type to/from memory while returning/taking the desired output/input type. This allows to\r\n// emit instructions like\r\n//\r\n// * `i32.load8` ^= `<i32>load<i8>(...)` that reads an i8 but returns an i32, or\r\n// * `i64.load32_s` ^= `<i64>load<i32>(...)`) that reads a 32-bit as a 64-bit integer\r\n//\r\n// without having to emit an additional instruction for conversion purposes. The second parameter\r\n// can be omitted for references and other loads and stores that simply return the exact type.\r\n\r\n@inline export function LOAD<T,TOut = T>(buffer: ArrayBuffer, index: i32, byteOffset: i32 = 0): TOut {\r\n  return <TOut>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, HEADER_SIZE);\r\n}\r\n\r\n@inline export function STORE<T,TIn = T>(buffer: ArrayBuffer, index: i32, value: TIn, byteOffset: i32 = 0): void {\r\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, value, HEADER_SIZE);\r\n}\r\n","import { CanvasInstruction } from \"../../src/shared/CanvasInstruction\";\r\nimport { Buffer } from \"../internal/Buffer\";\r\nimport { LOAD, STORE } from \"internal/arraybuffer\";\r\nimport { DOMMatrix } from \"./DOMMatrix\";\r\nimport { CanvasDirection } from \"../../src/shared/CanvasDirection\";\r\nimport { CanvasPattern } from \"./CanvasPattern\";\r\nimport { CanvasGradient } from \"./CanvasGradient\";\r\nimport { Image } from \"./Image\";\r\nimport { CanvasPatternRepetition } from \"../../src/shared/CanvasPatternRepetition\";\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"createLinearGradient\")\r\ndeclare function createLinearGradient(id: i32, x0: f64, y0: f64, x1: f64, y1: f64): i32;\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"createRadialGradient\")\r\ndeclare function createRadialGradient(id: i32, x0: f64, y0: f64, r0: f64, x1: f64, y1: f64, r1: f64): i32;\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"createPattern\")\r\ndeclare function createPattern(ctxid: i32, imageid: i32, repetition: CanvasPatternRepetition): i32;\r\n\r\nconst enum StrokeFillStyleType {\r\n  String,\r\n  CanvasPattern,\r\n  CanvasGradient,\r\n}\r\n\r\nconst defaultBlack: string = \"#000\";\r\nconst defaultNone: string = \"none\";\r\nconst defaultFont: string = \"10px sans-serif\";\r\n\r\n//#region ARRAYBUFFERINITIALIZER\r\n/**\r\n * Utility function for setting the given ArrayBuffer to the identity 2d transform matrix inline.\r\n *\r\n * @param ArrayBuffer buff\r\n */\r\n@inline\r\nfunction setArrayBufferIdentity(buff: ArrayBuffer): ArrayBuffer {\r\n  STORE<f64>(buff, 0, 1.0);\r\n  STORE<f64>(buff, 1, 0.0);\r\n  STORE<f64>(buff, 2, 0.0);\r\n  STORE<f64>(buff, 3, 1.0);\r\n  STORE<f64>(buff, 4, 0.0);\r\n  STORE<f64>(buff, 5, 0.0);\r\n  return buff;\r\n}\r\n\r\n/**\r\n * Utility function for setting the given ArrayBuffer's first value to the specified value inline.\r\n * \r\n * @param ArrayBuffer buff\r\n * @param T value\r\n */\r\n@inline\r\nfunction setArrayBufferValue<T>(buff: ArrayBuffer, value: T): ArrayBuffer {\r\n  STORE<T>(buff, 0, value);\r\n  return buff;\r\n}\r\n\r\n/**\r\n * Utility function for setting the given ArrayBuffer's first value to the specified value inline.\r\n *\r\n * @param ArrayBuffer buff\r\n * @param T value\r\n */\r\n@inline\r\nfunction setArrayBufferValue2<T>(buff: ArrayBuffer, a: T, b: T): ArrayBuffer {\r\n  STORE<T>(buff, 0, a);\r\n  STORE<T>(buff, 1, b);\r\n  return buff;\r\n}\r\n//#endregion ARRAYBUFFERINITIALIZER\r\n\r\n/**\r\n * An AssemblyScript virtual representation of an actual CanvasRenderingContext2D Object. The\r\n * CanvasRenderingContext2D interface, part of the Canvas API, provides the 2D rendering context\r\n * for the drawing surface of a <canvas> element. It is used for drawing shapes, text, images, and\r\n * other objects.\r\n */\r\nexport class CanvasRenderingContext2D extends Buffer<CanvasInstruction> {\r\n  /**\r\n   * The component's external object id. It initializes to -1, which will never be an actual object\r\n   * id externally. If it actually returns -1, it will cause the host to error saying it cannot\r\n   * find the specified canvas context.\r\n   */\r\n  private id: i32 = -1;\r\n\r\n  /**\r\n   * The virutal stack index offset that keeps track of the number of `save()` and `restore()`\r\n   * stack states.\r\n   */\r\n  private _stackOffset: u8 = <u8>0;\r\n\r\n  //#region CREATELINEARGRADIENT\r\n  /**\r\n   * The CanvasRenderingContext2D.createLinearGradient() method of the Canvas 2D API creates a\r\n   * gradient along the line connecting two given coordinates.\r\n   *\r\n   * @param {f64} x0 - A float number representing the first x coordinate point of the gradient.\r\n   * @param {f64} y0 - A float number representing the first y coordinate point of the gradient.\r\n   * @param {f64} x1 - A float number representing the second x coordinate point of the gradient.\r\n   * @param {f64} y1 - A float number representing the second y coordinate point of the gradient.\r\n   */\r\n  public createLinearGradient(x0: f64, y0: f64, x1: f64, y1: f64): CanvasGradient {\r\n    var id: i32 = createLinearGradient(this.id, x0, y0, x1, y1);\r\n    var result: CanvasGradient = new CanvasGradient();\r\n    store<i32>(changetype<usize>(result) + offsetof<CanvasGradient>(\"id\"), id);\r\n    return result;\r\n  }\r\n  //#endregion CREATELINEARGRADIENT\r\n\r\n  //#region CREATERADIALGRADIENT\r\n  /**\r\n   * The CanvasRenderingContext2D.createRadialGradient() method of the Canvas 2D API creates a\r\n   * radial gradient using the size and coordinates of two circles.\r\n   *\r\n   * @param {f64} x0 - The x-axis coordinate of the start circle.\r\n   * @param {f64} y0 - The y-axis coordinate of the start circle.\r\n   * @param {f64} r0 - The radius of the start circle. Must be non-negative and finite.\r\n   * @param {f64} x1 - The x-axis coordinate of the end circle.\r\n   * @param {f64} y1 - The y-axis coordinate of the end circle.\r\n   * @param {f64} r1 - The radius of the end circle. Must be non-negative and finite.\r\n   */\r\n  public createRadialGradient(x0: f64, y0: f64, r0: f64, x1: f64, y1: f64, r1: f64): CanvasGradient {\r\n    var id: i32 = createRadialGradient(this.id, x0, y0, r0, x1, y1, r1);\r\n    var result: CanvasGradient = new CanvasGradient();\r\n    store<i32>(changetype<usize>(result) + offsetof<CanvasGradient>(\"id\"), id);\r\n    return result;\r\n  }\r\n  //#endregion CREATERADIALGRADIENT\r\n\r\n  //#region TRANSFORM\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of transforms. Each transform value is a set of 6 numbers\r\n   * stored in a repeated pattern of [a0, b0, c0, d0, e0, f0, a1, b1, c1, d1, e1, f1\r\n   */\r\n  private _transformStack: ArrayBuffer = setArrayBufferIdentity(new ArrayBuffer(0xFF * 6 * 8));\r\n\r\n  /**\r\n   * An ArrayBuffer that contains a single transform value that represents the last transform\r\n   * written by a `setTransform()` operation\r\n   */\r\n  private _transformCurrent: ArrayBuffer = setArrayBufferIdentity(new ArrayBuffer(6));\r\n\r\n  /**\r\n   * An operation that generates a DOMMatrix reflecting the current transform on the `_transformStack\r\n   */\r\n  @inline\r\n  private _getTransform(): DOMMatrix {\r\n    var result: DOMMatrix = new DOMMatrix();\r\n    var index: i32 = 6 * <i32>this._stackOffset;\r\n    var current: ArrayBuffer = this._transformStack;\r\n    result.m11 = LOAD<f64>(current, index);\r\n    result.m12 = LOAD<f64>(current, index + 1);\r\n    result.m21 = LOAD<f64>(current, index + 2);\r\n    result.m22 = LOAD<f64>(current, index + 3);\r\n    result.m41 = LOAD<f64>(current, index + 4);\r\n    result.m42 = LOAD<f64>(current, index + 5);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * An operation that sets the current transform on the `_transformStack` to the specified\r\n   * DOMMatrix values.\r\n   *\r\n   * @param {f64} a - The a property of the transform matrix.\r\n   * @param {f64} b - The b property of the transform matrix.\r\n   * @param {f64} c - The c property of the transform matrix.\r\n   * @param {f64} d - The d property of the transform matrix.\r\n   * @param {f64} e - The e property of the transform matrix.\r\n   * @param {f64} f - The f property of the transform matrix.\r\n   */\r\n  @inline\r\n  private _setTransform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    var index: i32 = 6 * <i32>this._stackOffset;\r\n    var current: ArrayBuffer = this._transformStack;\r\n    STORE<f64>(current, index, a);\r\n    STORE<f64>(current, index + 1, b);\r\n    STORE<f64>(current, index + 2, c);\r\n    STORE<f64>(current, index + 3, d);\r\n    STORE<f64>(current, index + 4, e);\r\n    STORE<f64>(current, index + 5, f);\r\n  }\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.currentTransform property of the Canvas 2D API returns or sets a\r\n   * DOMMatrix (current specification) object for the current transformation matrix\r\n  */\r\n  public get currentTransform(): DOMMatrix {\r\n    return this._getTransform();\r\n  }\r\n\r\n  public set currentTransform(value: DOMMatrix) {\r\n    this._setTransform(value.m11, value.m12, value.m21, value.m22, value.m41, value.m42);\r\n  }\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.getTransform() method of the Canvas 2D API gets the current\r\n   * transformation matrix, and returns a DOMMatrix\r\n   */\r\n  public getTransform(): DOMMatrix {\r\n    return this._getTransform();\r\n  }\r\n  //#endregion TRANSFORM\r\n\r\n  //#region DIRECTION\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of CanvasDirection values, stored as `i32` values\r\n   */\r\n  private _directionStack: ArrayBuffer\r\n    = setArrayBufferValue<CanvasDirection>(new ArrayBuffer(0xFF * 4), CanvasDirection.inherit);\r\n\r\n  /**\r\n   * A private member that contains a single CanvasDirection value that represents the last\r\n   * CanvasDirection value written by a drawing operation\r\n   */\r\n  private _currentDirection: CanvasDirection = CanvasDirection.inherit;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.direction property of the Canvas 2D API specifies the current text\r\n   * direction used to draw text\r\n   */\r\n  public get direction(): CanvasDirection {\r\n    return LOAD<CanvasDirection>(this._directionStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set direction(value: CanvasDirection) {\r\n    STORE<CanvasDirection>(this._directionStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function call that writes the current CanvasDirection value on the _directionStack\r\n   * if it currently does not match the last written CanvasDirection\r\n   */\r\n  @inline\r\n  private _updateDirection(): void {\r\n    var value: CanvasDirection = LOAD<CanvasDirection>(this._directionStack, <i32>this._stackOffset);\r\n    if (value != this._currentDirection) {\r\n      this._currentDirection = value;\r\n      this.write_one(CanvasInstruction.Direction, <f64>value);\r\n    }\r\n  }\r\n  //#endregion DIRECTION\r\n\r\n  //#region FILLSTYLE\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of 2 i32 values. For each fillStyle, if the fillStyle is\r\n   * a string, the second i32 value will be a pointer, otherwise, it's an `<i32>` representing the\r\n   * style's objectID\r\n   */\r\n  private _fillStyleStack: ArrayBuffer = setArrayBufferValue2<i32>(\r\n    new ArrayBuffer(0xFF * 4 * 2),\r\n    <i32>StrokeFillStyleType.String,\r\n    <i32>changetype<usize>(defaultBlack),\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single StrokeFillStyleType value that represents the last\r\n   * fillStyle value written by a drawing operation\r\n   */\r\n  private _currentFillStyleType: StrokeFillStyleType = StrokeFillStyleType.String;\r\n\r\n  /**\r\n   * A private member that contains a single pointer or id value that represents the last\r\n   * fillStyle value written by a drawing operation\r\n   */\r\n  private _currentFillStyleValue: i32 = <i32>changetype<usize>(defaultBlack);\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.fillStyle property of the Canvas 2D API specifies the current text\r\n   * representing a CSS Color\r\n   */\r\n  public get fillStyle(): string | null {\r\n    var index: i32 = this._stackOffset * 2;\r\n    var fillStyleType: StrokeFillStyleType = <StrokeFillStyleType>LOAD<i32>(\r\n      this._fillStyleStack,\r\n      index,\r\n    );\r\n    if (fillStyleType == StrokeFillStyleType.String, \"current fillStyle is not a string\") {\r\n      return changetype<string>(<usize>LOAD<i32>(this._fillStyleStack, index + 1));\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public set fillStyle(value: string | null) {\r\n    if (value == null) value = defaultBlack;\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._fillStyleStack;\r\n    STORE<i32>(buff, index, StrokeFillStyleType.String);\r\n    STORE<i32>(buff, index + 1, <i32>changetype<usize>(value));\r\n  }\r\n\r\n  /**\r\n   * An internal function call that writes the current fillStyle value on the _fillStyleStack\r\n   * if it currently does not match the last written fillStyle.\r\n   */\r\n  @inline\r\n  private _updateFillStyle(): void {\r\n    var buff: ArrayBuffer = this._fillStyleStack;\r\n    var index: i32 = <i32>this._stackOffset * 2;\r\n    var styleType: StrokeFillStyleType = <StrokeFillStyleType>LOAD<i32>(buff, index);\r\n    var value: i32 = LOAD<i32>(buff, index + 1);\r\n    if (styleType != this._currentFillStyleType || value != this._currentFillStyleValue) {\r\n      var inst: CanvasInstruction\r\n      if (styleType == StrokeFillStyleType.String) inst = CanvasInstruction.FillStyle;\r\n      else if (styleType == StrokeFillStyleType.CanvasGradient) inst = CanvasInstruction.FillGradient;\r\n      else inst = CanvasInstruction.FillPattern;\r\n      this.write_one(inst, <f64>value);\r\n    }\r\n  }\r\n  //#endregion FILLSTYLE\r\n\r\n  //#region FILLPATTERN\r\n  /**\r\n   * The CanvasRenderingContext2D.fillPattern property of the Canvas 2D API specifies the current\r\n   * fillStyle pattern\r\n   */\r\n  public get fillPattern(): CanvasPattern | null {\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._fillStyleStack;\r\n    var fillStyleType: StrokeFillStyleType = <StrokeFillStyleType>LOAD<i32>(\r\n      buff,\r\n      index,\r\n    );\r\n\r\n    if (fillStyleType == StrokeFillStyleType.CanvasPattern) {\r\n      var result: CanvasPattern = new CanvasPattern();\r\n      store<i32>(\r\n        changetype<usize>(result) + offsetof<CanvasPattern>(\"id\"),\r\n        LOAD<i32>(buff, index + 1),\r\n      );\r\n      return result;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  public set fillPattern(value: CanvasPattern | null) {\r\n    if (value == null) {\r\n      this.fillStyle = defaultBlack;\r\n      return;\r\n    }\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._fillStyleStack;\r\n    STORE<i32>(buff, index, StrokeFillStyleType.CanvasPattern);\r\n    STORE<i32>(buff, index + 1, load<i32>(changetype<usize>(value) + offsetof<CanvasPattern>(\"id\")));\r\n  }\r\n  //#endregion FILLPATTERN\r\n\r\n  //#region FILLGRADIENT\r\n  /**\r\n   * The CanvasRenderingContext2D.fillGradient property of the Canvas 2D API specifies the current\r\n   * fillStyle gradient\r\n   */\r\n  public get fillGradient(): CanvasGradient | null {\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._fillStyleStack;\r\n    var fillStyleType: StrokeFillStyleType = <StrokeFillStyleType>LOAD<i32>(\r\n      buff,\r\n      index,\r\n    );\r\n    if (fillStyleType == StrokeFillStyleType.CanvasGradient) {\r\n      var result: CanvasGradient = new CanvasGradient();\r\n      store<i32>(\r\n        changetype<usize>(result) + offsetof<CanvasGradient>(\"id\"),\r\n        LOAD<i32>(buff, index + 1),\r\n      );\r\n      return result;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  public set fillGradient(value: CanvasGradient | null) {\r\n    if (value == null) {\r\n      this.fillStyle = defaultBlack;\r\n      return;\r\n    }\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._fillStyleStack;\r\n    STORE<i32>(buff, index, StrokeFillStyleType.CanvasGradient);\r\n    STORE<i32>(buff, index + 1, load<i32>(changetype<usize>(value) + offsetof<CanvasGradient>(\"id\")));\r\n  }\r\n  //#endregion FILLGRADIENT\r\n\r\n  //#region CREATEPATTERN\r\n  /**\r\n   * The CanvasRenderingContext2D.createPattern() method of the Canvas 2D API creates a pattern\r\n   * using the specified image and repetition.\r\n   *\r\n   * @param {Image} img - A CanvasImageSource to be used as the pattern's Image.\r\n   * @param {CanvasPatternRepetition} repetition - An enum value indicating how to repeat the pattern's image.\r\n   */\r\n  public createPattern(img: Image, repetition: CanvasPatternRepetition): CanvasPattern {\r\n    var result = new CanvasPattern();\r\n    var id: i32 = load<i32>(changetype<usize>(img) + offsetof<Image>(\"_id\"));\r\n    store<i32>(changetype<usize>(result) + offsetof<CanvasPattern>(\"id\"), createPattern(this.id, id, repetition));\r\n    return result;\r\n  }\r\n  //#endregion CREATEPATTERN\r\n\r\n  //#region FILTER\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of string pointer values.\r\n   */\r\n  private _filterStack: ArrayBuffer = setArrayBufferValue(\r\n    new ArrayBuffer(0xFF * sizeof<usize>()),\r\n    changetype<usize>(defaultNone),\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single string value that represents the last\r\n   * filter value written by a drawing operation.\r\n   */\r\n  private _currentFilter: string = defaultNone;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.filter property of the Canvas 2D API provides filter effects such\r\n   * as blurring and grayscaling. It is similar to the CSS filter property and accepts the same\r\n   * values.\r\n   */\r\n  public get filter(): string {\r\n    return changetype<string>(LOAD<usize>(this._filterStack, <i32>this._stackOffset));\r\n  }\r\n\r\n  public set filter(value: string) {\r\n    STORE<usize>(this._filterStack, <i32>this._stackOffset, changetype<usize>(value));\r\n  }\r\n\r\n  /**\r\n   * An internal function call that writes the current filter value on the _filterStack\r\n   * if it currently does not match the last written filter string value.\r\n   */\r\n  @inline\r\n  private _updateFilter(): void {\r\n    var value: string = changetype<string>(LOAD<usize>(this._filterStack, <i32>this._stackOffset));\r\n    if (value != this._currentFilter) {\r\n      this._currentFilter = value;\r\n      this.write_one(CanvasInstruction.Filter, changetype<usize>(value));\r\n    }\r\n  }\r\n  //#endregion FILTER\r\n\r\n  //#region FONT\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of string pointer values.\r\n   */\r\n  private _fontStack: ArrayBuffer = setArrayBufferValue(\r\n    new ArrayBuffer(0xFF * sizeof<usize>()),\r\n    changetype<usize>(defaultFont),\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single string value that represents the last\r\n   * font value written by a drawing operation.\r\n   */\r\n  private _currentFont: string = defaultFont;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.font property of the Canvas 2D API specifies the current text\r\n   * style to use when drawing text. This string uses the same syntax as the CSS font specifier.\r\n   */\r\n  public get font(): string {\r\n    return changetype<string>(LOAD<usize>(this._fontStack, <i32>this._stackOffset));\r\n  }\r\n\r\n  public set font(value: string) {\r\n    STORE<usize>(this._fontStack, <i32>this._stackOffset, changetype<usize>(value));\r\n  }\r\n\r\n  /**\r\n   * An internal function call that writes the current font value on the _fontStack\r\n   * if it currently does not match the last written font string value.\r\n   */\r\n  @inline\r\n  private _updateFont(): void {\r\n    var value: string = changetype<string>(LOAD<usize>(this._fontStack, <i32>this._stackOffset));\r\n    if (value != this._currentFont) {\r\n      this._currentFont = value;\r\n      this.write_one(CanvasInstruction.Font, changetype<usize>(value));\r\n    }\r\n  }\r\n  //#endregion FONT\r\n}\r\n","import { memcmp, memmove, memset } from \"./internal/memory\";\r\n\r\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\r\n\r\n/* tslint:disable */\r\n\r\nexport namespace memory {\r\n\r\n  @builtin export declare function size(): i32;\r\n\r\n  @builtin export declare function grow(pages: i32): i32;\r\n\r\n  @inline export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n    if (isDefined(__memory_fill)) { __memory_fill(dest, c, n); return; }\r\n    memset(dest, c, n);\r\n  }\r\n\r\n  @inline export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n    if (isDefined(__memory_copy)) { __memory_copy(dest, src, n); return; }\r\n    memmove(dest, src, n);\r\n  }\r\n\r\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\r\n    if (isDefined(__memory_compare)) return __memory_compare(vl, vr, n);\r\n    return memcmp(vl, vr, n);\r\n  }\r\n\r\n  // Passive segments\r\n\r\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\r\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\r\n  // }\r\n\r\n  // export function drop(segmentIndex: u32): void {\r\n  //   __memory_drop(segmentIndex);\r\n  // }\r\n\r\n  // Allocator\r\n\r\n  @inline export function allocate(size: usize): usize {\r\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\r\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\r\n    return <usize>unreachable();\r\n  }\r\n\r\n  @inline export function free(ptr: usize): void {\r\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\r\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\r\n    unreachable();\r\n  }\r\n\r\n  @inline export function reset(): void {\r\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\r\n    unreachable();\r\n  }\r\n}\r\n","/**\r\n * Arena Memory Allocator\r\n *\r\n * Provides a `memory.reset` function to reset the heap to its initial state. A user has to make\r\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\r\n *\r\n * @module std/assembly/allocator/arena\r\n *//***/\r\n\r\nimport { AL_MASK, MAX_SIZE_32 } from \"../internal/allocator\";\r\n\r\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\r\nvar offset: usize = startOffset;\r\n\r\n// Memory allocator interface\r\n\r\n@global export function __memory_allocate(size: usize): usize {\r\n  if (size > MAX_SIZE_32) unreachable();\r\n  var ptr = offset;\r\n  var newPtr = (ptr + max<usize>(size, 1) + AL_MASK) & ~AL_MASK;\r\n  var pagesBefore = memory.size();\r\n  if (newPtr > <usize>pagesBefore << 16) {\r\n    let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\r\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\r\n    if (memory.grow(pagesWanted) < 0) {\r\n      if (memory.grow(pagesNeeded) < 0) {\r\n        unreachable(); // out of memory\r\n      }\r\n    }\r\n  }\r\n  offset = newPtr;\r\n  return ptr;\r\n}\r\n\r\n@global export function __memory_free(ptr: usize): void { /* nop */ }\r\n\r\n@global export function __memory_reset(): void {\r\n  offset = startOffset;\r\n}\r\n","import {\r\n  HEADER_SIZE as HEADER_SIZE_AB\r\n} from \"./internal/arraybuffer\";\r\n\r\nimport {\r\n  HASH\r\n} from \"./internal/hash\";\r\n\r\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\r\n\r\nconst INITIAL_CAPACITY = 4;\r\nconst FILL_FACTOR: f64 = 8 / 3;\r\nconst FREE_FACTOR: f64 = 3 / 4;\r\n\r\n/** Structure of a map entry. */\r\n@unmanaged class MapEntry<K,V> {\r\n  key: K;\r\n  value: V;\r\n  taggedNext: usize; // LSB=1 indicates EMPTY\r\n}\r\n\r\n/** Empty bit. */\r\nconst EMPTY: usize = 1 << 0;\r\n\r\n/** Size of a bucket. */\r\nconst BUCKET_SIZE = sizeof<usize>();\r\n\r\n/** Computes the alignment of an entry. */\r\n@inline function ENTRY_ALIGN<K,V>(): usize {\r\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\r\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\r\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\r\n  return align;\r\n}\r\n\r\n/** Computes the aligned size of an entry. */\r\n@inline function ENTRY_SIZE<K,V>(): usize {\r\n  const align = ENTRY_ALIGN<K,V>();\r\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\r\n  return size;\r\n}\r\n\r\nexport class Map<K,V> {\r\n\r\n  // buckets holding references to the respective first entry within\r\n  private buckets: ArrayBuffer; // usize[bucketsMask + 1]\r\n  private bucketsMask: u32;\r\n\r\n  // entries in insertion order\r\n  private entries: ArrayBuffer; // MapEntry<K,V>[entriesCapacity]\r\n  private entriesCapacity: i32;\r\n  private entriesOffset: i32;\r\n  private entriesCount: i32;\r\n\r\n  get size(): i32 { return this.entriesCount; }\r\n\r\n  constructor() { this.clear(); }\r\n\r\n  clear(): void {\r\n    const bucketsSize = INITIAL_CAPACITY * <i32>BUCKET_SIZE;\r\n    this.buckets = new ArrayBuffer(bucketsSize);\r\n    this.bucketsMask = INITIAL_CAPACITY - 1;\r\n    const entriesSize = INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>();\r\n    this.entries = new ArrayBuffer(entriesSize, true);\r\n    this.entriesCapacity = INITIAL_CAPACITY;\r\n    this.entriesOffset = 0;\r\n    this.entriesCount = 0;\r\n  }\r\n\r\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\r\n    var entry = load<MapEntry<K,V>>(\r\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE,\r\n      HEADER_SIZE_AB\r\n    );\r\n    while (entry) {\r\n      if (!(entry.taggedNext & EMPTY) && entry.key == key) return entry;\r\n      entry = changetype<MapEntry<K,V>>(entry.taggedNext & ~EMPTY);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  has(key: K): bool {\r\n    return this.find(key, HASH<K>(key)) !== null;\r\n  }\r\n\r\n  get(key: K): V {\r\n    var entry = this.find(key, HASH<K>(key));\r\n    return entry ? entry.value : <V>unreachable();\r\n  }\r\n\r\n  set(key: K, value: V): void {\r\n    var hashCode = HASH<K>(key);\r\n    var entry = this.find(key, hashCode);\r\n    if (entry) {\r\n      entry.value = value;\r\n    } else {\r\n      // check if rehashing is necessary\r\n      if (this.entriesOffset == this.entriesCapacity) {\r\n        this.rehash(\r\n          this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\r\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\r\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\r\n        );\r\n      }\r\n      // append new entry\r\n      let entries = this.entries;\r\n      entry = changetype<MapEntry<K,V>>(\r\n        changetype<usize>(entries) + HEADER_SIZE_AB + this.entriesOffset++ * ENTRY_SIZE<K,V>()\r\n      );\r\n      entry.key = key;\r\n      entry.value = value;\r\n      ++this.entriesCount;\r\n      // link with previous entry in bucket\r\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\r\n      entry.taggedNext = load<usize>(bucketPtrBase, HEADER_SIZE_AB);\r\n      store<usize>(bucketPtrBase, changetype<usize>(entry), HEADER_SIZE_AB);\r\n      if (isManaged<K>()) __gc_link(changetype<usize>(this), changetype<usize>(key)); // tslint:disable-line\r\n      if (isManaged<V>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\r\n    }\r\n  }\r\n\r\n  delete(key: K): bool {\r\n    var entry = this.find(key, HASH<K>(key));\r\n    if (!entry) return false;\r\n    entry.taggedNext |= EMPTY;\r\n    --this.entriesCount;\r\n    // check if rehashing is appropriate\r\n    var halfBucketsMask = this.bucketsMask >> 1;\r\n    if (\r\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\r\n      this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\r\n    ) this.rehash(halfBucketsMask);\r\n    return true;\r\n  }\r\n\r\n  private rehash(newBucketsMask: u32): void {\r\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\r\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\r\n    var newEntriesCapacity = <i32>(newBucketsCapacity * FILL_FACTOR);\r\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>(), true);\r\n\r\n    // copy old entries to new entries\r\n    var oldPtr = changetype<usize>(this.entries) + HEADER_SIZE_AB;\r\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\r\n    var newPtr = changetype<usize>(newEntries) + HEADER_SIZE_AB;\r\n    while (oldPtr != oldEnd) {\r\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\r\n      if (!(oldEntry.taggedNext & EMPTY)) {\r\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\r\n        newEntry.key = oldEntry.key;\r\n        newEntry.value = oldEntry.value;\r\n        let newBucketIndex = HASH<K>(oldEntry.key) & newBucketsMask;\r\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\r\n        newEntry.taggedNext = load<usize>(newBucketPtrBase, HEADER_SIZE_AB);\r\n        store<usize>(newBucketPtrBase, newPtr, HEADER_SIZE_AB);\r\n        newPtr += ENTRY_SIZE<K,V>();\r\n      }\r\n      oldPtr += ENTRY_SIZE<K,V>();\r\n    }\r\n\r\n    this.buckets = newBuckets;\r\n    this.bucketsMask = newBucketsMask;\r\n    this.entries = newEntries;\r\n    this.entriesCapacity = newEntriesCapacity;\r\n    this.entriesOffset = this.entriesCount;\r\n  }\r\n\r\n  toString(): string {\r\n    return \"[object Map]\";\r\n  }\r\n\r\n  private __gc(): void {\r\n    __gc_mark(changetype<usize>(this.buckets)); // tslint:disable-line\r\n    var entries = this.entries;\r\n    __gc_mark(changetype<usize>(entries)); // tslint:disable-line\r\n    if (isManaged<K>() || isManaged<V>()) {\r\n      let offset: usize = 0;\r\n      let end: usize = this.entriesOffset * ENTRY_SIZE<K,V>();\r\n      while (offset < end) {\r\n        let entry = changetype<MapEntry<K,V>>(\r\n          changetype<usize>(entries) + HEADER_SIZE_AB + offset * ENTRY_SIZE<K,V>()\r\n        );\r\n        if (!(entry.taggedNext & EMPTY)) {\r\n          if (isManaged<K>()) __gc_mark(changetype<usize>(entry.key)); // tslint:disable-line\r\n          if (isManaged<V>()) __gc_mark(changetype<usize>(entry.value)); // tslint:disable-line\r\n        }\r\n        offset += ENTRY_SIZE<K,V>();\r\n      }\r\n    }\r\n  }\r\n}\r\n","import {\r\n  HEADER_SIZE,\r\n  MAX_BLENGTH,\r\n  allocateUnsafe\r\n} from \"./internal/arraybuffer\";\r\n\r\n@sealed\r\nexport class ArrayBuffer {\r\n\r\n  readonly byteLength: i32; // capped to [0, MAX_LENGTH]\r\n\r\n  // @unsafe\r\n  get data(): usize { return changetype<usize>(this) + HEADER_SIZE; }\r\n\r\n  constructor(length: i32, unsafe: bool = false) {\r\n    if (<u32>length > <u32>MAX_BLENGTH) throw new RangeError(\"Invalid array buffer length\");\r\n    var buffer = allocateUnsafe(length);\r\n    if (!unsafe) memory.fill(changetype<usize>(buffer) + HEADER_SIZE, 0, <usize>length);\r\n    return buffer;\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = MAX_BLENGTH): ArrayBuffer {\r\n    var len = this.byteLength;\r\n    if (begin < 0) begin = max(len + begin, 0);\r\n    else begin = min(begin, len);\r\n    if (end < 0) end = max(len + end, 0);\r\n    else end = min(end, len);\r\n    var newLen = max(end - begin, 0);\r\n    var buffer = allocateUnsafe(newLen);\r\n    memory.copy(changetype<usize>(buffer) + HEADER_SIZE, changetype<usize>(this) + HEADER_SIZE + begin, newLen);\r\n    return buffer;\r\n  }\r\n\r\n  toString(): string {\r\n    return \"[object ArrayBuffer]\";\r\n  }\r\n}\r\n","// this function will go away once `memory.copy` becomes an intrinsic\r\nexport function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\r\n  var w: u32, x: u32;\r\n\r\n  // copy 1 byte each until src is aligned to 4 bytes\r\n  while (n && (src & 3)) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    n--;\r\n  }\r\n\r\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\r\n  if ((dest & 3) == 0) {\r\n    while (n >= 16) {\r\n      store<u32>(dest     , load<u32>(src     ));\r\n      store<u32>(dest +  4, load<u32>(src +  4));\r\n      store<u32>(dest +  8, load<u32>(src +  8));\r\n      store<u32>(dest + 12, load<u32>(src + 12));\r\n      src += 16; dest += 16; n -= 16;\r\n    }\r\n    if (n & 8) {\r\n      store<u32>(dest    , load<u32>(src    ));\r\n      store<u32>(dest + 4, load<u32>(src + 4));\r\n      dest += 8; src += 8;\r\n    }\r\n    if (n & 4) {\r\n      store<u32>(dest, load<u32>(src));\r\n      dest += 4; src += 4;\r\n    }\r\n    if (n & 2) { // drop to 2 bytes each\r\n      store<u16>(dest, load<u16>(src));\r\n      dest += 2; src += 2;\r\n    }\r\n    if (n & 1) { // drop to 1 byte\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    return;\r\n  }\r\n\r\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\r\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\r\n  if (n >= 32) {\r\n    switch (dest & 3) {\r\n      // known to be != 0\r\n      case 1: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 3;\r\n        while (n >= 17) {\r\n          x = load<u32>(src + 1);\r\n          store<u32>(dest, w >> 24 | x << 8);\r\n          w = load<u32>(src + 5);\r\n          store<u32>(dest + 4, x >> 24 | w << 8);\r\n          x = load<u32>(src + 9);\r\n          store<u32>(dest + 8, w >> 24 | x << 8);\r\n          w = load<u32>(src + 13);\r\n          store<u32>(dest + 12, x >> 24 | w << 8);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 2: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 2;\r\n        while (n >= 18) {\r\n          x = load<u32>(src + 2);\r\n          store<u32>(dest, w >> 16 | x << 16);\r\n          w = load<u32>(src + 6);\r\n          store<u32>(dest + 4, x >> 16 | w << 16);\r\n          x = load<u32>(src + 10);\r\n          store<u32>(dest + 8, w >> 16 | x << 16);\r\n          w = load<u32>(src + 14);\r\n          store<u32>(dest + 12, x >> 16 | w << 16);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 1;\r\n        while (n >= 19) {\r\n          x = load<u32>(src + 3);\r\n          store<u32>(dest, w >> 8 | x << 24);\r\n          w = load<u32>(src + 7);\r\n          store<u32>(dest + 4, x >> 8 | w << 24);\r\n          x = load<u32>(src + 11);\r\n          store<u32>(dest + 8, w >> 8 | x << 24);\r\n          w = load<u32>(src + 15);\r\n          store<u32>(dest + 12, x >> 8 | w << 24);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // copy remaining bytes one by one\r\n  if (n & 16) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 8) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 4) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 2) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 1) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n}\r\n\r\n// this function will go away once `memory.copy` becomes an intrinsic\r\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n  if (dest === src) return;\r\n  if (src + n <= dest || dest + n <= src) {\r\n    memcpy(dest, src, n);\r\n    return;\r\n  }\r\n  if (dest < src) {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while (dest & 7) {\r\n        if (!n) return;\r\n        --n;\r\n        store<u8>(dest++, load<u8>(src++));\r\n      }\r\n      while (n >= 8) {\r\n        store<u64>(dest, load<u64>(src));\r\n        n    -= 8;\r\n        dest += 8;\r\n        src  += 8;\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while ((dest + n) & 7) {\r\n        if (!n) return;\r\n        store<u8>(dest + --n, load<u8>(src + n));\r\n      }\r\n      while (n >= 8) {\r\n        n -= 8;\r\n        store<u64>(dest + n, load<u64>(src + n));\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest + --n, load<u8>(src + n));\r\n    }\r\n  }\r\n}\r\n\r\n// this function will go away once `memory.fill` becomes an intrinsic\r\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n\r\n  // fill head and tail with minimal branching\r\n  if (!n) return;\r\n  store<u8>(dest, c);\r\n  store<u8>(dest + n - 1, c);\r\n  if (n <= 2) return;\r\n\r\n  store<u8>(dest + 1, c);\r\n  store<u8>(dest + 2, c);\r\n  store<u8>(dest + n - 2, c);\r\n  store<u8>(dest + n - 3, c);\r\n  if (n <= 6) return;\r\n  store<u8>(dest + 3, c);\r\n  store<u8>(dest + n - 4, c);\r\n  if (n <= 8) return;\r\n\r\n  // advance pointer to align it at 4-byte boundary\r\n  var k: usize = -dest & 3;\r\n  dest += k;\r\n  n -= k;\r\n  n &= -4;\r\n\r\n  var c32: u32 = <u32>-1 / 255 * c;\r\n\r\n  // fill head/tail up to 28 bytes each in preparation\r\n  store<u32>(dest, c32);\r\n  store<u32>(dest + n - 4, c32);\r\n  if (n <= 8) return;\r\n  store<u32>(dest + 4, c32);\r\n  store<u32>(dest + 8, c32);\r\n  store<u32>(dest + n - 12, c32);\r\n  store<u32>(dest + n - 8, c32);\r\n  if (n <= 24) return;\r\n  store<u32>(dest + 12, c32);\r\n  store<u32>(dest + 16, c32);\r\n  store<u32>(dest + 20, c32);\r\n  store<u32>(dest + 24, c32);\r\n  store<u32>(dest + n - 28, c32);\r\n  store<u32>(dest + n - 24, c32);\r\n  store<u32>(dest + n - 20, c32);\r\n  store<u32>(dest + n - 16, c32);\r\n\r\n  // align to a multiple of 8\r\n  k = 24 + (dest & 4);\r\n  dest += k;\r\n  n -= k;\r\n\r\n  // copy 32 bytes each\r\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\r\n  while (n >= 32) {\r\n    store<u64>(dest, c64);\r\n    store<u64>(dest + 8, c64);\r\n    store<u64>(dest + 16, c64);\r\n    store<u64>(dest + 24, c64);\r\n    n -= 32;\r\n    dest += 32;\r\n  }\r\n}\r\n\r\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\r\n  if (vl == vr) return 0;\r\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\r\n    n--; vl++; vr++;\r\n  }\r\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\r\n}\r\n","import { CanvasRenderingContext2D } from \"../renderer/CanvasRenderingContext2D\";\r\n\r\nlet map = new Map<string, CanvasRenderingContext2D>();\r\n\r\nexport function __use_context(name: string, id: i32): void {\r\n  var result = new CanvasRenderingContext2D();\r\n  store<i32>(changetype<usize>(result) + offsetof<CanvasRenderingContext2D>(\"id\"), id);\r\n  map.set(name, result);\r\n}\r\n\r\nexport function getContextById(name: string): CanvasRenderingContext2D {\r\n  if (!map.has(name)) throw new Error(\"Cannot find context with name: \" + name);\r\n  return map.get(name);\r\n}\r\n","\r\nimport { STORE } from \"internal/arraybuffer\";\r\n\r\nexport class Buffer<T extends i32> {\r\n  protected buffer: ArrayBuffer = new ArrayBuffer(0x10000 * 8, true);\r\n  private offset: i32 = 0;\r\n\r\n  @inline\r\n  protected write_zero(inst: T): void {\r\n    var buff: ArrayBuffer = this.buffer;\r\n    var index: i32 = this.offset;\r\n    var next: i32 = index + 2;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    this.offset = next;\r\n  }\r\n\r\n  @inline\r\n  protected write_one(inst: T, a: f64): void {\r\n    var buff: ArrayBuffer = this.buffer;\r\n    var index: i32 = this.offset;\r\n    var next: i32 = index + 3;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    this.offset = next;\r\n  }\r\n\r\n  @inline\r\n  protected write_two(inst: T, a: f64, b: f64): void {\r\n    var buff: ArrayBuffer = this.buffer;\r\n    var index: i32 = this.offset;\r\n    var next: i32 = index + 4;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    this.offset = next;\r\n  }\r\n\r\n  @inline\r\n  protected write_four(inst: T, a: f64, b: f64, c: f64, d: f64): void {\r\n    var buff: ArrayBuffer = this.buffer;\r\n    var index: i32 = this.offset;\r\n    var next: i32 = index + 6;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    STORE<f64>(buff, index + 4, c);\r\n    STORE<f64>(buff, index + 5, d);\r\n    this.offset = next;\r\n  }\r\n}\r\n","export enum CanvasDirection {\r\n  ltr = 0,\r\n  rtl = 1,\r\n  inherit = 2,\r\n}\r\n","import {\r\n  HEADER_SIZE\r\n} from \"./string\";\r\n\r\n/** Computes the 32-bit hash of a value of any type. */\r\n@inline\r\nexport function HASH<T>(key: T): u32 {\r\n  // branch-level tree-shaking makes this a `(return (call ...))`\r\n  if (isString(key)) {\r\n    return hashStr(key);\r\n  } else if (isReference<T>()) {\r\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\r\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\r\n  } else if (isFloat<T>()) {\r\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(key));\r\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(key));\r\n  } else {\r\n    if (sizeof<T>() == 1) return hash8 (<u32>key);\r\n    if (sizeof<T>() == 2) return hash16(<u32>key);\r\n    if (sizeof<T>() == 4) return hash32(<u32>key);\r\n    if (sizeof<T>() == 8) return hash64(<u64>key);\r\n  }\r\n  unreachable();\r\n}\r\n\r\n// FNV-1a 32-bit as a starting point, see: http://isthe.com/chongo/tech/comp/fnv/\r\n\r\nconst FNV_OFFSET: u32 = 2166136261;\r\nconst FNV_PRIME: u32 = 16777619;\r\n\r\nfunction hash8(key: u32): u32 {\r\n  return (FNV_OFFSET ^ key) * FNV_PRIME;\r\n}\r\n\r\nfunction hash16(key: u32): u32 {\r\n  var v = FNV_OFFSET;\r\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( key >>  8        )) * FNV_PRIME;\r\n  return v;\r\n}\r\n\r\nfunction hash32(key: u32): u32 {\r\n  var v = FNV_OFFSET;\r\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((key >>  8) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((key >> 16) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( key >> 24        )) * FNV_PRIME;\r\n  return v;\r\n}\r\n\r\nfunction hash64(key: u64): u32 {\r\n  var l = <u32> key;\r\n  var h = <u32>(key >>> 32);\r\n  var v = FNV_OFFSET;\r\n  v = (v ^ ( l        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((l >>  8) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((l >> 16) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( l >> 24        )) * FNV_PRIME;\r\n  v = (v ^ ( h        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((h >>  8) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((h >> 16) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( h >> 24        )) * FNV_PRIME;\r\n  return v;\r\n}\r\n\r\nfunction hashStr(key: string): u32 {\r\n  var v = FNV_OFFSET;\r\n  for (let i: usize = 0, k: usize = key.length << 1; i < k; ++i) {\r\n    v = (v ^ <u32>load<u8>(changetype<usize>(key) + i, HEADER_SIZE)) * FNV_PRIME;\r\n  }\r\n  return v;\r\n}\r\n","import { MAX_SIZE_32 } from \"./allocator\";\r\nimport { String } from \"../string\";\r\n\r\n/** Size of a String header. */\r\nexport const HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\r\n/** Maximum length of a String. */\r\nexport const MAX_LENGTH = (<i32>MAX_SIZE_32 - HEADER_SIZE) >>> 1;\r\n\r\n// Low-level utility\r\n\r\nfunction __gc(ref: usize): void {}\r\n\r\nexport function allocateUnsafe(length: i32): String {\r\n  assert(length > 0 && length <= MAX_LENGTH);\r\n  var buffer: usize;\r\n  if (isManaged<String>()) {\r\n    buffer = __gc_allocate(HEADER_SIZE + (<usize>length << 1), __gc);  // tslint:disable-line\r\n  } else {\r\n    buffer = memory.allocate(HEADER_SIZE + (<usize>length << 1));\r\n  }\r\n  store<i32>(buffer, length);\r\n  return changetype<String>(buffer);\r\n}\r\n\r\n@inline\r\nexport function freeUnsafe(buffer: String): void {\r\n  if (!isManaged<String>()) {\r\n    assert(buffer);\r\n    memory.free(changetype<usize>(buffer));\r\n  }\r\n}\r\n\r\nexport function copyUnsafe(dest: String, destOffset: usize, src: String, srcOffset: usize, len: usize): void {\r\n  memory.copy(\r\n    changetype<usize>(dest) + (destOffset << 1) + HEADER_SIZE,\r\n    changetype<usize>(src)  + (srcOffset  << 1) + HEADER_SIZE,\r\n    len << 1\r\n  );\r\n}\r\n\r\nexport function compareUnsafe(str1: String, offset1: usize, str2: String, offset2: usize, len: usize): i32 {\r\n  var cmp: i32 = 0;\r\n  var ptr1 = changetype<usize>(str1) + (offset1 << 1);\r\n  var ptr2 = changetype<usize>(str2) + (offset2 << 1);\r\n  while (len && !(cmp = <i32>load<u16>(ptr1, HEADER_SIZE) - <i32>load<u16>(ptr2, HEADER_SIZE))) {\r\n    --len, ptr1 += 2, ptr2 += 2;\r\n  }\r\n  return cmp;\r\n}\r\n\r\nexport function repeatUnsafe(dest: String, destOffset: usize, src: String, count: i32): void {\r\n  var length = src.length;\r\n  if (ASC_SHRINK_LEVEL > 1) {\r\n    let strLen = length << 1;\r\n    let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\r\n    let from = changetype<usize>(src)  + HEADER_SIZE;\r\n    for (let i = 0, len = strLen * count; i < len; i += strLen) {\r\n      memory.copy(to + i, from, strLen);\r\n    }\r\n  } else {\r\n    switch (length) {\r\n      case 0: break;\r\n      case 1: {\r\n        let cc =  load<u16>(changetype<usize>(src), HEADER_SIZE);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u16>(out + (i << 1), cc, HEADER_SIZE);\r\n        }\r\n        break;\r\n      }\r\n      case 2: {\r\n        let cc  = load<u32>(changetype<usize>(src), HEADER_SIZE);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u32>(out + (i << 2), cc, HEADER_SIZE);\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        let cc1 = load<u32>(changetype<usize>(src), HEADER_SIZE + 0);\r\n        let cc2 = load<u16>(changetype<usize>(src), HEADER_SIZE + 4);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u32>(out + (i << 2), cc1, HEADER_SIZE + 0);\r\n          store<u16>(out + (i << 1), cc2, HEADER_SIZE + 4);\r\n        }\r\n        break;\r\n      }\r\n      case 4: {\r\n        let cc = load<u64>(changetype<usize>(src), HEADER_SIZE);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u64>(out + (i << 3), cc, HEADER_SIZE);\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        let strLen = length << 1;\r\n        let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\r\n        let from = changetype<usize>(src)  + HEADER_SIZE;\r\n        for (let i = 0, len = strLen * count; i < len; i += strLen) {\r\n          memory.copy(to + i, from, strLen);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Helpers\r\n\r\nexport const enum CharCode {\r\n  PLUS = 0x2B,\r\n  MINUS = 0x2D,\r\n  DOT = 0x2E,\r\n  _0 = 0x30,\r\n  _1 = 0x31,\r\n  _2 = 0x32,\r\n  _3 = 0x33,\r\n  _4 = 0x34,\r\n  _5 = 0x35,\r\n  _6 = 0x36,\r\n  _7 = 0x37,\r\n  _8 = 0x38,\r\n  _9 = 0x39,\r\n  A = 0x41,\r\n  B = 0x42,\r\n  E = 0x45,\r\n  N = 0x4E,\r\n  O = 0x4F,\r\n  X = 0x58,\r\n  Z = 0x5a,\r\n  a = 0x61,\r\n  b = 0x62,\r\n  e = 0x65,\r\n  n = 0x6E,\r\n  o = 0x6F,\r\n  x = 0x78,\r\n  z = 0x7A\r\n}\r\n\r\nexport function isWhiteSpaceOrLineTerminator(c: u16): bool {\r\n  switch (c) {\r\n    case 9:    // <TAB>\r\n    case 10:   // <LF>\r\n    case 13:   // <CR>\r\n    case 11:   // <VT>\r\n    case 12:   // <FF>\r\n    case 32:   // <SP>\r\n    case 160:  // <NBSP>\r\n    case 8232: // <LS>\r\n    case 8233: // <PS>\r\n    case 65279: return true; // <ZWNBSP>\r\n    default: return false;\r\n  }\r\n}\r\n\r\n/** Parses a string to an integer (usually), using the specified radix. */\r\nexport function parse<T>(str: String, radix: i32 = 0): T {\r\n  var len: i32 = str.length;\r\n  if (!len) return <T>NaN;\r\n\r\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\r\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n\r\n  // determine sign\r\n  var sign: T;\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) return <T>NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) return <T>NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = 1;\r\n  } else {\r\n    sign = 1;\r\n  }\r\n\r\n  // determine radix\r\n  if (!radix) {\r\n    if (code == CharCode._0 && len > 2) {\r\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\r\n        case CharCode.B:\r\n        case CharCode.b: {\r\n          ptr += 4; len -= 2;\r\n          radix = 2;\r\n          break;\r\n        }\r\n        case CharCode.O:\r\n        case CharCode.o: {\r\n          ptr += 4; len -= 2;\r\n          radix = 8;\r\n          break;\r\n        }\r\n        case CharCode.X:\r\n        case CharCode.x: {\r\n          ptr += 4; len -= 2;\r\n          radix = 16;\r\n          break;\r\n        }\r\n        default: radix = 10;\r\n      }\r\n    } else radix = 10;\r\n  } else if (radix < 2 || radix > 36) {\r\n    return <T>NaN;\r\n  }\r\n\r\n  // calculate value\r\n  var num: T = 0;\r\n  while (len--) {\r\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n    if (code >= CharCode._0 && code <= CharCode._9) {\r\n      code -= CharCode._0;\r\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\r\n      code -= CharCode.A - 10;\r\n    } else if (code >= CharCode.a && code <= CharCode.z) {\r\n      code -= CharCode.a - 10;\r\n    } else break;\r\n    if (code >= radix) break;\r\n    num = (num * radix) + code;\r\n    ptr += 2;\r\n  }\r\n  return sign * num;\r\n}\r\n","import {\r\n  HEADER_SIZE,\r\n  MAX_LENGTH,\r\n  allocateUnsafe,\r\n  compareUnsafe,\r\n  repeatUnsafe,\r\n  copyUnsafe,\r\n  isWhiteSpaceOrLineTerminator,\r\n  CharCode,\r\n  parse\r\n} from \"./internal/string\";\r\n\r\nimport {\r\n  STORE\r\n} from \"./internal/arraybuffer\";\r\n\r\n@sealed\r\nexport class String {\r\n\r\n  readonly length: i32; // capped to [0, MAX_LENGTH]\r\n\r\n  // TODO Add and handle second argument\r\n  static fromCharCode(code: i32): String {\r\n    var out = allocateUnsafe(1);\r\n    store<u16>(\r\n      changetype<usize>(out),\r\n      <u16>code,\r\n      HEADER_SIZE\r\n    );\r\n    return out;\r\n  }\r\n\r\n  static fromCodePoint(code: i32): String {\r\n    assert(<u32>code <= 0x10FFFF);\r\n    var sur = code > 0xFFFF;\r\n    var out = allocateUnsafe(<i32>sur + 1);\r\n    if (!sur) {\r\n      store<u16>(\r\n        changetype<usize>(out),\r\n        <u16>code,\r\n        HEADER_SIZE\r\n      );\r\n    } else {\r\n      code -= 0x10000;\r\n      let hi: u32 = (code >>> 10)  + 0xD800;\r\n      let lo: u32 = (code & 0x3FF) + 0xDC00;\r\n      store<u32>(\r\n        changetype<usize>(out),\r\n        (hi << 16) | lo,\r\n        HEADER_SIZE\r\n      );\r\n    }\r\n    return out;\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  charAt(pos: i32): String {\r\n    assert(this !== null);\r\n\r\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\r\n\r\n    var out = allocateUnsafe(1);\r\n    store<u16>(\r\n      changetype<usize>(out),\r\n      load<u16>(\r\n        changetype<usize>(this) + (<usize>pos << 1),\r\n        HEADER_SIZE\r\n      ),\r\n      HEADER_SIZE\r\n    );\r\n    return out;\r\n  }\r\n\r\n  charCodeAt(pos: i32): i32 {\r\n    assert(this !== null);\r\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\r\n\r\n    return load<u16>(\r\n      changetype<usize>(this) + (<usize>pos << 1),\r\n      HEADER_SIZE\r\n    );\r\n  }\r\n\r\n  codePointAt(pos: i32): i32 {\r\n    assert(this !== null);\r\n    if (<u32>pos >= <u32>this.length) return -1; // (undefined)\r\n\r\n    var first = <i32>load<u16>(\r\n      changetype<usize>(this) + (<usize>pos << 1),\r\n      HEADER_SIZE\r\n    );\r\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) {\r\n      return first;\r\n    }\r\n    var second = <i32>load<u16>(\r\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\r\n      HEADER_SIZE\r\n    );\r\n    if (second < 0xDC00 || second > 0xDFFF) return first;\r\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\r\n  }\r\n\r\n  @operator(\"+\")\r\n  private static __concat(left: String, right: String): String {\r\n    if (!changetype<usize>(left)) left = changetype<String>(\"null\");\r\n    return left.concat(right);\r\n  }\r\n\r\n  concat(other: String): String {\r\n    assert(this !== null);\r\n    if (other === null) other = changetype<String>(\"null\");\r\n\r\n    var thisLen: isize = this.length;\r\n    var otherLen: isize = other.length;\r\n    var outLen: usize = thisLen + otherLen;\r\n    if (outLen == 0) return changetype<String>(\"\");\r\n    var out = allocateUnsafe(outLen);\r\n    copyUnsafe(out, 0, this, 0, thisLen);\r\n    copyUnsafe(out, thisLen, other, 0, otherLen);\r\n    return out;\r\n  }\r\n\r\n  endsWith(searchString: String, endPosition: i32 = MAX_LENGTH): bool {\r\n    assert(this !== null);\r\n    if (searchString === null) return false;\r\n    var end = min(max(endPosition, 0), this.length);\r\n    var searchLength: isize = searchString.length;\r\n    var start: isize = end - searchLength;\r\n    if (start < 0) return false;\r\n    return !compareUnsafe(this, start, searchString, 0, searchLength);\r\n  }\r\n\r\n  @operator(\"==\")\r\n  private static __eq(left: String, right: String): bool {\r\n    if (left === right) return true;\r\n    if (left === null || right === null) return false;\r\n\r\n    var leftLength = left.length;\r\n    if (leftLength != right.length) return false;\r\n\r\n    return !compareUnsafe(left, 0, right, 0, leftLength);\r\n  }\r\n\r\n  @operator(\"!=\")\r\n  private static __ne(left: String, right: String): bool {\r\n    return !this.__eq(left, right);\r\n  }\r\n\r\n  @operator(\">\")\r\n  private static __gt(left: String, right: String): bool {\r\n    if (left === right || left === null || right === null) return false;\r\n\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n\r\n    if (!leftLength)  return false;\r\n    if (!rightLength) return true;\r\n\r\n    var length = <usize>min<i32>(leftLength, rightLength);\r\n    return compareUnsafe(left, 0, right, 0, length) > 0;\r\n  }\r\n\r\n  @operator(\">=\")\r\n  private static __gte(left: String, right: String): bool {\r\n    if (left === right) return true;\r\n    if (left === null || right === null) return false;\r\n\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n\r\n    if (!leftLength)  return !rightLength;\r\n    if (!rightLength) return true;\r\n\r\n    var length = <usize>min<i32>(leftLength, rightLength);\r\n    return compareUnsafe(left, 0, right, 0, length) >= 0;\r\n  }\r\n\r\n  @operator(\"<\")\r\n  private static __lt(left: String, right: String): bool {\r\n    if (left === right || left === null || right === null) return false;\r\n\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n\r\n    if (!rightLength) return false;\r\n    if (!leftLength)  return true;\r\n\r\n    var length = <usize>min<i32>(leftLength, rightLength);\r\n    return compareUnsafe(left, 0, right, 0, length) < 0;\r\n  }\r\n\r\n  @operator(\"<=\")\r\n  private static __lte(left: String, right: String): bool {\r\n    if (left === right) return true;\r\n    if (left === null || right === null) return false;\r\n\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n\r\n    if (!rightLength) return !leftLength;\r\n    if (!leftLength)  return true;\r\n\r\n    var length = <usize>min<i32>(leftLength, rightLength);\r\n    return compareUnsafe(left, 0, right, 0, length) <= 0;\r\n  }\r\n\r\n  @inline\r\n  includes(searchString: String, position: i32 = 0): bool {\r\n    return this.indexOf(searchString, position) != -1;\r\n  }\r\n\r\n  indexOf(searchString: String, fromIndex: i32 = 0): i32 {\r\n    assert(this !== null);\r\n    if (searchString === null) searchString = changetype<String>(\"null\");\r\n\r\n    var searchLen: isize = searchString.length;\r\n    if (!searchLen) return 0;\r\n    var len: isize = this.length;\r\n    if (!len) return -1;\r\n    var start = min<isize>(max<isize>(fromIndex, 0), len);\r\n    len -= searchLen;\r\n    for (let k: isize = start; k <= len; ++k) {\r\n      if (!compareUnsafe(this, k, searchString, 0, searchLen)) return <i32>k;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  lastIndexOf(searchString: String, fromIndex: i32 = i32.MAX_VALUE): i32 {\r\n    assert(this !== null);\r\n    if (searchString === null) searchString = changetype<String>(\"null\");\r\n\r\n    var len: isize = this.length;\r\n    var searchLen: isize = searchString.length;\r\n    if (!searchLen) return len;\r\n    if (!len) return -1;\r\n    var start = min<isize>(max(fromIndex, 0), len - searchLen);\r\n    for (let k = start; k >= 0; --k) {\r\n      if (!compareUnsafe(this, k, searchString, 0, searchLen)) return <i32>k;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  startsWith(searchString: String, position: i32 = 0): bool {\r\n    assert(this !== null);\r\n    if (searchString === null) searchString = changetype<String>(\"null\");\r\n\r\n    var pos: isize = position;\r\n    var len: isize = this.length;\r\n    var start = min(max(pos, 0), len);\r\n    var searchLength: isize = searchString.length;\r\n    if (searchLength + start > len) return false;\r\n    return !compareUnsafe(this, start, searchString, 0, searchLength);\r\n  }\r\n\r\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\r\n    assert(this !== null);\r\n    var intStart: isize = start;\r\n    var end: isize = length;\r\n    var size: isize = this.length;\r\n    if (intStart < 0) intStart = max(size + intStart, 0);\r\n    var resultLength = min(max(end, 0), size - intStart);\r\n    if (resultLength <= 0) return changetype<String>(\"\");\r\n    var out = allocateUnsafe(resultLength);\r\n    copyUnsafe(out, 0, this, intStart, resultLength);\r\n    return out;\r\n  }\r\n\r\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\r\n    assert(this !== null);\r\n    var len = this.length;\r\n    var finalStart = min(max(start, 0), len);\r\n    var finalEnd = min(max(end, 0), len);\r\n    var from = min<i32>(finalStart, finalEnd);\r\n    var to = max<i32>(finalStart, finalEnd);\r\n    len = to - from;\r\n    if (!len) return changetype<String>(\"\");\r\n    if (!from && to == this.length) return this;\r\n    var out = allocateUnsafe(len);\r\n    copyUnsafe(out, 0, this, from, len);\r\n    return out;\r\n  }\r\n\r\n  trim(): String {\r\n    assert(this !== null);\r\n    var length: usize = this.length;\r\n\r\n    while (\r\n      length &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (length << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      --length;\r\n    }\r\n    var start: usize = 0;\r\n    while (\r\n      start < length &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      ++start, --length;\r\n    }\r\n    if (!length) return changetype<String>(\"\");\r\n    if (!start && length == this.length) return this;\r\n    var out = allocateUnsafe(length);\r\n    copyUnsafe(out, 0, this, start, length);\r\n    return out;\r\n  }\r\n\r\n  @inline\r\n  trimLeft(): String {\r\n    return this.trimStart();\r\n  }\r\n\r\n  @inline\r\n  trimRight(): String {\r\n    return this.trimEnd();\r\n  }\r\n\r\n  trimStart(): String {\r\n    assert(this !== null);\r\n    var start: isize = 0;\r\n    var len: isize = this.length;\r\n    while (\r\n      start < len &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      ++start;\r\n    }\r\n    if (!start) return this;\r\n    var outLen = len - start;\r\n    if (!outLen) return changetype<String>(\"\");\r\n    var out = allocateUnsafe(outLen);\r\n    copyUnsafe(out, 0, this, start, outLen);\r\n    return out;\r\n  }\r\n\r\n  trimEnd(): String {\r\n    assert(this !== null);\r\n    var len: isize = this.length;\r\n    while (\r\n      len > 0 &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (len << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      --len;\r\n    }\r\n    if (len <= 0) return changetype<String>(\"\");\r\n    if (<i32>len == this.length) return this;\r\n    var out = allocateUnsafe(len);\r\n    copyUnsafe(out, 0, this, 0, len);\r\n    return out;\r\n  }\r\n\r\n  padStart(targetLength: i32, padString: String = changetype<String>(\" \")): String {\r\n    assert(this !== null);\r\n    var length = this.length;\r\n    var padLen = padString.length;\r\n    if (targetLength < length || !padLen) return this;\r\n    var len = targetLength - length;\r\n    var out = allocateUnsafe(targetLength);\r\n    if (len > padLen) {\r\n      let count = (len - 1) / padLen;\r\n      let base  = count * padLen;\r\n      let rest  = len - base;\r\n      repeatUnsafe(out, 0, padString, count);\r\n      if (rest) copyUnsafe(out, base, padString, 0, rest);\r\n    } else {\r\n      copyUnsafe(out, 0, padString, 0, len);\r\n    }\r\n    if (length) copyUnsafe(out, len, this, 0, length);\r\n    return out;\r\n  }\r\n\r\n  padEnd(targetLength: i32, padString: String = changetype<String>(\" \")): String {\r\n    assert(this !== null);\r\n    var length = this.length;\r\n    var padLen = padString.length;\r\n    if (targetLength < length || !padLen) return this;\r\n    var len = targetLength - length;\r\n    var out = allocateUnsafe(targetLength);\r\n    if (length) copyUnsafe(out, 0, this, 0, length);\r\n    if (len > padLen) {\r\n      let count = (len - 1) / padLen;\r\n      let base = count * padLen;\r\n      let rest = len - base;\r\n      repeatUnsafe(out, length, padString, count);\r\n      if (rest) copyUnsafe(out, base + length, padString, 0, rest);\r\n    } else {\r\n      copyUnsafe(out, length, padString, 0, len);\r\n    }\r\n    return out;\r\n  }\r\n\r\n  repeat(count: i32 = 0): String {\r\n    assert(this !== null);\r\n    var length = this.length;\r\n\r\n    // Most browsers can't handle strings 1 << 28 chars or longer\r\n    if (count < 0 || length * count > (1 << 28)) {\r\n      throw new RangeError(\"Invalid count value\");\r\n    }\r\n\r\n    if (count == 0 || !length) return changetype<String>(\"\");\r\n    if (count == 1) return this;\r\n\r\n    var result = allocateUnsafe(length * count);\r\n    repeatUnsafe(result, 0, this, count);\r\n    return result;\r\n  }\r\n\r\n  slice(beginIndex: i32, endIndex: i32 = i32.MAX_VALUE): String {\r\n    var length = this.length;\r\n    var begin = (beginIndex < 0) ? max(beginIndex + length, 0) : min(beginIndex, length);\r\n    var end = (endIndex < 0) ? max(endIndex + length, 0) : min(endIndex, length);\r\n    var len = end - begin;\r\n    if (len <= 0) return changetype<String>(\"\");\r\n    var out = allocateUnsafe(len);\r\n    copyUnsafe(out, 0, this, begin, len);\r\n    return out;\r\n  }\r\n\r\n  split(separator: String = null, limit: i32 = i32.MAX_VALUE): String[] {\r\n    assert(this !== null);\r\n    if (!limit) return new Array<String>();\r\n    if (separator === null) return <String[]>[this];\r\n    var length: isize = this.length;\r\n    var sepLen: isize = separator.length;\r\n    if (limit < 0) limit = i32.MAX_VALUE;\r\n    if (!sepLen) {\r\n      if (!length) return new Array<String>();\r\n      // split by chars\r\n      length = min<isize>(length, <isize>limit);\r\n      let result = new Array<String>(length);\r\n      let buffer = <ArrayBuffer>result.buffer_;\r\n      for (let i: isize = 0; i < length; ++i) {\r\n        let char = allocateUnsafe(1);\r\n        store<u16>(\r\n          changetype<usize>(char),\r\n          load<u16>(\r\n            changetype<usize>(this) + (<usize>i << 1),\r\n            HEADER_SIZE\r\n          ),\r\n          HEADER_SIZE\r\n        );\r\n        STORE<String>(buffer, i, char);\r\n      }\r\n      return result;\r\n    } else if (!length) {\r\n      return <String[]>[changetype<String>(\"\")];\r\n    }\r\n    var result = new Array<String>();\r\n    var end = 0, start = 0, i = 0;\r\n    while ((end = this.indexOf(separator, start)) != -1) {\r\n      let len = end - start;\r\n      if (len > 0) {\r\n        let out = allocateUnsafe(len);\r\n        copyUnsafe(out, 0, this, start, len);\r\n        result.push(out);\r\n      } else {\r\n        result.push(changetype<String>(\"\"));\r\n      }\r\n      if (++i == limit) return result;\r\n      start = end + sepLen;\r\n    }\r\n    if (!start) return <String[]>[this];\r\n    var len = length - start;\r\n    if (len > 0) {\r\n      let out = allocateUnsafe(len);\r\n      copyUnsafe(out, 0, this, start, len);\r\n      result.push(out);\r\n    } else {\r\n      result.push(changetype<String>(\"\"));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  toString(): String {\r\n    return this;\r\n  }\r\n\r\n  get lengthUTF8(): i32 {\r\n    var len = 1; // null terminated\r\n    var pos: usize = 0;\r\n    var end = <usize>this.length;\r\n    while (pos < end) {\r\n      let c = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\r\n      if (c < 128) {\r\n        len += 1; ++pos;\r\n      } else if (c < 2048) {\r\n        len += 2; ++pos;\r\n      } else {\r\n        if (\r\n          (c & 0xFC00) == 0xD800 && pos + 1 < end &&\r\n          (<u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE) & 0xFC00) == 0xDC00\r\n        ) {\r\n          len += 4; pos += 2;\r\n        } else {\r\n          len += 3; ++pos;\r\n        }\r\n      }\r\n    }\r\n    return len;\r\n  }\r\n\r\n  static fromUTF8(ptr: usize, len: usize): String {\r\n    if (len < 1) return changetype<String>(\"\");\r\n    var ptrPos = <usize>0;\r\n    var buf = memory.allocate(<usize>len << 1);\r\n    var bufPos = <usize>0;\r\n    while (ptrPos < len) {\r\n      let cp = <u32>load<u8>(ptr + ptrPos++);\r\n      if (cp < 128) {\r\n        store<u16>(buf + bufPos, cp);\r\n        bufPos += 2;\r\n      } else if (cp > 191 && cp < 224) {\r\n        assert(ptrPos + 1 <= len);\r\n        store<u16>(buf + bufPos, (cp & 31) << 6 | load<u8>(ptr + ptrPos++) & 63);\r\n        bufPos += 2;\r\n      } else if (cp > 239 && cp < 365) {\r\n        assert(ptrPos + 3 <= len);\r\n        cp = (\r\n          (cp                       &  7) << 18 |\r\n          (load<u8>(ptr + ptrPos++) & 63) << 12 |\r\n          (load<u8>(ptr + ptrPos++) & 63) << 6  |\r\n           load<u8>(ptr + ptrPos++) & 63\r\n        ) - 0x10000;\r\n        store<u16>(buf + bufPos, 0xD800 + (cp >> 10));\r\n        bufPos += 2;\r\n        store<u16>(buf + bufPos, 0xDC00 + (cp & 1023));\r\n        bufPos += 2;\r\n      } else {\r\n        assert(ptrPos + 2 <= len);\r\n        store<u16>(buf + bufPos,\r\n          (cp                       & 15) << 12 |\r\n          (load<u8>(ptr + ptrPos++) & 63) << 6  |\r\n           load<u8>(ptr + ptrPos++) & 63\r\n        );\r\n        bufPos += 2;\r\n      }\r\n    }\r\n    assert(ptrPos == len);\r\n    var str = allocateUnsafe(<u32>(bufPos >> 1));\r\n    memory.copy(changetype<usize>(str) + HEADER_SIZE, buf, bufPos);\r\n    memory.free(buf);\r\n    return str;\r\n  }\r\n\r\n  toUTF8(): usize {\r\n    var buf = memory.allocate(<usize>this.lengthUTF8);\r\n    var pos: usize = 0;\r\n    var end = <usize>this.length;\r\n    var off: usize = 0;\r\n    while (pos < end) {\r\n      let c1 = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\r\n      if (c1 < 128) {\r\n        store<u8>(buf + off, c1);\r\n        ++off; ++pos;\r\n      } else if (c1 < 2048) {\r\n        let ptr = buf + off;\r\n        store<u8>(ptr, c1 >> 6      | 192);\r\n        store<u8>(ptr, c1      & 63 | 128, 1);\r\n        off += 2; ++pos;\r\n      } else {\r\n        let ptr = buf + off;\r\n        if ((c1 & 0xFC00) == 0xD800 && pos + 1 < end) {\r\n          let c2 = <u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE);\r\n          if ((c2 & 0xFC00) == 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            store<u8>(ptr, c1 >> 18      | 240);\r\n            store<u8>(ptr, c1 >> 12 & 63 | 128, 1);\r\n            store<u8>(ptr, c1 >> 6  & 63 | 128, 2);\r\n            store<u8>(ptr, c1       & 63 | 128, 3);\r\n            off += 4; pos += 2;\r\n            continue;\r\n          }\r\n        }\r\n        store<u8>(ptr, c1 >> 12      | 224);\r\n        store<u8>(ptr, c1 >> 6  & 63 | 128, 1);\r\n        store<u8>(ptr, c1       & 63 | 128, 2);\r\n        off += 3; ++pos;\r\n      }\r\n    }\r\n    store<u8>(buf + off, 0);\r\n    return buf;\r\n  }\r\n}\r\n\r\nexport function parseInt(str: String, radix: i32 = 0): f64 {\r\n  return parse<f64>(str, radix);\r\n}\r\n\r\nexport function parseI32(str: String, radix: i32 = 0): i32 {\r\n  return parse<i32>(str, radix);\r\n}\r\n\r\nexport function parseI64(str: String, radix: i32 = 0): i64 {\r\n  return parse<i64>(str, radix);\r\n}\r\n\r\n// FIXME: naive implementation\r\nexport function parseFloat(str: String): f64 {\r\n  var len: i32 = str.length;\r\n  if (!len) return NaN;\r\n\r\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\r\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n\r\n  // determine sign\r\n  var sign: f64;\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) return NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) return NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = 1;\r\n  } else {\r\n    sign = 1;\r\n  }\r\n\r\n  // calculate value\r\n  var num: f64 = 0;\r\n  while (len--) {\r\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n    if (code == CharCode.DOT) {\r\n      ptr += 2;\r\n      let fac: f64 = 0.1; // precision :(\r\n      while (len--) {\r\n        code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n        if (code == CharCode.E || code == CharCode.e) {\r\n          assert(false); // TODO\r\n        }\r\n        code -= CharCode._0;\r\n        if (<u32>code > 9) break;\r\n        num += <f64>code * fac;\r\n        fac *= 0.1;\r\n        ptr += 2;\r\n      }\r\n      break;\r\n    }\r\n    code -= CharCode._0;\r\n    if (<u32>code >= 10) break;\r\n    num = (num * 10) + code;\r\n    ptr += 2;\r\n  }\r\n  return sign * num;\r\n}\r\n","// @ts-ignore\r\n@external(\"__canvas_sys\", \"loadImage\")\r\ndeclare function loadImage(img: Image, src: string): i32;\r\n\r\nexport class Image {\r\n  private _id: i32 = -1;\r\n  private _width: i32 = 0;\r\n  private _height: i32 = 0;\r\n  private _loaded: bool = false;\r\n  private _src: string = \"\";\r\n\r\n  @inline\r\n  public get width(): number {\r\n    return this._width;\r\n  }\r\n\r\n  @inline\r\n  public get height(): number {\r\n    return this._height;\r\n  }\r\n\r\n  @inline\r\n  public get loaded(): bool {\r\n    return this._loaded;\r\n  }\r\n\r\n  @inline\r\n  public get src(): string {\r\n    return this._src;\r\n  }\r\n\r\n  public set src(value: string) {\r\n    this._src = value;\r\n    this._id = loadImage(this, value);\r\n  }\r\n}\r\n\r\nexport function __image_loaded(img: Image, width: i32, height: i32): void {\r\n  store<i32>(changetype<usize>(img) + offsetof<Image>(\"_width\"), width);\r\n  store<i32>(changetype<usize>(img) + offsetof<Image>(\"_height\"), height);\r\n  store<bool>(changetype<usize>(img) + offsetof<Image>(\"_loaded\"), true);\r\n}\r\n","import \"allocator/arena\";\r\nimport { getContextById } from \"./internal/getContext\";\r\nimport { CanvasRenderingContext2D } from \"./renderer/CanvasRenderingContext2D\";\r\nimport { Buffer } from \"./internal/Buffer\";\r\n\r\nvar ctx: CanvasRenderingContext2D;\r\n\r\nclass Writer extends Buffer<f64> {\r\n  writeTest(): void {\r\n    this.write_two(0, 1, 2);\r\n  }\r\n}\r\n\r\nvar buff: Writer = new Writer();\r\nexport function init(): void {\r\n  ctx = getContextById(\"main\");\r\n}\r\n\r\nexport function writeThreeTimes(): usize {\r\n  buff.writeTest();\r\n  return changetype<usize>(buff) + offsetof<Writer>(\"buffer\");\r\n}"]}